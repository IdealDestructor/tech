{"title":"前端面经总结","uid":"329c2025145e0b6d6215dadb590fe2d6","slug":"前端面试复习计划","date":"2022-01-04T03:02:15.000Z","updated":"2022-05-18T11:15:56.380Z","comments":true,"path":"api/articles/前端面试复习计划.json","keywords":null,"cover":"https://source.unsplash.com/VivsxaizzVE/1200x628","content":"<p>一、简历</p>\n<p>简历在找工作过程中是非常非常重要的，无论你是什么途径去面试的，面试你的人一定会看你的简历。</p>\n<p>推荐阅读：<br><a href=\"https://link.juejin.cn/?target=https://mp.weixin.qq.com/s/py_HLqOjNdL4l0CZHjMwqw\" title=\"https://mp.weixin.qq.com/s/py_HLqOjNdL4l0CZHjMwqw\">如何写「前端简历」，能敲开字节跳动的大门？</a><br><a href=\"https://link.juejin.cn/?target=https://www.zhihu.com/question/23150301/answer/1229870117\" title=\"https://www.zhihu.com/question/23150301/answer/1229870117\">一份优秀的前端开发工程师简历是怎么样的？</a></p>\n<h3 id=\"1、重点\"><a href=\"#1、重点\" class=\"headerlink\" title=\"1、重点\"></a>1、重点</h3><ul>\n<li>简历就像高考作文——阅卷时间非常短。</li>\n<li>内容要简洁。</li>\n<li>直击重点，表现出自己的优势（只要是符合招人单位要求的都是优势，不是别人不会的你会才叫优势）。</li>\n</ul>\n<h3 id=\"2、简历包含的内容\"><a href=\"#2、简历包含的内容\" class=\"headerlink\" title=\"2、简历包含的内容\"></a>2、简历包含的内容</h3><ul>\n<li>个人信息。</li>\n<li>专业技能。</li>\n<li>工作经历。</li>\n<li>项目经历。</li>\n<li>社区贡献。</li>\n</ul>\n<h4 id=\"2-1-基本信息\"><a href=\"#2-1-基本信息\" class=\"headerlink\" title=\"2.1 基本信息\"></a>2.1 基本信息</h4><ul>\n<li>必备：姓名 电话 邮箱。</li>\n<li>年龄（最好写上，在这个行业年龄还是比较重要的），学历（写好是哪一届）。</li>\n<li>头像无所谓（好看就放上呗）。</li>\n<li>可以放 github 链接，前提是有内容。</li>\n</ul>\n<h4 id=\"2-2-专业技能\"><a href=\"#2-2-专业技能\" class=\"headerlink\" title=\"2.2 专业技能\"></a>2.2 专业技能</h4><ul>\n<li>表现出自己的核心竞争力（只要是符合招人单位要求的都是优势）。</li>\n<li>内容不要太多，3、5 条即可。</li>\n<li>太基础的不要写，例如会用 vscode、lodash。</li>\n</ul>\n<h4 id=\"2-3-工作经历\"><a href=\"#2-3-工作经历\" class=\"headerlink\" title=\"2.3 工作经历\"></a>2.3 工作经历</h4><ul>\n<li>如实写。</li>\n<li>写明公司，职位，入职离职时间即可，多写无益。</li>\n<li>如果有空窗期，如实写明即可。</li>\n</ul>\n<h4 id=\"2-4-项目经历\"><a href=\"#2-4-项目经历\" class=\"headerlink\" title=\"2.4 项目经历\"></a>2.4 项目经历</h4><ul>\n<li>写 2-4 个具有说服力的项目（不要什么项目都写，没用）。</li>\n<li>项目名称，项目描述，技术栈，个人角色。</li>\n</ul>\n<h4 id=\"2-5-社区贡献\"><a href=\"#2-5-社区贡献\" class=\"headerlink\" title=\"2.5 社区贡献\"></a>2.5 社区贡献</h4><ul>\n<li>有博客或者开源作品，会让你更有竞争力。</li>\n<li>切记：需要真的有内容，不可临时抱佛脚。</li>\n</ul>\n<h3 id=\"3、注意事项\"><a href=\"#3、注意事项\" class=\"headerlink\" title=\"3、注意事项\"></a>3、注意事项</h3><ul>\n<li>界面不能太花哨，简洁明了即可。</li>\n<li>注意用词，“精通”“熟练” 等慎用，可用 “熟悉”。</li>\n<li>不可造假，会被拉入黑名单。</li>\n</ul>\n<h3 id=\"4、面试前准备\"><a href=\"#4、面试前准备\" class=\"headerlink\" title=\"4、面试前准备\"></a>4、面试前准备</h3><ul>\n<li>看 JD，是否需要临时准备一下。</li>\n<li>打印纸质简历，带着纸和笔（增加好印象）。</li>\n<li>最好带着自己电脑，现场可能手写代码（带一个帆布包最适合，又优雅又方便）。</li>\n<li>要有时间观念，如果迟到或者推迟，要提前说。</li>\n<li>衣着适当，不用正装，也不要太随意。</li>\n<li>为何离职？—— 不要吐槽前东家，说自己的原因（想找一个更好的发展平台等）。</li>\n<li>能加班吗？—— 能！除非你特别自信，能找到其他机会。</li>\n<li>不要挑战面试官，即便他错了（面试一定要保证愉快）。</li>\n<li>遇到不会的问题，要表现出自己积极的一面（不好意思哈，确实是我的知识盲区，可以跟我说下 xxx 吗，我回去研究一下）。</li>\n</ul>\n<h2 id=\"二、HTML-CSS-面试题\"><a href=\"#二、HTML-CSS-面试题\" class=\"headerlink\" title=\"二、HTML+CSS 面试题\"></a>二、HTML+CSS 面试题</h2><p>HTML 和 CSS 面试题答不出来基本可以回去了。</p>\n<h3 id=\"1、HTML-面试题\"><a href=\"#1、HTML-面试题\" class=\"headerlink\" title=\"1、HTML 面试题\"></a>1、HTML 面试题</h3><p>以下是针对 HTML 相关的面试题，一般来说这地方不会出太多题，面试官也不愿意花太多时间在这上面。</p>\n<h4 id=\"1-1-如何理解-HTML-语义化？\"><a href=\"#1-1-如何理解-HTML-语义化？\" class=\"headerlink\" title=\"1.1 如何理解 HTML 语义化？\"></a>1.1 如何理解 HTML 语义化？</h4><ul>\n<li>让人更容易读懂（增加代码可读性）。</li>\n<li>让搜索引擎更容易读懂，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重（SEO）。</li>\n<li>在没有 CSS 样式下，页面也能呈现出很好地内容结构、代码结构。</li>\n</ul>\n<h4 id=\"1-2-script-标签中-defer-和-async-的区别？\"><a href=\"#1-2-script-标签中-defer-和-async-的区别？\" class=\"headerlink\" title=\"1.2 script 标签中 defer 和 async 的区别？\"></a>1.2 script 标签中 defer 和 async 的区别？</h4><ul>\n<li><code>script</code> ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。</li>\n<li><code>async script</code> ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。</li>\n<li><code>defer script</code>：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。</li>\n</ul>\n<p>下图清晰地展示了三种 <code>script</code> 的过程： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ea091aed8364b88a653a13c4845a824~tplv-k3u1fbpfcp-watermark.awebp\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>推荐文章：</p>\n<ul>\n<li><a href=\"https://juejin.cn/post/6894629999215640583\" title=\"https://juejin.cn/post/6894629999215640583\">图解 script 标签中的 async 和 defer 属性</a></li>\n</ul></blockquote>\n<h4 id=\"1-3-从浏览器地址栏输入-url-到请求返回发生了什么\"><a href=\"#1-3-从浏览器地址栏输入-url-到请求返回发生了什么\" class=\"headerlink\" title=\"1.3 从浏览器地址栏输入 url 到请求返回发生了什么\"></a>1.3 从浏览器地址栏输入 url 到请求返回发生了什么</h4><p>先阅读这篇科普性质的：<a href=\"https://juejin.cn/post/6844903784229896199\" title=\"https://juejin.cn/post/6844903784229896199\">从 URL 输入到页面展现到底发生什么？</a> 先阅读篇文章：<a href=\"https://juejin.cn/post/6935232082482298911\" title=\"https://juejin.cn/post/6935232082482298911\">从输入 URL 开始建立前端知识体系</a>。</p>\n<ol>\n<li>输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。</li>\n</ol>\n<ul>\n<li>强缓存。</li>\n<li>协商缓存。</li>\n</ul>\n<ol start=\"2\">\n<li><p>DNS 域名解析。（<a href=\"https://juejin.cn/post/6990344840181940261\" title=\"https://juejin.cn/post/6990344840181940261\">字节面试被虐后，是时候搞懂 DNS 了</a>）</p>\n</li>\n<li><p>TCP 连接。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点<strong>可靠传输</strong>决定的。客户端和服务端要进行可靠传输，那么就需要<strong>确认双方的接收和发送能力</strong>。第一次握手可以确认客服端的<strong>发送能力</strong>，第二次握手，确认了服务端的<strong>发送能力和接收能力</strong>，所以第三次握手才可以确认客户端的<strong>接收能力</strong>。不然容易出现丢包的现象。</p></blockquote>\n</li>\n<li><p>http 请求。</p>\n</li>\n<li><p>服务器处理请求并返回 HTTP 报文。</p>\n</li>\n<li><p>浏览器渲染页面。</p>\n</li>\n</ol>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77972f24d69243bb93679f155f305095~tplv-k3u1fbpfcp-watermark.awebp\"></p>\n<ol start=\"7\">\n<li>断开 TCP 连接。</li>\n</ol>\n<h3 id=\"2、CSS-面试题\"><a href=\"#2、CSS-面试题\" class=\"headerlink\" title=\"2、CSS 面试题\"></a>2、CSS 面试题</h3><p>以下是针对 CSS 相关的面试题，这些题答不出来会给人非常不好的技术印象。</p>\n<h4 id=\"2-1-盒模型介绍\"><a href=\"#2-1-盒模型介绍\" class=\"headerlink\" title=\"2.1 盒模型介绍\"></a>2.1 盒模型介绍</h4><p>CSS3 中的盒模型有以下两种：<strong>标准盒模型</strong>、<strong>IE（替代）盒模型</strong>。</p>\n<p>两种盒子模型都是由 <code>content + padding + border + margin</code> 构成，其大小都是由 <code>content + padding + border</code> 决定的，但是盒子内容宽 &#x2F; 高度（即 <code>width/height</code>）的计算范围根据盒模型的不同会有所不同：</p>\n<ul>\n<li>标准盒模型：只包含 <code>content</code> 。</li>\n<li>IE（替代）盒模型：<code>content + padding + border</code> 。</li>\n</ul>\n<p>可以通过 <code>box-sizing</code> 来改变元素的盒模型：</p>\n<ul>\n<li><code>box-sizing: content-box</code> ：标准盒模型（默认值）。</li>\n<li><code>box-sizing: border-box</code> ：IE（替代）盒模型。</li>\n</ul>\n<h4 id=\"2-2-css-选择器和优先级\"><a href=\"#2-2-css-选择器和优先级\" class=\"headerlink\" title=\"2.2 css 选择器和优先级\"></a>2.2 css 选择器和优先级</h4><p>首先我们要知道有哪些选择器：<a href=\"https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors%23%25E9%2580%2589%25E6%258B%25A9%25E5%2599%25A8%25E5%258F%2582%25E8%2580%2583%25E8%25A1%25A8\" title=\"https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors#%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%82%E8%80%83%E8%A1%A8\">选择器参考表</a>。</p>\n<p>常规来说，大家都知道样式的优先级一般为 <code>!important &gt; style &gt; id &gt; class</code> ，但是涉及多类选择器作用于同一个元素时候怎么判断优先级呢？相信我，你在改一些第三方库（比如 antd 😂）样式时，理解这个会帮助很大！</p>\n<p>这篇文章写的非常清晰易懂，强烈推荐，看完之后就没啥问题了：<a href=\"https://juejin.cn/post/6844903709772611592\" title=\"https://juejin.cn/post/6844903709772611592\">深入理解 CSS 选择器优先级</a>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>上述文章中核心内容： 优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p>\n<ul>\n<li>如果存在内联样式，那么 <code>A = 1</code>，否则 <code>A = 0</code> ；</li>\n<li>B 的值等于 <code>ID选择器（#id）</code> 出现的次数；</li>\n<li>C 的值等于 <code>类选择器（.class）</code> 和 <code>属性选择器（a[href=&quot;https://example.org&quot;]）</code> 和 <code>伪类（:first-child）</code> 出现的总次数；</li>\n<li>D 的值等于 <code>标签选择器（h1,a,div）</code> 和 <code>伪元素（::before,::after）</code> 出现的总次数。</li>\n</ul></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>从左至右比较，如果是样式优先级相等，取后面出现的样式。</p></blockquote>\n<h4 id=\"2-3-重排（reflow）和重绘（repaint）的理解\"><a href=\"#2-3-重排（reflow）和重绘（repaint）的理解\" class=\"headerlink\" title=\"2.3 重排（reflow）和重绘（repaint）的理解\"></a>2.3 重排（reflow）和重绘（repaint）的理解</h4><p>简单地总结下两者的概念：</p>\n<ul>\n<li>重排：无论通过什么方式影响了元素的<strong>几何信息</strong> (元素在视口内的位置和尺寸大小)，浏览器需要<strong>重新计算</strong>元素在视口内的几何属性，这个过程叫做重排。</li>\n<li>重绘：通过构造渲染树和重排（回流）阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息 (元素在视口内的位置和尺寸大小)，接下来就可以将渲染树的每个节点都转换为屏幕上的<strong>实际像素</strong>，这个阶段就叫做重绘。</li>\n</ul>\n<p>如何减少重排和重绘？</p>\n<ul>\n<li><strong>最小化重绘和重排</strong>，比如样式集中改变，使用添加新样式类名 <code>.class</code> 或 <code>cssText</code> 。</li>\n<li><strong>批量操作 DOM</strong>，比如读取某元素 <code>offsetWidth</code> 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 <code>document.createDocumentFragment()</code> 来添加要被添加的节点，处理完之后再插入到实际 DOM 中。</li>\n<li><strong>使用 <strong><code>**absolute**</code></strong> 或 <strong><code>**fixed**</code></strong> 使元素脱离文档流</strong>，这在制作复杂的动画时对性能的影响比较明显。</li>\n<li><strong>开启 GPU 加速</strong>，利用 css 属性 <code>transform</code> 、<code>will-change</code> 等，比如改变元素位置，我们使用 <code>translate</code> 会比使用绝对定位改变其 <code>left</code> 、<code>top</code> 等来的高效，因为它不会触发重排或重绘，<code>transform</code> 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。</li>\n</ul>\n<p>这里推荐<strong>腾讯 IVWEB 团队</strong>的这篇文章：<a href=\"https://juejin.cn/post/6844903779700047885\" title=\"https://juejin.cn/post/6844903779700047885\">你真的了解回流和重绘吗</a>，好好认真看完，面试应该没问题的。</p>\n<h4 id=\"2-4-对-BFC-的理解\"><a href=\"#2-4-对-BFC-的理解\" class=\"headerlink\" title=\"2.4 对 BFC 的理解\"></a>2.4 对 BFC 的理解</h4><p>BFC 即块级格式上下文，根据盒模型可知，每个元素都被定义为一个矩形盒子，然而盒子的布局会受到<strong>尺寸，定位，盒子的子元素或兄弟元素，视口的尺寸</strong>等因素决定，所以这里有一个浏览器计算的过程，计算的规则就是由一个叫做<strong>视觉格式化模型</strong>的东西所定义的，BFC 就是来自这个概念，它是 CSS 视觉渲染的一部分，<strong>用于决定块级盒的布局及浮动相互影响范围的一个区域</strong>。</p>\n<p>BFC 具有一些特性：</p>\n<ol>\n<li>块级元素会在垂直方向一个接一个的排列，和文档流的排列方式一致。</li>\n<li>在 BFC 中上下相邻的两个容器的 <code>margin</code>  会重叠，创建新的 BFC 可以避免外边距重叠。</li>\n<li>计算 BFC 的高度时，需要计算浮动元素的高度。</li>\n<li>BFC 区域不会与浮动的容器发生重叠。</li>\n<li>BFC 是独立的容器，容器内部元素不会影响外部元素。</li>\n<li>每个元素的左 <code>margin</code>  值和容器的左 <code>border</code>  相接触。</li>\n</ol>\n<p>利用这些特性，我们可以解决以下问题：</p>\n<ul>\n<li>利用 <code>4</code>  和 <code>6</code> ，我们可以实现三栏（或两栏）自适应布局。</li>\n<li>利用 <code>2</code> ，我们可以避免 <code>margin</code>  重叠问题。</li>\n<li>利用 <code>3</code> ，我们可以避免高度塌陷。</li>\n</ul>\n<p>创建 BFC 的方式：</p>\n<ul>\n<li>绝对定位元素（<code>position</code> 为 <code>absolute</code> 或 <code>fixed</code> ）。</li>\n<li>行内块元素，即 <code>display</code> 为 <code>inline-block</code> 。</li>\n<li><code>overflow</code> 的值不为 <code>visible</code> 。</li>\n</ul>\n<p>推荐文章：<a href=\"https://juejin.cn/post/6960866014384881671\" title=\"https://juejin.cn/post/6960866014384881671\">可能是最好的 BFC 解析了…</a></p>\n<h4 id=\"2-5-实现两栏布局（左侧固定-右侧自适应布局）\"><a href=\"#2-5-实现两栏布局（左侧固定-右侧自适应布局）\" class=\"headerlink\" title=\"2.5 实现两栏布局（左侧固定 + 右侧自适应布局）\"></a>2.5 实现两栏布局（左侧固定 + 右侧自适应布局）</h4><p>现在有以下 DOM 结构：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;div class&#x3D;&quot;outer&quot;&gt;\n  &lt;div class&#x3D;&quot;left&quot;&gt;左侧&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;right&quot;&gt;右侧&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n复制代码</code></pre>\n\n<ol>\n<li>利用浮动，左边元素宽度固定 ，设置向左浮动。将右边元素的 <code>margin-left</code> 设为固定宽度 。注意，因为右边元素的 <code>width</code> 默认为 <code>auto</code> ，所以会自动撑满父元素。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.outer &#123;\n  height: 100px;\n&#125;\n.left &#123;\n  float: left;\n  width: 200px;\n  height: 100%;\n  background: lightcoral;\n&#125;\n.right &#123;\n  margin-left: 200px;\n  height: 100%;\n  background: lightseagreen;\n&#125;\n复制代码</code></pre>\n\n<ol start=\"2\">\n<li>同样利用浮动，左边元素宽度固定 ，设置向左浮动。右侧元素设置 <code>overflow: hidden;</code> 这样右边就触发了 <code>BFC</code> ，<code>BFC</code> 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.outer &#123;\n  height: 100px;\n&#125;\n.left &#123;\n  float: left;\n  width: 200px;\n  height: 100%;\n  background: lightcoral;\n&#125;\n.right &#123;\n  overflow: auto;\n  height: 100%;\n  background: lightseagreen;\n&#125;\n复制代码</code></pre>\n\n<ol start=\"3\">\n<li>利用 <code>flex</code> 布局，左边元素固定宽度，右边的元素设置 <code>flex: 1</code> 。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.outer &#123;\n  display: flex;\n  height: 100px;\n&#125;\n.left &#123;\n  width: 200px;\n  height: 100%;\n  background: lightcoral;\n&#125;\n.right &#123;\n  flex: 1;\n  height: 100%;\n  background: lightseagreen;\n&#125;\n复制代码</code></pre>\n\n<ol start=\"4\">\n<li>利用绝对定位，父级元素设为相对定位。左边元素 <code>absolute</code>  定位，宽度固定。右边元素的 <code>margin-left</code>  的值设为左边元素的宽度值。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.outer &#123;\n  position: relative;\n  height: 100px;\n&#125;\n.left &#123;\n  position: absolute;\n  width: 200px;\n  height: 100%;\n  background: lightcoral;\n&#125;\n.right &#123;\n  margin-left: 200px;\n  height: 100%;\n  background: lightseagreen;\n&#125;\n复制代码</code></pre>\n\n<ol start=\"5\">\n<li>利用绝对定位，父级元素设为相对定位。左边元素宽度固定，右边元素 <code>absolute</code>  定位， <code>left</code>  为宽度大小，其余方向定位为 <code>0</code> 。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.outer &#123;\n  position: relative;\n  height: 100px;\n&#125;\n.left &#123;\n  width: 200px;\n  height: 100%;\n  background: lightcoral;\n&#125;\n.right &#123;\n  position: absolute;\n  left: 200px;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  height: 100%;\n  background: lightseagreen;\n&#125;\n复制代码</code></pre>\n\n<h4 id=\"2-6-实现圣杯布局和双飞翼布局（经典三分栏布局）\"><a href=\"#2-6-实现圣杯布局和双飞翼布局（经典三分栏布局）\" class=\"headerlink\" title=\"2.6 实现圣杯布局和双飞翼布局（经典三分栏布局）\"></a>2.6 实现圣杯布局和双飞翼布局（经典三分栏布局）</h4><p>圣杯布局和双飞翼布局的目的：</p>\n<ul>\n<li>三栏布局，中间一栏最先加载和渲染（<strong>内容最重要，这就是为什么还需要了解这种布局的原因</strong>）。</li>\n<li>两侧内容固定，中间内容随着宽度自适应。</li>\n<li>一般用于 PC 网页。</li>\n</ul>\n<p>圣杯布局和双飞翼布局的技术总结：</p>\n<ul>\n<li>使用 <code>float</code>  布局。</li>\n<li>两侧使用 <code>margin</code> 负值，以便和中间内容横向重叠。</li>\n<li>防止中间内容被两侧覆盖，圣杯布局用 <code>padding</code> ，双飞翼布局用 <code>margin</code> 。</li>\n</ul>\n<p><strong>圣杯布局：</strong> HTML 结构：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;div id&#x3D;&quot;container&quot; class&#x3D;&quot;clearfix&quot;&gt;\n  &lt;p class&#x3D;&quot;center&quot;&gt;我是中间&lt;&#x2F;p&gt;\n  &lt;p class&#x3D;&quot;left&quot;&gt;我是左边&lt;&#x2F;p&gt;\n  &lt;p class&#x3D;&quot;right&quot;&gt;我是右边&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n复制代码</code></pre>\n\n<p>CSS 样式：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#container &#123;\n  padding-left: 200px;\n  padding-right: 150px;\n  overflow: auto;\n&#125;\n#container p &#123;\n  float: left;\n&#125;\n.center &#123;\n  width: 100%;\n  background-color: lightcoral;\n&#125;\n.left &#123;\n  width: 200px;\n  position: relative;\n  left: -200px;\n  margin-left: -100%;\n  background-color: lightcyan;\n&#125;\n.right &#123;\n  width: 150px;\n  margin-right: -150px;\n  background-color: lightgreen;\n&#125;\n.clearfix:after &#123;\n  content: &quot;&quot;;\n  display: table;\n  clear: both;\n&#125;\n复制代码</code></pre>\n\n<p><strong>双飞翼布局：</strong> HTML 结构：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;div id&#x3D;&quot;main&quot; class&#x3D;&quot;float&quot;&gt;\n  &lt;div id&#x3D;&quot;main-wrap&quot;&gt;main&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;div id&#x3D;&quot;left&quot; class&#x3D;&quot;float&quot;&gt;left&lt;&#x2F;div&gt;\n&lt;div id&#x3D;&quot;right&quot; class&#x3D;&quot;float&quot;&gt;right&lt;&#x2F;div&gt;\n复制代码</code></pre>\n\n<p>CSS 样式：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.float &#123;\n  float: left;\n&#125;\n#main &#123;\n  width: 100%;\n  height: 200px;\n  background-color: lightpink;\n&#125;\n#main-wrap &#123;\n  margin: 0 190px 0 190px;\n&#125;\n#left &#123;\n  width: 190px;\n  height: 200px;\n  background-color: lightsalmon;\n  margin-left: -100%;\n&#125;\n#right &#123;\n  width: 190px;\n  height: 200px;\n  background-color: lightskyblue;\n  margin-left: -190px;\n&#125;\n复制代码</code></pre>\n\n<p>tips：上述代码中 <code>margin-left: -100%</code>  相对的是父元素的 <code>content</code>  宽度，即不包含 <code>paddig</code> 、 <code>border</code>  的宽度。</p>\n<p>其实以上问题需要掌握 <strong>margin 负值问题</strong> 即可很好理解。</p>\n<h4 id=\"2-7-水平垂直居中多种实现方式\"><a href=\"#2-7-水平垂直居中多种实现方式\" class=\"headerlink\" title=\"2.7 水平垂直居中多种实现方式\"></a>2.7 水平垂直居中多种实现方式</h4><ol>\n<li>利用绝对定位，设置 <code>left: 50%</code>  和 <code>top: 50%</code>  现将子元素左上角移到父元素中心位置，然后再通过 <code>translate</code>  来调整子元素的中心点到父元素的中心。该方法可以<strong>不定宽高</strong>。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.father &#123;\n  position: relative;\n&#125;\n.son &#123;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n&#125;\n复制代码</code></pre>\n\n<ol start=\"2\">\n<li>利用绝对定位，子元素所有方向都为 <code>0</code> ，将 <code>margin</code>  设置为 <code>auto</code> ，由于宽高固定，对应方向实现平分，该方法必须<strong>盒子有宽高</strong>。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.father &#123;\n  position: relative;\n&#125;\n.son &#123;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0px;\n  margin: auto;\n  height: 100px;\n  width: 100px;\n&#125;\n复制代码</code></pre>\n\n<ol start=\"3\">\n<li>利用绝对定位，设置 <code>left: 50%</code> 和 <code>top: 50%</code> 现将子元素左上角移到父元素中心位置，然后再通过 <code>margin-left</code>  和 <code>margin-top</code>  以子元素自己的一半宽高进行负值赋值。该方法<strong>必须定宽高</strong>。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.father &#123;\n  position: relative;\n&#125;\n.son &#123;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  width: 200px;\n  height: 200px;\n  margin-left: -100px;\n  margin-top: -100px;\n&#125;\n复制代码</code></pre>\n\n<ol start=\"4\">\n<li>利用 <code>flex</code> ，最经典最方便的一种了，不用解释，定不定宽高无所谓的。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">.father &#123;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n&#125;\n复制代码</code></pre>\n\n<p>其实还有很多方法，比如 <code>display: grid</code>  或 <code>display: table-cell</code>  来做，有兴趣点击下面这篇文章可以了解下：<br><a href=\"https://juejin.cn/post/6844903982960214029\" title=\"https://juejin.cn/post/6844903982960214029\">面试官：你能实现多少种水平垂直居中的布局（定宽高和不定宽高）</a>。</p>\n<h4 id=\"2-8-flex-布局\"><a href=\"#2-8-flex-布局\" class=\"headerlink\" title=\"2.8 flex 布局\"></a>2.8 flex 布局</h4><p>这一块内容看 <a href=\"https://link.juejin.cn/?target=https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\" title=\"https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\">Flex 布局教程</a> 就够了。</p>\n<p>这里有个小问题，很多时候我们会用到 <code>flex: 1</code> ，它具体包含了以下的意思：</p>\n<ul>\n<li><code>flex-grow: 1</code> ：该属性默认为 <code>0</code> ，如果存在剩余空间，元素也不放大。设置为 <code>1</code>  代表会放大。</li>\n<li><code>flex-shrink: 1</code> ：该属性默认为 <code>1</code> ，如果空间不足，元素缩小。</li>\n<li><code>flex-basis: 0%</code> ：该属性定义在分配多余空间之前，元素占据的主轴空间。浏览器就是根据这个属性来<strong>计算是否有多余空间</strong>的。默认值为 <code>auto</code> ，即项目本身大小。设置为 <code>0%</code>  之后，因为有 <code>flex-grow</code>  和 <code>flex-shrink</code>  的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 <code>flex-basis</code>  设为 <code>auto</code>  的话，其本身大小将会是 <code>0</code> 。</li>\n</ul>\n<h4 id=\"2-9-line-height-如何继承？\"><a href=\"#2-9-line-height-如何继承？\" class=\"headerlink\" title=\"2.9 line-height 如何继承？\"></a>2.9 line-height 如何继承？</h4><ul>\n<li>父元素的 <code>line-height</code> 写了<strong>具体数值</strong>，比如 <code>30px</code>，则子元素 <code>line-height</code> 继承该值。</li>\n<li>父元素的 <code>line-height</code> 写了<strong>比例</strong>，比如 <code>1.5 或 2</code>，则子元素 <code>line-height</code> 也是继承该比例。</li>\n<li>父元素的 <code>line-height</code> 写了<strong>百分比</strong>，比如 <code>200%</code>，则子元素 <code>line-height</code> 继承的是父元素 <code>font-size * 200%</code> 计算出来的值。</li>\n</ul>\n<h2 id=\"三、js-基础\"><a href=\"#三、js-基础\" class=\"headerlink\" title=\"三、js 基础\"></a>三、js 基础</h2><p>js 的考察其实来回就那些东西，不过就我自己而已学习的时候理解是真的理解了，但是忘也确实会忘（大家都说理解了一定不会忘，但是要答全的话还是需要理解 + 背）。</p>\n<h3 id=\"1、数据类型\"><a href=\"#1、数据类型\" class=\"headerlink\" title=\"1、数据类型\"></a>1、数据类型</h3><p>以下是比较重要的几个 js 变量要掌握的点。</p>\n<h4 id=\"1-1-基本的数据类型介绍，及值类型和引用类型的理解\"><a href=\"#1-1-基本的数据类型介绍，及值类型和引用类型的理解\" class=\"headerlink\" title=\"1.1 基本的数据类型介绍，及值类型和引用类型的理解\"></a>1.1 基本的数据类型介绍，及值类型和引用类型的理解</h4><p>在 JS 中共有 <code>8</code>  种基础的数据类型，分别为： <code>Undefined</code> 、 <code>Null</code> 、 <code>Boolean</code> 、 <code>Number</code> 、 <code>String</code> 、 <code>Object</code> 、 <code>Symbol</code> 、 <code>BigInt</code> 。</p>\n<p>其中 <code>Symbol</code>  和 <code>BigInt</code>  是 ES6 新增的数据类型，可能会被单独问：</p>\n<ul>\n<li>Symbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。</li>\n<li>BigInt 可以表示任意大小的整数。</li>\n</ul>\n<p><strong>值类型的赋值变动过程如下：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">let a &#x3D; 100;\nlet b &#x3D; a;\na &#x3D; 200;\nconsole.log(b); &#x2F;&#x2F; 200\n复制代码</code></pre>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55df6cb63d3346be9ec1f572a1514853~tplv-k3u1fbpfcp-watermark.awebp\"> 值类型是直接存储在 ** 栈（stack）** 中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</p>\n<p><strong>引用类型的赋值变动过程如下：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">let a &#x3D; &#123; age: 20 &#125;;\nlet b &#x3D; a;\nb.age &#x3D; 30;\nconsole.log(a.age); &#x2F;&#x2F; 30\n复制代码</code></pre>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56c5c43d1c584ed4b8e4cce8855bab52~tplv-k3u1fbpfcp-watermark.awebp\"> 引用类型存储在 ** 堆（heap）** 中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；</p>\n<h4 id=\"1-2-数据类型的判断\"><a href=\"#1-2-数据类型的判断\" class=\"headerlink\" title=\"1.2 数据类型的判断\"></a>1.2 数据类型的判断</h4><ul>\n<li><strong>typeof</strong>：能判断所有<strong>值类型，函数</strong>。不可对 <strong>null、对象、数组</strong>进行精确判断，因为都返回 <code>object</code> 。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">console.log(typeof undefined); &#x2F;&#x2F; undefined\nconsole.log(typeof 2); &#x2F;&#x2F; number\nconsole.log(typeof true); &#x2F;&#x2F; boolean\nconsole.log(typeof &quot;str&quot;); &#x2F;&#x2F; string\nconsole.log(typeof Symbol(&quot;foo&quot;)); &#x2F;&#x2F; symbol\nconsole.log(typeof 2172141653n); &#x2F;&#x2F; bigint\nconsole.log(typeof function () &#123;&#125;); &#x2F;&#x2F; function\n&#x2F;&#x2F; 不能判别\nconsole.log(typeof []); &#x2F;&#x2F; object\nconsole.log(typeof &#123;&#125;); &#x2F;&#x2F; object\nconsole.log(typeof null); &#x2F;&#x2F; object\n复制代码</code></pre>\n\n<ul>\n<li><strong>instanceof</strong>：能判断<strong>对象</strong>类型，不能判断基本数据类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。比如考虑以下代码：</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class People &#123;&#125;\nclass Student extends People &#123;&#125;\n\nconst vortesnail &#x3D; new Student();\n\nconsole.log(vortesnail instanceof People); &#x2F;&#x2F; true\nconsole.log(vortesnail instanceof Student); &#x2F;&#x2F; true\n复制代码</code></pre>\n\n<p>其实现就是顺着<strong>原型链</strong>去找，如果能找到对应的 <code>Xxxxx.prototype</code>  即为 <code>true</code> 。比如这里的 <code>vortesnail</code>  作为实例，顺着原型链能找到 <code>Student.prototype</code>  及 <code>People.prototype</code> ，所以都为 <code>true</code> 。</p>\n<ul>\n<li>**Object.prototype.toString.call()**：所有原始数据类型都是能判断的，还有 <strong>Error 对象，Date 对象</strong>等。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Object.prototype.toString.call(2); &#x2F;&#x2F; &quot;[object Number]&quot;\nObject.prototype.toString.call(&quot;&quot;); &#x2F;&#x2F; &quot;[object String]&quot;\nObject.prototype.toString.call(true); &#x2F;&#x2F; &quot;[object Boolean]&quot;\nObject.prototype.toString.call(undefined); &#x2F;&#x2F; &quot;[object Undefined]&quot;\nObject.prototype.toString.call(null); &#x2F;&#x2F; &quot;[object Null]&quot;\nObject.prototype.toString.call(Math); &#x2F;&#x2F; &quot;[object Math]&quot;\nObject.prototype.toString.call(&#123;&#125;); &#x2F;&#x2F; &quot;[object Object]&quot;\nObject.prototype.toString.call([]); &#x2F;&#x2F; &quot;[object Array]&quot;\nObject.prototype.toString.call(function () &#123;&#125;); &#x2F;&#x2F; &quot;[object Function]&quot;\n复制代码</code></pre>\n\n<p>在面试中有一个经常被问的问题就是：如何判断变量是否为数组？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Array.isArray(arr); &#x2F;&#x2F; true\narr.__proto__ &#x3D;&#x3D;&#x3D; Array.prototype; &#x2F;&#x2F; true\narr instanceof Array; &#x2F;&#x2F; true\nObject.prototype.toString.call(arr); &#x2F;&#x2F; &quot;[object Array]&quot;\n复制代码</code></pre>\n\n<h4 id=\"1-3-手写深拷贝\"><a href=\"#1-3-手写深拷贝\" class=\"headerlink\" title=\"1.3 手写深拷贝\"></a>1.3 手写深拷贝</h4><p>这个题一定要会啊！笔者面试过程中疯狂被问到！</p>\n<p>文章推荐：<a href=\"https://juejin.cn/post/6844903929705136141\" title=\"https://juejin.cn/post/6844903929705136141\">如何写出一个惊艳面试官的深拷贝?</a></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * 深拷贝\n * @param &#123;Object&#125; obj 要拷贝的对象\n * @param &#123;Map&#125; map 用于存储循环引用对象的地址\n *&#x2F;\n\nfunction deepClone(obj &#x3D; &#123;&#125;, map &#x3D; new Map()) &#123;\n  if (typeof obj !&#x3D;&#x3D; &quot;object&quot;) &#123;\n    return obj;\n  &#125;\n  if (map.get(obj)) &#123;\n    return map.get(obj);\n  &#125;\n\n  let result &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; 初始化返回结果\n  if (\n    obj instanceof Array ||\n    &#x2F;&#x2F; 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此\n    Object.prototype.toString(obj) &#x3D;&#x3D;&#x3D; &quot;[object Array]&quot;\n  ) &#123;\n    result &#x3D; [];\n  &#125;\n  &#x2F;&#x2F; 防止循环引用\n  map.set(obj, result);\n  for (const key in obj) &#123;\n    &#x2F;&#x2F; 保证 key 不是原型属性\n    if (obj.hasOwnProperty(key)) &#123;\n      &#x2F;&#x2F; 递归调用\n      result[key] &#x3D; deepClone(obj[key], map);\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 返回结果\n  return result;\n&#125;\n复制代码</code></pre>\n\n<h4 id=\"1-4-根据-0-1-0-2-x3D-x3D-0-3，讲讲-IEEE-754-，如何让其相等？\"><a href=\"#1-4-根据-0-1-0-2-x3D-x3D-0-3，讲讲-IEEE-754-，如何让其相等？\" class=\"headerlink\" title=\"1.4 根据 0.1+0.2 ! &#x3D;&#x3D; 0.3，讲讲 IEEE 754 ，如何让其相等？\"></a>1.4 根据 0.1+0.2 ! &#x3D;&#x3D; 0.3，讲讲 IEEE 754 ，如何让其相等？</h4><p>建议先阅读这篇文章了解 IEEE 754 ：<a href=\"https://juejin.cn/post/6940405970954616839\" title=\"https://juejin.cn/post/6940405970954616839\">硬核基础二进制篇（一）0.1 + 0.2 !&#x3D; 0.3 和 IEEE-754 标准</a>。 再阅读这篇文章了解如何运算：<a href=\"https://juejin.cn/post/6844903680362151950\" title=\"https://juejin.cn/post/6844903680362151950\">0.1 + 0.2 不等于 0.3？为什么 JavaScript 有这种 “骚” 操作？</a>。 </p>\n<p>原因总结：</p>\n<ul>\n<li><code>进制转换</code> ：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环 ，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。</li>\n<li><code>对阶运算</code> ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（<code>0舍1入</code>），尾数位移时可能会发生数丢失的情况，影响精度。</li>\n</ul>\n<p>解决办法：</p>\n<ol>\n<li>转为整数（大数）运算。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function add(a, b) &#123;\n  const maxLen &#x3D; Math.max(\n    a.toString().split(&quot;.&quot;)[1].length,\n    b.toString().split(&quot;.&quot;)[1].length\n  );\n  const base &#x3D; 10 ** maxLen;\n  const bigA &#x3D; BigInt(base * a);\n  const bigB &#x3D; BigInt(base * b);\n  const bigRes &#x3D; (bigA + bigB) &#x2F; BigInt(base); &#x2F;&#x2F; 如果是 (1n + 2n) &#x2F; 10n 是等于 0n的。。。\n  return Number(bigRes);\n&#125;\n复制代码</code></pre>\n\n<p>这里代码是有问题的，因为最后计算 <code>bigRes</code> 的大数相除（即 <code>/</code>）是会把小数部分截掉的，所以我很疑惑为什么网络上很多文章都说可以通过<strong>先转为整数运算再除回去，为了防止转为的整数超出 js 表示范围，还可以运用到 ES6 新增的大数类型，我真的很疑惑，希望有好心人能解答下。</strong></p>\n<ol start=\"2\">\n<li>使用 <code>Number.EPSILON</code> 误差范围。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function isEqual(a, b) &#123;\n  return Math.abs(a - b) &lt; Number.EPSILON;\n&#125;\n\nconsole.log(isEqual(0.1 + 0.2, 0.3)); &#x2F;&#x2F; true\n复制代码</code></pre>\n\n<p><code>Number.EPSILON</code> 的实质是一个可以接受的最小误差范围，一般来说为 <code>Math.pow(2, -52)</code> 。 </p>\n<ol start=\"3\">\n<li>转成字符串，对字符串做加法运算。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 字符串数字相加\nvar addStrings &#x3D; function (num1, num2) &#123;\n  let i &#x3D; num1.length - 1;\n  let j &#x3D; num2.length - 1;\n  const res &#x3D; [];\n  let carry &#x3D; 0;\n  while (i &gt;&#x3D; 0 || j &gt;&#x3D; 0) &#123;\n    const n1 &#x3D; i &gt;&#x3D; 0 ? Number(num1[i]) : 0;\n    const n2 &#x3D; j &gt;&#x3D; 0 ? Number(num2[j]) : 0;\n    const sum &#x3D; n1 + n2 + carry;\n    res.unshift(sum % 10);\n    carry &#x3D; Math.floor(sum &#x2F; 10);\n    i--;\n    j--;\n  &#125;\n  if (carry) &#123;\n    res.unshift(carry);\n  &#125;\n  return res.join(&quot;&quot;);\n&#125;;\n\nfunction isEqual(a, b, sum) &#123;\n  const [intStr1, deciStr1] &#x3D; a.toString().split(&quot;.&quot;);\n  const [intStr2, deciStr2] &#x3D; b.toString().split(&quot;.&quot;);\n  const inteSum &#x3D; addStrings(intStr1, intStr2); &#x2F;&#x2F; 获取整数相加部分\n  const deciSum &#x3D; addStrings(deciStr1, deciStr2); &#x2F;&#x2F; 获取小数相加部分\n  return inteSum + &quot;.&quot; + deciSum &#x3D;&#x3D;&#x3D; String(sum);\n&#125;\n\nconsole.log(isEqual(0.1, 0.2, 0.3)); &#x2F;&#x2F; true\n复制代码</code></pre>\n\n<p>这是 leetcode 上一道原题：<a href=\"https://link.juejin.cn/?target=https://leetcode-cn.com/problems/add-strings/\" title=\"https://leetcode-cn.com/problems/add-strings/\">415. 字符串相加</a>。区别在于原题没有考虑小数，但是也是很简单的，我们分为两个部分计算就行。</p>\n<h3 id=\"2、-原型和原型链\"><a href=\"#2、-原型和原型链\" class=\"headerlink\" title=\"2、 原型和原型链\"></a>2、 原型和原型链</h3><p>可以说这部分每家面试官都会问了。。首先理解的话，其实一张图即可，一段代码即可。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function Foo() &#123;&#125;\n\nlet f1 &#x3D; new Foo();\nlet f2 &#x3D; new Foo();\n复制代码</code></pre>\n\n<p>千万别畏惧下面这张图，特别有用，一定要搞懂，熟到提笔就能默画出来。 <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a61ca07672a45d3aecf382100cc9719~tplv-k3u1fbpfcp-watermark.awebp\"></p>\n<p>总结：</p>\n<ul>\n<li>原型：每一个 JavaScript 对象（null 除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型 “继承” 属性，其实就是 <code>prototype</code> 对象。</li>\n<li>原型链：由相互关联的原型组成的<strong>链状结构</strong>就是原型链。</li>\n</ul>\n<p>先说出总结的话，再举例子说明如何顺着原型链找到某个属性。</p>\n<p>推荐的阅读：<a href=\"https://link.juejin.cn/?target=https://github.com/mqyqingfeng/blog/issues/2\" title=\"https://github.com/mqyqingfeng/blog/issues/2\">JavaScript 深入之从原型到原型链</a> 掌握基本概念，再阅读这篇文章<a href=\"https://juejin.cn/post/6844903989088092174\" title=\"https://juejin.cn/post/6844903989088092174\">轻松理解 JS 原型原型链</a>加深上图的印象。</p>\n<h3 id=\"3、-作用域与作用域链\"><a href=\"#3、-作用域与作用域链\" class=\"headerlink\" title=\"3、 作用域与作用域链\"></a>3、 作用域与作用域链</h3><ul>\n<li>作用域：规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。换句话说，作用域决定了代码区块中变量和其他资源的可见性。（全局作用域、函数作用域、块级作用域）</li>\n<li>作用域链：从当前作用域开始一层层往上找某个变量，如果找到全局作用域还没找到，就放弃寻找 。这种层级关系就是作用域链。（由多个执行上下文的<strong>变量对象</strong>构成的链表就叫做作用域链，学习下面的内容之后再考虑这句话）</li>\n</ul>\n<p><strong>需要注意的是，js 采用的是静态作用域，所以函数的作用域在函数定义时就确定了。</strong></p>\n<p>推荐阅读：先阅读 <a href=\"https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/3\" title=\"https://github.com/mqyqingfeng/Blog/issues/3\">JavaScript 深入之词法作用域和动态作用域</a>，再阅读<a href=\"https://juejin.cn/post/6844903797135769614\" title=\"https://juejin.cn/post/6844903797135769614\">深入理解 JavaScript 作用域和作用域链</a>。 </p>\n<h3 id=\"4、-执行上下文\"><a href=\"#4、-执行上下文\" class=\"headerlink\" title=\"4、 执行上下文\"></a>4、 执行上下文</h3><p>这部分一定要按顺序连续读这几篇文章，必须多读几遍：</p>\n<ul>\n<li><a href=\"https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/4\" title=\"https://github.com/mqyqingfeng/Blog/issues/4\">JavaScript 深入之执行上下文栈</a>；</li>\n<li><a href=\"https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/5\" title=\"https://github.com/mqyqingfeng/Blog/issues/5\">JavaScript 深入之变量对象</a>；</li>\n<li><a href=\"https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/6\" title=\"https://github.com/mqyqingfeng/Blog/issues/6\">JavaScript 深入之作用域链</a>；</li>\n<li><a href=\"https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/8\" title=\"https://github.com/mqyqingfeng/Blog/issues/8\">JavaScript 深入之执行上下文</a>。</li>\n</ul>\n<p>总结：当 JavaScript 代码执行一段可执行代码时，会创建对应的执行上下文。对于每个执行上下文，都有三个重要属性：</p>\n<ul>\n<li>变量对象（Variable object，VO）；</li>\n<li>作用域链（Scope chain）；</li>\n<li>this。（关于 this 指向问题，在上面推荐的深入系列也有讲从 ES 规范讲的，但是实在是难懂，对于应付面试来说以下这篇阮一峰的文章应该就可以了：<a href=\"https://link.juejin.cn/?target=https://www.ruanyifeng.com/blog/2018/06/javascript-this.html\" title=\"https://www.ruanyifeng.com/blog/2018/06/javascript-this.html\">JavaScript 的 this 原理</a>）</li>\n</ul>\n<h3 id=\"5、-闭包\"><a href=\"#5、-闭包\" class=\"headerlink\" title=\"5、 闭包\"></a>5、 闭包</h3><p>根据 MDN 中文的定义，闭包的定义如下：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。可以在一个内层函数中访问到其外层函数的作用域。</p></blockquote>\n<p>也可以这样说：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是<strong>函数参数</strong>也不是<strong>函数的局部变量</strong>的<strong>变量</strong>。 闭包 &#x3D; 函数 + 函数能够访问的自由变量。</p></blockquote>\n<p>在经过上一小节 “执行上下文” 的学习，再来阅读这篇文章：<a href=\"https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/9\" title=\"https://github.com/mqyqingfeng/Blog/issues/9\">JavaScript 深入之闭包</a>，你会对闭包的实质有一定的了解。在回答时，我们这样答：</p>\n<p>在某个内部函数的执行上下文创建时，会将父级函数的<strong>活动对象</strong>加到内部函数的 <code>[[scope]]</code> 中，形成作用域链，所以即使父级函数的执行上下文销毁（即执行上下文栈弹出父级函数的执行上下文），但是因为其<strong>活动对象</strong>还是实际存储在内存中可被内部函数访问到的，从而实现了闭包。</p>\n<p>闭包应用： 函数作为参数被传递：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function print(fn) &#123;\n  const a &#x3D; 200;\n  fn();\n&#125;\n\nconst a &#x3D; 100;\nfunction fn() &#123;\n  console.log(a);\n&#125;\n\nprint(fn); &#x2F;&#x2F; 100\n复制代码</code></pre>\n\n<p>函数作为返回值被返回：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function create() &#123;\n  const a &#x3D; 100;\n\n  return function () &#123;\n    console.log(a);\n  &#125;;\n&#125;\n\nconst fn &#x3D; create();\nconst a &#x3D; 200;\nfn(); &#x2F;&#x2F; 100\n复制代码</code></pre>\n\n<p><strong>闭包：自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在执行的地方。</strong> ****</p>\n<p>应用实例：比如缓存工具，隐藏数据，只提供 API 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function createCache() &#123;\n  const data &#x3D; &#123;&#125;; &#x2F;&#x2F; 闭包中被隐藏的数据，不被外界访问\n  return &#123;\n    set: function (key, val) &#123;\n      data[key] &#x3D; val;\n    &#125;,\n    get: function (key) &#123;\n      return data[key];\n    &#125;,\n  &#125;;\n&#125;\n\nconst c &#x3D; createCache();\nc.set(&quot;a&quot;, 100);\nconsole.log(c.get(&quot;a&quot;)); &#x2F;&#x2F; 100\n复制代码</code></pre>\n\n<h3 id=\"6、-call、apply、bind-实现\"><a href=\"#6、-call、apply、bind-实现\" class=\"headerlink\" title=\"6、 call、apply、bind 实现\"></a>6、 call、apply、bind 实现</h3><p>这部分实现还是要知道的，就算工作中不会自己手写，但是说不准面试官就是要问，知道点原理也好，可以扩宽我们写代码的思路。</p>\n<p><strong>call</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p></blockquote>\n<p>举个例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var obj &#x3D; &#123;\n  value: &quot;vortesnail&quot;,\n&#125;;\n\nfunction fn() &#123;\n  console.log(this.value);\n&#125;\n\nfn.call(obj); &#x2F;&#x2F; vortesnail\n复制代码</code></pre>\n\n<p>通过 <code>call</code> 方法我们做到了以下两点：</p>\n<ul>\n<li><code>call</code> 改变了 this 的指向，指向到 <code>obj</code> 。</li>\n<li><code>fn</code> 函数执行了。</li>\n</ul>\n<p>那么如果我们自己写 <code>call</code> 方法的话，可以怎么做呢？我们先考虑改造 <code>obj</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var obj &#x3D; &#123;\n  value: &quot;vortesnail&quot;,\n  fn: function () &#123;\n    console.log(this.value);\n  &#125;,\n&#125;;\n\nobj.fn(); &#x2F;&#x2F; vortesnail\n复制代码</code></pre>\n\n<p>这时候 this 就指向了 <code>obj</code> ，但是这样做我们手动给 <code>obj</code> 增加了一个 <code>fn</code> 属性，这显然是不行的，不用担心，我们执行完再使用对象属性的删除方法（delete）不就行了？</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">obj.fn &#x3D; fn;\nobj.fn();\ndelete obj.fn;\n复制代码</code></pre>\n\n<p>根据这个思路，我们就可以写出来了：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Function.prototype.myCall &#x3D; function (context) &#123;\n  &#x2F;&#x2F; 判断调用对象\n  if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;\n    throw new Error(&quot;Type error&quot;);\n  &#125;\n  &#x2F;&#x2F; 首先获取参数\n  let args &#x3D; [...arguments].slice(1);\n  let result &#x3D; null;\n  &#x2F;&#x2F; 判断 context 是否传入，如果没有传就设置为 window\n  context &#x3D; context || window;\n  &#x2F;&#x2F; 将被调用的方法设置为 context 的属性\n  &#x2F;&#x2F; this 即为我们要调用的方法\n  context.fn &#x3D; this;\n  &#x2F;&#x2F; 执行要被调用的方法\n  result &#x3D; context.fn(...args);\n  &#x2F;&#x2F; 删除手动增加的属性方法\n  delete context.fn;\n  &#x2F;&#x2F; 将执行结果返回\n  return result;\n&#125;;\n复制代码</code></pre>\n\n<p><strong>apply</strong></p>\n<p>我们会了 <code>call</code> 的实现之后，<code>apply</code> 就变得很简单了，他们没有任何区别，除了传参方式。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Function.prototype.myApply &#x3D; function (context) &#123;\n  if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;\n    throw new Error(&quot;Type error&quot;);\n  &#125;\n  let result &#x3D; null;\n  context &#x3D; context || window;\n  &#x2F;&#x2F; 与上面代码相比，我们使用 Symbol 来保证属性唯一\n  &#x2F;&#x2F; 也就是保证不会重写用户自己原来定义在 context 中的同名属性\n  const fnSymbol &#x3D; Symbol();\n  context[fnSymbol] &#x3D; this;\n  &#x2F;&#x2F; 执行要被调用的方法\n  if (arguments[1]) &#123;\n    result &#x3D; context[fnSymbol](...arguments[1]);\n  &#125; else &#123;\n    result &#x3D; context[fnSymbol]();\n  &#125;\n  delete context[fnSymbol];\n  return result;\n&#125;;\n复制代码</code></pre>\n\n<p><strong>bind</strong></p>\n<p><code>bind</code> 返回的是一个函数，这个地方可以详细阅读这篇文章，讲的非常清楚：<a href=\"https://link.juejin.cn/?target=https://github.com/sisterAn/JavaScript-Algorithms/issues/81\" title=\"https://github.com/sisterAn/JavaScript-Algorithms/issues/81\">解析 bind 原理，并手写 bind 实现</a>。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Function.prototype.myBind &#x3D; function (context) &#123;\n  &#x2F;&#x2F; 判断调用对象是否为函数\n  if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;\n    throw new Error(&quot;Type error&quot;);\n  &#125;\n  &#x2F;&#x2F; 获取参数\n  const args &#x3D; [...arguments].slice(1),\n  const fn &#x3D; this;\n  return function Fn() &#123;\n    return fn.apply(\n      this instanceof Fn ? this : context,\n      &#x2F;&#x2F; 当前的这个 arguments 是指 Fn 的参数\n      args.concat(...arguments)\n    );\n  &#125;;\n&#125;;\n复制代码</code></pre>\n\n<h3 id=\"7、-new-实现\"><a href=\"#7、-new-实现\" class=\"headerlink\" title=\"7、 new 实现\"></a>7、 new 实现</h3><ol>\n<li>首先创一个新的空对象。</li>\n<li>根据原型链，设置空对象的 <code>__proto__</code> 为构造函数的 <code>prototype</code> 。</li>\n<li>构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。</li>\n<li>判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象。</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function myNew(context) &#123;\n  const obj &#x3D; new Object();\n  obj.__proto__ &#x3D; context.prototype;\n  const res &#x3D; context.apply(obj, [...arguments].slice(1));\n  return typeof res &#x3D;&#x3D;&#x3D; &quot;object&quot; ? res : obj;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"8、-异步\"><a href=\"#8、-异步\" class=\"headerlink\" title=\"8、 异步\"></a>8、 异步</h3><p>这部分着重要理解 Promise、async awiat、event loop 等。</p>\n<h4 id=\"8-1-event-loop、宏任务和微任务\"><a href=\"#8-1-event-loop、宏任务和微任务\" class=\"headerlink\" title=\"8.1 event loop、宏任务和微任务\"></a>8.1 event loop、宏任务和微任务</h4><p>首先推荐一个可以在线看代码流程的网站：<a href=\"https://link.juejin.cn/?target=http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%253D\" title=\"http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\">loupe</a>。 然后看下这个视频学习下：<a href=\"https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1oV411k7XY/?spm_id_from=333.788.recommend_more_video.-1\" title=\"https://www.bilibili.com/video/BV1oV411k7XY/?spm_id_from=333.788.recommend_more_video.-1\">到底什么是 Event Loop 呢？</a></p>\n<p>简单的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">console.log(&quot;Hi&quot;);\n\nsetTimeout(function cb() &#123;\n  console.log(&quot;cb&quot;); &#x2F;&#x2F; cb 即 callback\n&#125;, 5000);\n\nconsole.log(&quot;Bye&quot;);\n复制代码</code></pre>\n\n<p>它的执行过程是这样的： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e15fc609aa84eac973c5b8ff163c11c~tplv-k3u1fbpfcp-watermark.awebp\"> Web APIs 会创建对应的线程，比如 <code>setTimeout</code> 会创建定时器线程，<code>ajax</code> 请求会创建 http 线程。。。这是由 js 的运行环境决定的，比如浏览器。</p>\n<p>看完上面的视频之后，至少大家画 Event Loop 的图讲解不是啥问题了，但是涉及到<strong>宏任务</strong>和<strong>微任务</strong>，我们还得拜读一下这篇文章：<a href=\"https://juejin.cn/post/6844903512845860872\" title=\"https://juejin.cn/post/6844903512845860872\">这一次，彻底弄懂 JavaScript 执行机制</a>。如果意犹未尽，不如再读下这篇非常详细带有大量动图的文章：<a href=\"https://juejin.cn/post/6969028296893792286#comment\" title=\"https://juejin.cn/post/6969028296893792286#comment\">做一些动图，学习一下 EventLoop</a>。想了解事件循环和页面渲染之间关系的又可以再阅读这篇文章：<a href=\"https://juejin.cn/post/6844904165462769678\" title=\"https://juejin.cn/post/6844904165462769678\">深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调（动图演示）</a>。</p>\n<p><strong>注意：1.Call Stack 调用栈空闲 -&gt; 2. 尝试 DOM 渲染 -&gt; 触发 Event loop</strong>。</p>\n<ul>\n<li>每次 Call Stack 清空（即每次轮询结束），即同步任务执行完。</li>\n<li>都是 DOM 重新渲染的机会，DOM 结构有改变则重新渲染。</li>\n<li>然后再去触发下一次 Event loop。</li>\n</ul>\n<p>宏任务：setTimeout，setInterval，Ajax，DOM 事件。 微任务：Promise async&#x2F;await。</p>\n<p>两者区别：</p>\n<ul>\n<li>宏任务：DOM 渲染后触发，如 <code>setTimeout</code> 、<code>setInterval</code> 、<code>DOM 事件</code> 、<code>script</code> 。</li>\n<li>微任务：DOM 渲染前触发，如 <code>Promise.then</code> 、<code>MutationObserver</code> 、Node 环境下的 <code>process.nextTick</code> 。</li>\n</ul>\n<p><strong>从 event loop 解释，为何微任务执行更早？</strong></p>\n<ul>\n<li>微任务是 ES6 语法规定的（被压入 micro task queue）。</li>\n<li>宏任务是由浏览器规定的（通过 Web APIs 压入 Callback queue）。</li>\n<li>宏任务执行时间一般比较长。</li>\n<li>每一次宏任务开始之前一定是伴随着一次 event loop 结束的，而微任务是在一次 event loop 结束前执行的。</li>\n</ul>\n<h4 id=\"8-2-Promise\"><a href=\"#8-2-Promise\" class=\"headerlink\" title=\"8.2 Promise\"></a>8.2 Promise</h4><p>关于这一块儿没什么好说的，最好是实现一遍 Promise A+ 规范，多少有点印象，当然面试官也不会叫你默写一个完整的出来，但是你起码要知道实现原理。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>关于 Promise 的所有使用方式，可参照这篇文章：<a href=\"https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/promise\" title=\"https://es6.ruanyifeng.com/#docs/promise\">ECMAScript 6 入门 - Promise 对象</a>。 手写 Promise 源码的解析文章，可阅读此篇文章：<a href=\"https://juejin.cn/post/6945319439772434469#heading-0\" title=\"https://juejin.cn/post/6945319439772434469#heading-0\">从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节</a>。 关于 Promise 的面试题，可参考这篇文章：<a href=\"https://juejin.cn/post/6844904077537574919\" title=\"https://juejin.cn/post/6844904077537574919\">要就来 45 道 Promise 面试题一次爽到底</a>。</p></blockquote>\n<p>实现一个 Promise.all：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Promise.all &#x3D; function (promises) &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 参数可以不是数组，但必须具有 Iterator 接口\n    if (typeof promises[Symbol.iterator] !&#x3D;&#x3D; &quot;function&quot;) &#123;\n      reject(&quot;Type error&quot;);\n    &#125;\n    if (promises.length &#x3D;&#x3D;&#x3D; 0) &#123;\n      resolve([]);\n    &#125; else &#123;\n      const res &#x3D; [];\n      let count &#x3D; 0;\n      const len &#x3D; promises.length;\n      for (let i &#x3D; 0; i &lt; len; i++) &#123;\n        &#x2F;&#x2F;考虑到 promises[i] 可能是 thenable 对象也可能是普通值\n        Promise.resolve(promises[i])\n          .then((data) &#x3D;&gt; &#123;\n            res[i] &#x3D; data;\n            if (++count &#x3D;&#x3D;&#x3D; len) &#123;\n              resolve(res);\n            &#125;\n          &#125;)\n          .catch((err) &#x3D;&gt; &#123;\n            reject(err);\n          &#125;);\n      &#125;\n    &#125;\n  &#125;);\n&#125;;\n复制代码</code></pre>\n\n<h4 id=\"8-3-async-x2F-await-和-Promise-的关系\"><a href=\"#8-3-async-x2F-await-和-Promise-的关系\" class=\"headerlink\" title=\"8.3 async&#x2F;await 和 Promise 的关系\"></a>8.3 async&#x2F;await 和 Promise 的关系</h4><ul>\n<li>async&#x2F;await 是消灭异步回调的终极武器。</li>\n<li>但和 Promise 并不互斥，反而，两者相辅相成。</li>\n<li>执行 async 函数，返回的一定是 Promise 对象。</li>\n<li>await 相当于 Promise 的 then。</li>\n<li>tru…catch 可捕获异常，代替了 Promise 的 catch。</li>\n</ul>\n<h3 id=\"9、-浏览器的垃圾回收机制\"><a href=\"#9、-浏览器的垃圾回收机制\" class=\"headerlink\" title=\"9、 浏览器的垃圾回收机制\"></a>9、 浏览器的垃圾回收机制</h3><p>这里看这篇文章即可：<a href=\"https://juejin.cn/post/6981588276356317214\" title=\"https://juejin.cn/post/6981588276356317214\">「硬核 JS」你真的了解垃圾回收机制吗</a>。</p>\n<p>总结一下：</p>\n<p>有两种垃圾回收策略：</p>\n<ul>\n<li><strong>标记清除</strong>：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。</li>\n<li><strong>引用计数</strong>：它把<strong>对象是否不再需要</strong>简化定义为<strong>对象有没有其他对象引用到它</strong>。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。</li>\n</ul>\n<p>标记清除的缺点：</p>\n<ul>\n<li><strong>内存碎片化</strong>，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。</li>\n<li><strong>分配速度慢</strong>，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。</li>\n</ul>\n<p>解决以上的缺点可以使用 ** 标记整理（Mark-Compact）算法 **，标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图） <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb543f2fdc634e29add495b8f2ff048f~tplv-k3u1fbpfcp-watermark.awebp\"></p>\n<p>引用计数的缺点：</p>\n<ul>\n<li>需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。</li>\n<li>解决不了循环引用导致的无法回收问题。</li>\n</ul>\n<p>V8 的垃圾回收机制也是基于标记清除算法，不过对其做了一些优化。</p>\n<ul>\n<li>针对新生区采用并行回收。</li>\n<li>针对老生区采用增量标记与惰性回收。</li>\n</ul>\n<h3 id=\"10、-实现一个-EventMitter-类\"><a href=\"#10、-实现一个-EventMitter-类\" class=\"headerlink\" title=\"10、 实现一个 EventMitter 类\"></a>10、 实现一个 EventMitter 类</h3><p>EventMitter 就是发布订阅模式的典型应用：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">export class EventEmitter &#123;\n  private _events: Record&lt;string, Array&lt;Function&gt;&gt;;\n\n  constructor() &#123;\n    this._events &#x3D; Object.create(null);\n  &#125;\n\n  emit(evt: string, ...args: any[]) &#123;\n    if (!this._events[evt]) return false;\n\n    const fns &#x3D; [...this._events[evt]];\n    fns.forEach((fn) &#x3D;&gt; &#123;\n      fn.apply(this, args);\n    &#125;);\n\n    return true;\n  &#125;\n\n  on(evt: string, fn: Function) &#123;\n    if (typeof fn !&#x3D;&#x3D; &quot;function&quot;) &#123;\n      throw new TypeError(&quot;The evet-triggered callback must be a function&quot;);\n    &#125;\n    if (!this._events[evt]) &#123;\n      this._events[evt] &#x3D; [fn];\n    &#125; else &#123;\n      this._events[evt].push(fn);\n    &#125;\n  &#125;\n\n  once(evt: string, fn: Function) &#123;\n    const execFn &#x3D; () &#x3D;&gt; &#123;\n      fn.apply(this);\n      this.off(evt, execFn);\n    &#125;;\n    this.on(evt, execFn);\n  &#125;\n\n  off(evt: string, fn?: Function) &#123;\n    if (!this._events[evt]) return;\n    if (!fn) &#123;\n      this._events[evt] &amp;&amp; (this._events[evt].length &#x3D; 0);\n    &#125;\n\n    let cb;\n    const cbLen &#x3D; this._events[evt].length;\n    for (let i &#x3D; 0; i &lt; cbLen; i++) &#123;\n      cb &#x3D; this._events[evt][i];\n      if (cb &#x3D;&#x3D;&#x3D; fn) &#123;\n        this._events[evt].splice(i, 1);\n        break;\n      &#125;\n    &#125;\n  &#125;\n\n  removeAllListeners(evt?: string) &#123;\n    if (evt) &#123;\n      this._events[evt] &amp;&amp; (this._events[evt].length &#x3D; 0);\n    &#125; else &#123;\n      this._events &#x3D; Object.create(null);\n    &#125;\n  &#125;\n&#125;\n复制代码</code></pre>\n\n<h2 id=\"四、web-存储\"><a href=\"#四、web-存储\" class=\"headerlink\" title=\"四、web 存储\"></a>四、web 存储</h2><p>要掌握 cookie，localStorage 和 sessionStorage。</p>\n<h3 id=\"1、cookie\"><a href=\"#1、cookie\" class=\"headerlink\" title=\"1、cookie\"></a>1、cookie</h3><ul>\n<li>本身用于浏览器和 server 通讯。</li>\n<li>被 “借用” 到本地存储来的。</li>\n<li>可用 document.cookie &#x3D; ‘…’ 来修改。</li>\n</ul>\n<p>其缺点：</p>\n<ul>\n<li>存储大小限制为 4KB。</li>\n<li>http 请求时需要发送到服务端，增加请求数量。</li>\n<li>只能用 document.cookie &#x3D; ‘…’ 来修改，太过简陋。</li>\n</ul>\n<h3 id=\"2、localStorage-和-sessionStorage\"><a href=\"#2、localStorage-和-sessionStorage\" class=\"headerlink\" title=\"2、localStorage 和 sessionStorage\"></a>2、localStorage 和 sessionStorage</h3><ul>\n<li>HTML5 专门为存储来设计的，最大可存 5M。</li>\n<li>API 简单易用， setItem getItem。</li>\n<li>不会随着 http 请求被发送到服务端。</li>\n</ul>\n<p>它们的区别：</p>\n<ul>\n<li>localStorage 数据会永久存储，除非代码删除或手动删除。</li>\n<li>sessionStorage 数据只存在于当前会话，浏览器关闭则清空。</li>\n<li>一般用 localStorage 会多一些。</li>\n</ul>\n<h2 id=\"五、Http\"><a href=\"#五、Http\" class=\"headerlink\" title=\"五、Http\"></a>五、Http</h2><p>前端工程师做出网页，需要通过网络请求向后端获取数据，因此 http 协议是前端面试的必考内容。</p>\n<h3 id=\"1、http-状态码\"><a href=\"#1、http-状态码\" class=\"headerlink\" title=\"1、http 状态码\"></a>1、http 状态码</h3><h4 id=\"1-1-状态码分类\"><a href=\"#1-1-状态码分类\" class=\"headerlink\" title=\"1.1 状态码分类\"></a>1.1 状态码分类</h4><ul>\n<li>1xx - 服务器收到请求。</li>\n<li>2xx - 请求成功，如 200。</li>\n<li>3xx - 重定向，如 302。</li>\n<li>4xx - 客户端错误，如 404。</li>\n<li>5xx - 服务端错误，如 500。</li>\n</ul>\n<h4 id=\"1-2-常见状态码\"><a href=\"#1-2-常见状态码\" class=\"headerlink\" title=\"1.2 常见状态码\"></a>1.2 常见状态码</h4><ul>\n<li>200 - 成功。</li>\n<li>301 - 永久重定向（配合 location，浏览器自动处理）。</li>\n<li>302 - 临时重定向（配合 location，浏览器自动处理）。</li>\n<li>304 - 资源未被修改。</li>\n<li>403 - 没权限。</li>\n<li>404 - 资源未找到。</li>\n<li>500 - 服务器错误。</li>\n<li>504 - 网关超时。</li>\n</ul>\n<h4 id=\"1-3-关于协议和规范\"><a href=\"#1-3-关于协议和规范\" class=\"headerlink\" title=\"1.3 关于协议和规范\"></a>1.3 关于协议和规范</h4><ul>\n<li>状态码都是约定出来的。</li>\n<li>要求大家都跟着执行。</li>\n<li>不要违反规范，例如 IE 浏览器。</li>\n</ul>\n<h3 id=\"2、http-缓存\"><a href=\"#2、http-缓存\" class=\"headerlink\" title=\"2、http 缓存\"></a>2、http 缓存</h3><ul>\n<li>关于缓存的介绍。</li>\n<li>http 缓存策略（强制缓存 + 协商缓存）。</li>\n<li>刷新操作方式，对缓存的影响。</li>\n</ul>\n<h4 id=\"4-1-关于缓存\"><a href=\"#4-1-关于缓存\" class=\"headerlink\" title=\"4.1 关于缓存\"></a>4.1 关于缓存</h4><p>什么是缓存？ 把一些不需要重新获取的内容再重新获取一次</p>\n<p>为什么需要缓存？ 网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。</p>\n<p>哪些资源可以被缓存？ 静态资源，比如 js css img。</p>\n<h4 id=\"4-2-强制缓存\"><a href=\"#4-2-强制缓存\" class=\"headerlink\" title=\"4.2 强制缓存\"></a>4.2 强制缓存</h4><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ff1ec224244427ba9f15abecbd668fe~tplv-k3u1fbpfcp-watermark.awebp\"></p>\n<p>Cache-Control：</p>\n<ul>\n<li>在 Response Headers 中。</li>\n<li>控制强制缓存的逻辑。</li>\n<li>例如 Cache-Control: max-age&#x3D;3153600（单位是秒）</li>\n</ul>\n<p>Cache-Control 有哪些值：</p>\n<ul>\n<li>max-age：缓存最大过期时间。</li>\n<li>no-cache：可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。</li>\n<li>no-store：永远都不要在客户端存储资源，永远都去原始服务器去获取资源。</li>\n</ul>\n<h4 id=\"4-3-协商缓存（对比缓存）\"><a href=\"#4-3-协商缓存（对比缓存）\" class=\"headerlink\" title=\"4.3 协商缓存（对比缓存）\"></a>4.3 协商缓存（对比缓存）</h4><ul>\n<li>服务端缓存策略。</li>\n<li>服务端判断客户端资源，是否和服务端资源一样。</li>\n<li>一致则返回 304，否则返回 200 和最新的资源。</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56e265f46c80430fbf4673878a27bfc9~tplv-k3u1fbpfcp-watermark.awebp\"> 资源标识：</p>\n<ul>\n<li>在 Response Headers 中，有两种。</li>\n<li>Last-Modified：资源的最后修改时间。</li>\n<li>Etag：资源的唯一标识（一个字符串，类似于人类的指纹）。</li>\n</ul>\n<p><strong>Last-Modified：</strong> <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c4f44afeb73464295e9878d2c47b024~tplv-k3u1fbpfcp-watermark.awebp\"> 服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304 ，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。</p>\n<p><strong>Etag：</strong> <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e35285a8d23a4a4380676aeb681e815d~tplv-k3u1fbpfcp-watermark.awebp\"> 其实 Etag 和 Last-Modified 一样的，只不过 Etag 是服务端对资源按照一定方式（比如 contenthash）计算出来的唯一标识，就像人类指纹一样，传给客户端之后，客户端再传过来时候，服务端会将其与现在的资源计算出来的唯一标识做比较，一致则返回 304，不一致就返回 200 和新的资源及新的 Etag。</p>\n<p><strong>两者比较：</strong></p>\n<ul>\n<li>优先使用 Etag。</li>\n<li>Last-Modified 只能精确到秒级。</li>\n<li>如果资源被重复生成，而内容不变，则 Etag 更精确。</li>\n</ul>\n<h4 id=\"4-4-综述\"><a href=\"#4-4-综述\" class=\"headerlink\" title=\"4.4 综述\"></a>4.4 综述</h4><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b74c746d1459403382fd0bbc1d96aeca~tplv-k3u1fbpfcp-watermark.awebp\"></p>\n<h4 id=\"4-4-三种刷新操作对-http-缓存的影响\"><a href=\"#4-4-三种刷新操作对-http-缓存的影响\" class=\"headerlink\" title=\"4.4 三种刷新操作对 http 缓存的影响\"></a>4.4 三种刷新操作对 http 缓存的影响</h4><ul>\n<li>正常操作：地址栏输入 url，跳转链接，前进后退等。</li>\n<li>手动刷新：f5，点击刷新按钮，右键菜单刷新。</li>\n<li>强制刷新：ctrl + f5，shift+command+r。</li>\n</ul>\n<p><strong>正常操作：强制缓存有效，协商缓存有效。</strong> <strong>手动刷新：强制缓存失效，协商缓存有效。</strong> <strong>强制刷新：强制缓存失效，协商缓存失效。</strong> ****</p>\n<h3 id=\"3-面试\"><a href=\"#3-面试\" class=\"headerlink\" title=\"3. 面试\"></a>3. 面试</h3><p><strong>对于更多面试中可能出现的问题，我还是建议精读这篇三元的文章：</strong><a href=\"https://juejin.cn/post/6844904100035821575\" title=\"https://juejin.cn/post/6844904100035821575\">HTTP 灵魂之问，巩固你的 HTTP 知识体系</a>。</p>\n<p>比如会被经常问到的： GET 和 POST 的区别。</p>\n<ul>\n<li>从<strong>缓存</strong>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li>\n<li>从<strong>编码</strong>的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li>\n<li>从<strong>参数</strong>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li>\n<li>从<strong>幂等性</strong>的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)</li>\n<li>从 <strong>TCP</strong> 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)</li>\n</ul>\n<p>HTTP&#x2F;2 有哪些改进？（很大可能问原理）</p>\n<ul>\n<li>头部压缩。</li>\n<li>多路复用。</li>\n<li>服务器推送。</li>\n</ul>\n<p>关于 HTTPS 的一些原理，可以阅读这篇文章：<a href=\"https://juejin.cn/post/6844904038509576199\" title=\"https://juejin.cn/post/6844904038509576199\">这一次，彻底理解 https 原理</a>。接着你可以观看这个视频进行更进一步的学习：<a href=\"https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1XL411b7KZ?p=1\" title=\"https://www.bilibili.com/video/BV1XL411b7KZ?p=1\">HTTPS 底层原理，面试官直接下跪，唱征服！</a></p>\n<p>关于<strong>跨域</strong>问题，大部分文章都是理论性比较强，还不如读这篇文章，<a href=\"https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/149734572?from_voters_page=true\" title=\"https://zhuanlan.zhihu.com/p/149734572?from_voters_page=true\">聊聊跨域的原理与解决方法</a>，讲的非常清晰，我个人觉得对付面试就是先知道使用流程，把这个流程能自己说出来，然后再讲下原理即可。</p>\n<h2 id=\"六、React\"><a href=\"#六、React\" class=\"headerlink\" title=\"六、React\"></a>六、React</h2><h3 id=\"1、-React-事件机制，React-16-和-React-17-事件机制的不同\"><a href=\"#1、-React-事件机制，React-16-和-React-17-事件机制的不同\" class=\"headerlink\" title=\"1、 React 事件机制，React 16 和 React 17 事件机制的不同\"></a>1、 React 事件机制，React 16 和 React 17 事件机制的不同</h3><p>阅读这篇文章即可：<a href=\"https://juejin.cn/post/6955636911214067720\" title=\"https://juejin.cn/post/6955636911214067720\">一文吃透 react 事件系统原理</a>。</p>\n<p>为什么要自定义事件机制？</p>\n<ul>\n<li>抹平浏览器差异，实现更好的跨平台。</li>\n<li>避免垃圾回收，React 引入事件池，在事件池中获取或释放事件对象，避免频繁地去创建和销毁。</li>\n<li>方便事件统一管理和事务机制。</li>\n</ul>\n<h3 id=\"2、class-component\"><a href=\"#2、class-component\" class=\"headerlink\" title=\"2、class component\"></a>2、class component</h3><p>不排除现在还会有面试官问关于 class component 的问题。</p>\n<h4 id=\"2-1-生命周期\"><a href=\"#2-1-生命周期\" class=\"headerlink\" title=\"2.1 生命周期\"></a>2.1 生命周期</h4><ul>\n<li>初始化阶段。</li>\n</ul>\n<p>发生在 <code>constructor</code> 中的内容，在 <code>constructor</code> 中进行 <code>state</code> 、<code>props</code> 的初始化，在这个阶段修改 <code>state</code>，不会执行更新阶段的生命周期，可以直接对 <code>state</code> 赋值。</p>\n<ul>\n<li>挂载阶段。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1. componentWillMount\n   发生在 render 函数之前，还没有挂载 Dom\n2. render\n3. componentDidMount\n   发生在 render 函数之后，已经挂载 Dom\n复制代码</code></pre>\n\n<ul>\n<li>更新阶段。</li>\n</ul>\n<p>更新阶段分为由 <code>state</code> 更新引起和 <code>props</code> 更新引起。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">props 更新时：\n1. componentWillReceiveProps(nextProps,nextState)\n   这个生命周期主要为我们提供对 props 发生改变的监听，如果你需要在 props 发生改变后，相应改变组件的一些 state。在这个方法中改变 state 不会二次渲染，而是直接合并 state。\n2. shouldComponentUpdate(nextProps,nextState)\n   这个生命周期需要返回一个 Boolean 类型的值，判断是否需要更新渲染组件，优化 react 应用的主要手段之一，当返回 false 就不会再向下执行生命周期了，在这个阶段不可以 setState()，会导致循环调用。\n3. componentWillUpdate(nextProps,nextState)\n   这个生命周期主要是给我们一个时机能够处理一些在 Dom 发生更新之前的事情，如获得 Dom 更新前某些元素的坐标、大小等，在这个阶段不可以 setState()，会导致循环调用。\n    **一直到这里 this.props 和 this.state 都还未发生更新**\n4. render\n5. componentDidUpdate(prevProps, prevState)\n   在此时已经完成渲染，Dom 已经发生变化，state 已经发生更新，prevProps、prevState 均为上一个状态的值。\n\nstate 更新时（具体同上）\n1. shouldComponentUpdate\n2. componentWillUpdate\n3. render\n4. componentDidUpdate\n复制代码</code></pre>\n\n<ul>\n<li>卸载阶段。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1. componentWillUnmount\n   在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount  中创建的订阅等。componentWillUnmount 中不应调用 setState，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。\n\n复制代码</code></pre>\n\n<p>在 React 16 中官方已经建议删除以下三个方法，非要使用必须加前缀：<code>UNSAVE_</code> 。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">componentWillMount;\ncomponentWillReceiveProps;\ncomponentWillUpdate;\n复制代码</code></pre>\n\n<p>取代这两三个生命周期的以下两个新的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1. static getDerivedStateFromProps(nextProps,nextState)\n   在组件实例化、接收到新的 props 、组件状态更新时会被调用\n2. getSnapshotBeforeUpdate（prevProps,prevState）\n   在这个阶段我们可以拿到上一个状态 Dom 元素的坐标、大小的等相关信息。用于替代旧的生命周期中的 componentWillUpdate。\n   该函数的返回值将会作为 componentDidUpdate 的第三个参数出现。\n复制代码</code></pre>\n\n<p>需要注意的是，一般都会问为什么要废弃三个生命周期，原因是什么。</p>\n<h4 id=\"2-2-setState-同步还是异步\"><a href=\"#2-2-setState-同步还是异步\" class=\"headerlink\" title=\"2.2 setState 同步还是异步\"></a>2.2 setState 同步还是异步</h4><p><code>setState</code> 本身代码的执行肯定是同步的，这里的异步是指是多个 state 会合成到一起进行批量更新。 同步还是异步取决于它被调用的环境。</p>\n<ul>\n<li>如果 <code>setState</code> 在 React 能够控制的范围被调用，它就是<strong>异步</strong>的。比如<strong>合成事件处理函数</strong>，<strong>生命周期函数</strong>， 此时会进行批量更新，也就是将状态合并后再进行 DOM 更新。</li>\n<li>如果 <code>setState</code> 在原生 JavaScript 控制的范围被调用，它就是<strong>同步</strong>的。比如原生事件处理函数，定时器回调函数，Ajax 回调函数中，此时 <code>setState</code> 被调用后会立即更新 DOM 。</li>\n</ul>\n<h3 id=\"3、对函数式编程的理解\"><a href=\"#3、对函数式编程的理解\" class=\"headerlink\" title=\"3、对函数式编程的理解\"></a>3、对函数式编程的理解</h3><p>这篇文章写的真的太好了，一定要读：<a href=\"https://juejin.cn/post/6844903936378273799\" title=\"https://juejin.cn/post/6844903936378273799\">简明 JavaScript 函数式编程——入门篇</a>。</p>\n<p>总结一下： 函数式编程有两个核心概念。</p>\n<ul>\n<li><strong>数据不可变（无副作用）：</strong> 它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。</li>\n<li><strong>无状态：</strong> 主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。</li>\n</ul>\n<p>纯函数带来的意义。</p>\n<ul>\n<li><strong>便于测试和优化</strong>：这个意义在实际项目开发中意义非常大，由于纯函数对于相同的输入永远会返回相同的结果，因此我们可以轻松断言函数的执行结果，同时也可以保证函数的优化不会影响其他代码的执行。</li>\n<li><strong>可缓存性</strong>：因为相同的输入总是可以返回相同的输出，因此，我们可以提前缓存函数的执行结果。</li>\n<li><strong>更少的 Bug</strong>：使用纯函数意味着你的函数中<strong>不存在指向不明的 this，不存在对全局变量的引用，不存在对参数的修改</strong>，这些共享状态往往是绝大多数 bug 的源头。</li>\n</ul>\n<h3 id=\"4、react-hooks\"><a href=\"#4、react-hooks\" class=\"headerlink\" title=\"4、react hooks\"></a>4、react hooks</h3><p>现在应该大多数面试官会问 hooks 相关的啦。这里我强烈推荐三篇文章，即使没看过源码，也能比较好地理解一些原理：<br><a href=\"https://juejin.cn/post/6844904127110053895\" title=\"https://juejin.cn/post/6844904127110053895\">用动画和实战打开 React Hooks（一）：useState 和 useEffect</a><br><a href=\"https://juejin.cn/post/6844904132164190221\" title=\"https://juejin.cn/post/6844904132164190221\">用动画和实战打开 React Hooks（二）：自定义 Hook 和 useCallback</a><br><a href=\"https://juejin.cn/post/6844904149746728973\" title=\"https://juejin.cn/post/6844904149746728973\">用动画和实战打开 React Hooks（三）：useReducer 和 useContext</a></p>\n<h4 id=\"4-1-为什么不能在条件语句中写-hook\"><a href=\"#4-1-为什么不能在条件语句中写-hook\" class=\"headerlink\" title=\"4.1 为什么不能在条件语句中写 hook\"></a>4.1 为什么不能在条件语句中写 hook</h4><p>推荐这篇文章：<a href=\"https://juejin.cn/post/6939766434159394830\" title=\"https://juejin.cn/post/6939766434159394830\">我打破了 React Hook 必须按顺序、不能在条件语句中调用的枷锁</a>。</p>\n<p>hook 在每次渲染时的查找是根据一个 “全局” 的下标对链表进行查找的，如果放在条件语句中使用，有一定几率会造成拿到的状态出现错乱。</p>\n<h4 id=\"4-2-HOC-和-hook-的区别\"><a href=\"#4-2-HOC-和-hook-的区别\" class=\"headerlink\" title=\"4.2 HOC 和 hook 的区别\"></a>4.2 HOC 和 hook 的区别</h4><p>hoc 能复用<strong>逻辑和视图</strong>，hook 只能复用<strong>逻辑</strong>。</p>\n<h4 id=\"4-3-useEffect-和-useLayoutEffect-区别\"><a href=\"#4-3-useEffect-和-useLayoutEffect-区别\" class=\"headerlink\" title=\"4.3 useEffect 和 useLayoutEffect 区别\"></a>4.3 useEffect 和 useLayoutEffect 区别</h4><p>对于 React 的函数组件来说，其更新过程大致分为以下步骤：</p>\n<ol>\n<li>因为某个事件 <code>state</code> 发生变化。</li>\n<li>React 内部更新 <code>state</code> 变量。</li>\n<li>React 处理更新组件中 return 出来的 DOM 节点（进行一系列 dom diff 、调度等流程）。</li>\n<li>将更新过后的 DOM 数据绘制到浏览器中。</li>\n<li>用户看到新的页面。</li>\n</ol>\n<p><code>useEffect</code> 在第 4 步之后执行，且是异步的，保证了不会阻塞浏览器进程。 <code>useLayoutEffect</code> 在第 3 步至第 4 步之间执行，且是同步代码，所以会阻塞后面代码的执行。</p>\n<h4 id=\"4-4-useEffect-依赖为空数组与-componentDidMount-区别\"><a href=\"#4-4-useEffect-依赖为空数组与-componentDidMount-区别\" class=\"headerlink\" title=\"4.4 useEffect 依赖为空数组与 componentDidMount 区别\"></a>4.4 useEffect 依赖为空数组与 componentDidMount 区别</h4><p>在 <code>render</code> 执行之后，<code>componentDidMount</code> 会执行，如果在这个生命周期中再一次 <code>setState</code> ，会导致再次 <code>render</code> ，返回了新的值，浏览器只会渲染第二次 <code>render</code> 返回的值，这样可以避免闪屏。</p>\n<p>但是 <code>useEffect</code> 是在真实的 DOM 渲染之后才会去执行，这会造成两次 <code>render</code> ，有可能会闪屏。</p>\n<p>实际上 <code>useLayoutEffect</code> 会更接近 <code>componentDidMount</code> 的表现，它们都同步执行且会阻碍真实的 DOM 渲染的。</p>\n<h4 id=\"4-5-React-memo-和-React-useMemo-的区别\"><a href=\"#4-5-React-memo-和-React-useMemo-的区别\" class=\"headerlink\" title=\"4.5 React.memo() 和 React.useMemo() 的区别\"></a>4.5 React.memo() 和 React.useMemo() 的区别</h4><ul>\n<li><code>memo</code> 是一个高阶组件，默认情况下会对 <code>props</code> 进行浅比较，如果相等不会重新渲染。多数情况下我们比较的都是引用类型，浅比较就会失效，所以我们可以传入第二个参数手动控制。</li>\n<li><code>useMemo</code> 返回的是一个缓存值，只有依赖发生变化时才会去重新执行作为第一个参数的函数，需要记住的是，<code>useMemo</code> 是在 <code>render</code> 阶段执行的，所以不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴。</li>\n</ul>\n<h4 id=\"4-6-React-useCallback-和-React-useMemo-的区别\"><a href=\"#4-6-React-useCallback-和-React-useMemo-的区别\" class=\"headerlink\" title=\"4.6 React.useCallback() 和 React.useMemo() 的区别\"></a>4.6 React.useCallback() 和 React.useMemo() 的区别</h4><ul>\n<li><code>useCallback</code> 可缓存函数，其实就是避免每次重新渲染后都去重新执行一个新的函数。</li>\n<li><code>useMemo</code> 可缓存值。</li>\n</ul>\n<p>有很多时候，我们在 <code>useEffect</code> 中使用某个定义的外部函数，是要添加到 <code>deps</code> 数组中的，如果不用 <code>useCallback</code> 缓存，这个函数在每次重新渲染时都是一个完全新的函数，也就是引用地址发生了变化，这就会导致 <code>useEffect</code> 总会无意义的执行。</p>\n<h4 id=\"4-7-React-forwardRef-是什么及其作用\"><a href=\"#4-7-React-forwardRef-是什么及其作用\" class=\"headerlink\" title=\"4.7 React.forwardRef 是什么及其作用\"></a>4.7 React.forwardRef 是什么及其作用</h4><p>这里还是阅读官方文档来的清晰：<a href=\"https://link.juejin.cn/?target=https://zh-hans.reactjs.org/docs/react-api.html%23reactforwardref\" title=\"https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref\">React.forwardRef</a>。 一般在父组件要拿到子组件的某个实际的 DOM 元素时会用到。</p>\n<h3 id=\"6、react-hooks-与-class-组件对比\"><a href=\"#6、react-hooks-与-class-组件对比\" class=\"headerlink\" title=\"6、react hooks 与 class 组件对比\"></a>6、react hooks 与 class 组件对比</h3><p><a href=\"https://juejin.cn/post/6844904179136200712\" title=\"https://juejin.cn/post/6844904179136200712\">react hooks 与 class 组件对比</a> <a href=\"https://link.juejin.cn/?target=https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/\" title=\"https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/\">函数式组件与类组件有何不同</a></p>\n<h3 id=\"7、介绍-React-dom-diff-算法\"><a href=\"#7、介绍-React-dom-diff-算法\" class=\"headerlink\" title=\"7、介绍 React dom diff 算法\"></a>7、介绍 React dom diff 算法</h3><p><a href=\"https://juejin.cn/post/6844903806132568072\" title=\"https://juejin.cn/post/6844903806132568072\">让虚拟 DOM 和 DOM-diff 不再成为你的绊脚石</a>。</p>\n<h3 id=\"8、对-React-Fiber-的理解\"><a href=\"#8、对-React-Fiber-的理解\" class=\"headerlink\" title=\"8、对 React Fiber 的理解\"></a>8、对 React Fiber 的理解</h3><p>关于这块儿我觉得可以好好阅读下这篇无敌的博客了：<a href=\"https://link.juejin.cn/?target=https://pomb.us/build-your-own-react/\" title=\"https://pomb.us/build-your-own-react/\">Build your own React</a>。 它可以教你一步步实现一个简单的基于 React Fiber 的 React，可以学到很多 React 的设计思想，毕竟为了面试我们可能大多数人是没有时间或能力去阅读源码的了。</p>\n<p>然后我们再阅读下其它作者对于 React Fiber 的理解，再转化为我们自己的思考总结，以下是推荐文章： <a href=\"https://juejin.cn/post/6844903975112671239\" title=\"https://juejin.cn/post/6844903975112671239\">这可能是最通俗的 React Fiber(时间分片) 打开方式</a></p>\n<h3 id=\"9、React-性能优化手段\"><a href=\"#9、React-性能优化手段\" class=\"headerlink\" title=\"9、React 性能优化手段\"></a>9、React 性能优化手段</h3><p>推荐文章：<a href=\"https://juejin.cn/post/6844903924302888973\" title=\"https://juejin.cn/post/6844903924302888973\">React 性能优化的 8 种方式了解一下？</a></p>\n<ul>\n<li>使用 <code>React.memo</code> 来缓存组件。</li>\n<li>使用 <code>React.useMemo</code> 缓存大量的计算。</li>\n<li>避免使用匿名函数。</li>\n<li>利用 <code>React.lazy</code> 和 <code>React.Suspense</code> 延迟加载不是立即需要的组件。</li>\n<li>尽量使用 CSS 而不是强制加载和卸载组件。</li>\n<li>使用 <code>React.Fragment</code> 避免添加额外的 DOM。</li>\n</ul>\n<h3 id=\"10、React-Redux\"><a href=\"#10、React-Redux\" class=\"headerlink\" title=\"10、React Redux\"></a>10、React Redux</h3><p><a href=\"https://juejin.cn/post/6844904021187117069\" title=\"https://juejin.cn/post/6844904021187117069\">Redux 包教包会（一）：介绍 Redux 三大核心概念</a></p>\n<h2 id=\"七、webpack\"><a href=\"#七、webpack\" class=\"headerlink\" title=\"七、webpack\"></a>七、webpack</h2><p>原理初探：<a href=\"https://juejin.cn/post/6943468761575849992\" title=\"https://juejin.cn/post/6943468761575849992\">当面试官问 Webpack 的时候他想知道什么</a><br>简易实现：<a href=\"https://link.juejin.cn/?target=https://github.com/Cosen95/blog/issues/48\" title=\"https://github.com/Cosen95/blog/issues/48\">面试官：webpack 原理都不会</a>，<a href=\"https://link.juejin.cn/?target=https://segmentfault.com/a/1190000039231950\" title=\"https://segmentfault.com/a/1190000039231950\">手写一个 webpack，看看 AST 怎么用</a><br>加料：<a href=\"https://juejin.cn/post/6844903520378814471\" title=\"https://juejin.cn/post/6844903520378814471\">简单易懂的 webpack 打包后 JS 的运行过程</a>，<a href=\"https://juejin.cn/post/6888936770692448270\" title=\"https://juejin.cn/post/6888936770692448270\">Webpack 手写 loader 和 plugin</a><br>热更新原理：<a href=\"https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/30669007\" title=\"https://zhuanlan.zhihu.com/p/30669007\">Webpack HMR 原理解析</a><br>面试题：<a href=\"https://juejin.cn/post/6844904094281236487\" title=\"https://juejin.cn/post/6844904094281236487\">「吐血整理」再来一打 Webpack 面试题</a></p>\n<p><strong>这里要注意，应该还会考 webpack5 和 4 有哪些区别。</strong></p>\n<h2 id=\"八、模块化\"><a href=\"#八、模块化\" class=\"headerlink\" title=\"八、模块化\"></a>八、模块化</h2><p><a href=\"https://juejin.cn/post/6844903744518389768\" title=\"https://juejin.cn/post/6844903744518389768\">前端模块化详解 (完整版)</a> （这里面没有讲 umd）<br><a href=\"https://juejin.cn/post/6844903927104667662\" title=\"https://juejin.cn/post/6844903927104667662\">可能是最详细的 UMD 模块入门指南</a></p>\n<h2 id=\"九、性能优化\"><a href=\"#九、性能优化\" class=\"headerlink\" title=\"九、性能优化\"></a>九、性能优化</h2><p>代码层面：</p>\n<ul>\n<li>防抖和节流（resize，scroll，input）。</li>\n<li>减少回流（重排）和重绘。</li>\n<li>事件委托。</li>\n<li>css 放 ，js 脚本放 最底部。</li>\n<li>减少 DOM 操作。</li>\n<li>按需加载，比如 React 中使用 <code>React.lazy</code> 和 <code>React.Suspense</code> ，通常需要与 webpack 中的 <code>splitChunks</code> 配合。</li>\n</ul>\n<p>构建方面：</p>\n<ul>\n<li><strong>压缩代码文件</strong>，在 webpack 中使用 <code>terser-webpack-plugin</code> 压缩 Javascript 代码；使用 <code>css-minimizer-webpack-plugin</code> 压缩 CSS 代码；使用 <code>html-webpack-plugin</code> 压缩 html 代码。</li>\n<li><strong>开启 gzip 压缩</strong>，webpack 中使用 <code>compression-webpack-plugin</code> ，node 作为服务器也要开启，使用 <code>compression</code>。</li>\n<li><strong>常用的第三方库使用 CDN 服务</strong>，在 webpack 中我们要配置 externals，将比如 React， Vue 这种包不打倒最终生成的文件中。而是采用 CDN 服务。</li>\n</ul>\n<p>其它：</p>\n<ul>\n<li>使用 http2。因为解析速度快，头部压缩，多路复用，服务器推送静态资源。</li>\n<li>使用服务端渲染。</li>\n<li>图片压缩。</li>\n<li>使用 http 缓存，比如服务端的响应中添加 <code>Cache-Control / Expires</code> 。</li>\n</ul>\n<h2 id=\"十、常见手写\"><a href=\"#十、常见手写\" class=\"headerlink\" title=\"十、常见手写\"></a>十、常见手写</h2><p>以下的内容是上面没有提到的手写，比如 <code>new</code> 、<code>Promise.all</code> 这种上面内容中已经提到了如何写。</p>\n<h3 id=\"1、防抖\"><a href=\"#1、防抖\" class=\"headerlink\" title=\"1、防抖\"></a>1、防抖</h3><p><a href=\"https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/22\" title=\"https://github.com/mqyqingfeng/Blog/issues/22\">JavaScript 专题之跟着 underscore 学防抖</a> </p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function debounce(func, wait, immediate) &#123;\n  let timeout;\n\n  return function () &#123;\n    let context &#x3D; this;\n    let args &#x3D; arguments;\n\n    if (timeout) clearTimeout(timeout);\n    if (immediate) &#123;\n      let callNow &#x3D; !timeout;\n      timeout &#x3D; setTimeout(function () &#123;\n        timeout &#x3D; null;\n      &#125;, wait);\n      if (callNow) func.apply(context, args);\n    &#125; else &#123;\n      timeout &#x3D; setTimeout(function () &#123;\n        func.apply(context, args);\n      &#125;, wait);\n    &#125;\n  &#125;;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"2、节流\"><a href=\"#2、节流\" class=\"headerlink\" title=\"2、节流\"></a>2、节流</h3><p><a href=\"https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/26\" title=\"https://github.com/mqyqingfeng/Blog/issues/26\">JavaScript 专题之跟着 underscore 学节流</a></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 使用时间戳\nfunction throttle(func, wait) &#123;\n  let preTime &#x3D; 0;\n\n  return function () &#123;\n    let nowTime &#x3D; +new Date();\n    let context &#x3D; this;\n    let args &#x3D; arguments;\n\n    if (nowTime - preTime &gt; wait) &#123;\n      func.apply(context, args);\n      preTime &#x3D; nowTime;\n    &#125;\n  &#125;;\n&#125;\n\n&#x2F;&#x2F; 定时器实现\nfunction throttle(func, wait) &#123;\n  let timeout;\n\n  return function () &#123;\n    let context &#x3D; this;\n    let args &#x3D; arguments;\n\n    if (!timeout) &#123;\n      timeout &#x3D; setTimeout(function () &#123;\n        timeout &#x3D; null;\n        func.apply(context, args);\n      &#125;, wait);\n    &#125;\n  &#125;;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"3、快速排序\"><a href=\"#3、快速排序\" class=\"headerlink\" title=\"3、快速排序\"></a>3、快速排序</h3><p>这里对快排思想不太明白的同学可以看下这个讲解的很清晰的视频：<a href=\"https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1at411T75o?from=search&seid=10065750342799523965&spm_id_from=333.337.0.0\" title=\"https://www.bilibili.com/video/BV1at411T75o?from=search&amp;seid=10065750342799523965&amp;spm_id_from=333.337.0.0\">快速排序算法</a>。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function sortArray(nums) &#123;\n  quickSort(0, nums.length - 1, nums);\n  return nums;\n&#125;\n\nfunction quickSort(start, end, arr) &#123;\n  if (start &lt; end) &#123;\n    const mid &#x3D; sort(start, end, arr);\n    quickSort(start, mid - 1, arr);\n    quickSort(mid + 1, end, arr);\n  &#125;\n&#125;\n\nfunction sort(start, end, arr) &#123;\n  const base &#x3D; arr[start];\n  let left &#x3D; start;\n  let right &#x3D; end;\n  while (left !&#x3D;&#x3D; right) &#123;\n    while (arr[right] &gt;&#x3D; base &amp;&amp; right &gt; left) &#123;\n      right--;\n    &#125;\n    arr[left] &#x3D; arr[right];\n    while (arr[left] &lt;&#x3D; base &amp;&amp; right &gt; left) &#123;\n      left++;\n    &#125;\n    arr[right] &#x3D; arr[left];\n  &#125;\n  arr[left] &#x3D; base;\n  return left;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"4、instanceof\"><a href=\"#4、instanceof\" class=\"headerlink\" title=\"4、instanceof\"></a>4、instanceof</h3><p>这个手写一定要懂原型及原型链。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function myInstanceof(target, origin) &#123;\n  if (typeof target !&#x3D;&#x3D; &quot;object&quot; || target &#x3D;&#x3D;&#x3D; null) return false;\n  if (typeof origin !&#x3D;&#x3D; &quot;function&quot;)\n    throw new TypeError(&quot;origin must be function&quot;);\n  let proto &#x3D; Object.getPrototypeOf(target); &#x2F;&#x2F; 相当于 proto &#x3D; target.__proto__;\n  while (proto) &#123;\n    if (proto &#x3D;&#x3D;&#x3D; origin.prototype) return true;\n    proto &#x3D; Object.getPrototypeOf(proto);\n  &#125;\n  return false;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"5、数组扁平化\"><a href=\"#5、数组扁平化\" class=\"headerlink\" title=\"5、数组扁平化\"></a>5、数组扁平化</h3><p>重点，不要觉得用不到就不管，这道题就是考察你对 js 语法的熟练程度以及手写代码的基本能力。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function flat(arr, depth &#x3D; 1) &#123;\n  if (depth &gt; 0) &#123;\n    &#x2F;&#x2F; 以下代码还可以简化，不过为了可读性，还是....\n    return arr.reduce((pre, cur) &#x3D;&gt; &#123;\n      return pre.concat(Array.isArray(cur) ? flat(cur, depth - 1) : cur);\n    &#125;, []);\n  &#125;\n  return arr.slice();\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"6、手写-reduce\"><a href=\"#6、手写-reduce\" class=\"headerlink\" title=\"6、手写 reduce\"></a>6、手写 reduce</h3><p>先不考虑第二个参数初始值：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Array.prototype.reduce &#x3D; function (cb) &#123;\n  const arr &#x3D; this; &#x2F;&#x2F;this就是调用reduce方法的数组\n  let total &#x3D; arr[0]; &#x2F;&#x2F; 默认为数组的第一项\n  for (let i &#x3D; 1; i &lt; arr.length; i++) &#123;\n    total &#x3D; cb(total, arr[i], i, arr);\n  &#125;\n  return total;\n&#125;;\n复制代码</code></pre>\n\n<p>考虑上初始值：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Array.prototype.reduce &#x3D; function (cb, initialValue) &#123;\n  const arr &#x3D; this;\n  let total &#x3D; initialValue || arr[0];\n  &#x2F;&#x2F; 有初始值的话从0遍历，否则从1遍历\n  for (let i &#x3D; initialValue ? 0 : 1; i &lt; arr.length; i++) &#123;\n    total &#x3D; cb(total, arr[i], i, arr);\n  &#125;\n  return total;\n&#125;;\n复制代码</code></pre>\n\n<h3 id=\"7、带并发的异步调度器-Scheduler\"><a href=\"#7、带并发的异步调度器-Scheduler\" class=\"headerlink\" title=\"7、带并发的异步调度器 Scheduler\"></a>7、带并发的异步调度器 Scheduler</h3><p>JS 实现一个带并发限制的异度调度器 Scheduler，保证同时运行的任务最多有两个。完善下面代码中的 Scheduler 类，使得以下程序能正确输出。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Scheduler &#123;\n  add(promiseMaker) &#123;&#125;\n&#125;\n\nconst timeout &#x3D; (time) &#x3D;&gt;\n  new Promise((resolve) &#x3D;&gt; &#123;\n    setTimeout(resolve, time);\n  &#125;);\n\nconst scheduler &#x3D; new Scheduler();\nconst addTask &#x3D; (time, order) &#x3D;&gt; &#123;\n  scheduler.add(() &#x3D;&gt; timeout(time).then(() &#x3D;&gt; console.log(order)));\n&#125;;\n\naddTask(1000, &quot;1&quot;);\naddTask(500, &quot;2&quot;);\naddTask(300, &quot;3&quot;);\naddTask(400, &quot;4&quot;);\n&#x2F;&#x2F; output：2 3 1 4\n&#x2F;&#x2F; 一开始，1，2两个任务进入队列。\n&#x2F;&#x2F; 500ms 时，2完成，输出2，任务3入队。\n&#x2F;&#x2F; 800ms 时，3完成，输出3，任务4入队。\n&#x2F;&#x2F; 1000ms 时，1完成，输出1。\n复制代码</code></pre>\n\n<p>根据题目，我们只需要操作 <code>Scheduler</code> 类就行：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">class Scheduler &#123;\n  constructor() &#123;\n    this.waitTasks &#x3D; []; &#x2F;&#x2F; 待执行的任务队列\n    this.excutingTasks &#x3D; []; &#x2F;&#x2F; 正在执行的任务队列\n    this.maxExcutingNum &#x3D; 2; &#x2F;&#x2F; 允许同时运行的任务数量\n  &#125;\n\n  add(promiseMaker) &#123;\n    if (this.excutingTasks.length &lt; this.maxExcutingNum) &#123;\n      this.run(promiseMaker);\n    &#125; else &#123;\n      this.waitTasks.push(promiseMaker);\n    &#125;\n  &#125;\n\n  run(promiseMaker) &#123;\n    const len &#x3D; this.excutingTasks.push(promiseMaker);\n    const index &#x3D; len - 1;\n    promiseMaker().then(() &#x3D;&gt; &#123;\n      this.excutingTasks.splice(index, 1);\n      if (this.waitTasks.length &gt; 0) &#123;\n        this.run(this.waitTasks.shift());\n      &#125;\n    &#125;);\n  &#125;\n&#125;\n复制代码</code></pre>\n\n<h3 id=\"8、去重\"><a href=\"#8、去重\" class=\"headerlink\" title=\"8、去重\"></a>8、去重</h3><ul>\n<li>利用 ES6 <code>set</code> 关键字：</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function unique(arr) &#123;\n  return [...new Set(arr)];\n&#125;\n复制代码</code></pre>\n\n<ul>\n<li>利用 ES5 <code>filter</code> 方法：</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function unique(arr) &#123;\n  return arr.filter((item, index, array) &#x3D;&gt; &#123;\n    return array.indexOf(item) &#x3D;&#x3D;&#x3D; index;\n  &#125;);\n&#125;\n复制代码</code></pre>\n\n<h2 id=\"十一、其它\"><a href=\"#十一、其它\" class=\"headerlink\" title=\"十一、其它\"></a>十一、其它</h2><ol>\n<li>requestAnimationFrame（<a href=\"https://juejin.cn/post/6991297852462858277\" title=\"https://juejin.cn/post/6991297852462858277\">一个神奇的前端动画 API requestAnimationFrame</a>）</li>\n<li>如何排查内存泄漏问题，面试官可能会问为什么页面越来越卡顿，直至卡死，怎么定位到产生这种现象的源代码（开发环境）？（<a href=\"https://juejin.cn/post/6947841638118998029\" title=\"https://juejin.cn/post/6947841638118998029\">一文带你了解如何排查内存泄漏导致的页面卡顿现象</a>）</li>\n<li>vite 大火，我复习的时候是去年 9 月份，还没那么火，可能现在的你需要学一学了～</li>\n<li>vue3 也一样，如果你是 React 技术栈（就像我之前一样）当我没说。</li>\n<li>TCP&amp;UDP <a href=\"https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html\">https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html</a></li>\n</ol>\n<h2 id=\"十二、算法\"><a href=\"#十二、算法\" class=\"headerlink\" title=\"十二、算法\"></a>十二、算法</h2><p>这部分大家可以点击以下这个仓库，按照仓库中的题目顺序进行刷题，都是我亲自刷过的，排了最适合的顺序：<a href=\"https://link.juejin.cn/?target=https://github.com/vortesnail/leetcode\" title=\"https://github.com/vortesnail/leetcode\">vortesnail&#x2F;leetcode</a>。<br>然后如果大家想看下大厂的算法高频题可以看这个仓库：<a href=\"https://link.juejin.cn/?target=https://github.com/afatcoder/LeetcodeTop\" title=\"https://github.com/afatcoder/LeetcodeTop\">afatcoder&#x2F;LeetcodeTop</a>。</p>\n","feature":false,"text":"一、简历 简历在找工作过程中是非常非常重要的，无论你是什么途径去面试的，面试你的人一定会看你的简历。 推荐阅读：如何写「前端简历」，能敲开字节跳动的大门？一份优秀的前端开发工程师简历是怎么样的？ 1、重点 简历就像高考作文——阅卷时间非常短。 内容要简洁。 直击重点，表现出自己的...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"36 mins."},"categories":[{"name":"Frontend","slug":"Frontend","count":2,"path":"api/categories/Frontend.json"}],"tags":[{"name":"面经","slug":"面经","count":2,"path":"api/tags/面经.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81%E9%87%8D%E7%82%B9\"><span class=\"toc-text\">1、重点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81%E7%AE%80%E5%8E%86%E5%8C%85%E5%90%AB%E7%9A%84%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">2、简历包含的内容</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">2.1 基本信息</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-%E4%B8%93%E4%B8%9A%E6%8A%80%E8%83%BD\"><span class=\"toc-text\">2.2 专业技能</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-%E5%B7%A5%E4%BD%9C%E7%BB%8F%E5%8E%86\"><span class=\"toc-text\">2.3 工作经历</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86\"><span class=\"toc-text\">2.4 项目经历</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-%E7%A4%BE%E5%8C%BA%E8%B4%A1%E7%8C%AE\"><span class=\"toc-text\">2.5 社区贡献</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">3、注意事项</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%E3%80%81%E9%9D%A2%E8%AF%95%E5%89%8D%E5%87%86%E5%A4%87\"><span class=\"toc-text\">4、面试前准备</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81HTML-CSS-%E9%9D%A2%E8%AF%95%E9%A2%98\"><span class=\"toc-text\">二、HTML+CSS 面试题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81HTML-%E9%9D%A2%E8%AF%95%E9%A2%98\"><span class=\"toc-text\">1、HTML 面试题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-HTML-%E8%AF%AD%E4%B9%89%E5%8C%96%EF%BC%9F\"><span class=\"toc-text\">1.1 如何理解 HTML 语义化？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-script-%E6%A0%87%E7%AD%BE%E4%B8%AD-defer-%E5%92%8C-async-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">1.2 script 标签中 defer 和 async 的区别？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5-url-%E5%88%B0%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">1.3 从浏览器地址栏输入 url 到请求返回发生了什么</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81CSS-%E9%9D%A2%E8%AF%95%E9%A2%98\"><span class=\"toc-text\">2、CSS 面试题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">2.1 盒模型介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-css-%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">2.2 css 选择器和优先级</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-%E9%87%8D%E6%8E%92%EF%BC%88reflow%EF%BC%89%E5%92%8C%E9%87%8D%E7%BB%98%EF%BC%88repaint%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">2.3 重排（reflow）和重绘（repaint）的理解</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-%E5%AF%B9-BFC-%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">2.4 对 BFC 的理解</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5-%E5%AE%9E%E7%8E%B0%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80%EF%BC%88%E5%B7%A6%E4%BE%A7%E5%9B%BA%E5%AE%9A-%E5%8F%B3%E4%BE%A7%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%EF%BC%89\"><span class=\"toc-text\">2.5 实现两栏布局（左侧固定 + 右侧自适应布局）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-6-%E5%AE%9E%E7%8E%B0%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%EF%BC%88%E7%BB%8F%E5%85%B8%E4%B8%89%E5%88%86%E6%A0%8F%E5%B8%83%E5%B1%80%EF%BC%89\"><span class=\"toc-text\">2.6 实现圣杯布局和双飞翼布局（经典三分栏布局）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-7-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2.7 水平垂直居中多种实现方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-8-flex-%E5%B8%83%E5%B1%80\"><span class=\"toc-text\">2.8 flex 布局</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-9-line-height-%E5%A6%82%E4%BD%95%E7%BB%A7%E6%89%BF%EF%BC%9F\"><span class=\"toc-text\">2.9 line-height 如何继承？</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81js-%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">三、js 基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">1、数据类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D%EF%BC%8C%E5%8F%8A%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">1.1 基本的数据类型介绍，及值类型和引用类型的理解</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">1.2 数据类型的判断</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-%E6%89%8B%E5%86%99%E6%B7%B1%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">1.3 手写深拷贝</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-4-%E6%A0%B9%E6%8D%AE-0-1-0-2-x3D-x3D-0-3%EF%BC%8C%E8%AE%B2%E8%AE%B2-IEEE-754-%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%A9%E5%85%B6%E7%9B%B8%E7%AD%89%EF%BC%9F\"><span class=\"toc-text\">1.4 根据 0.1+0.2 ! &#x3D;&#x3D; 0.3，讲讲 IEEE 754 ，如何让其相等？</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE\"><span class=\"toc-text\">2、 原型和原型链</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E3%80%81-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE\"><span class=\"toc-text\">3、 作用域与作用域链</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%E3%80%81-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87\"><span class=\"toc-text\">4、 执行上下文</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5%E3%80%81-%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">5、 闭包</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6%E3%80%81-call%E3%80%81apply%E3%80%81bind-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">6、 call、apply、bind 实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7%E3%80%81-new-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">7、 new 实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8%E3%80%81-%E5%BC%82%E6%AD%A5\"><span class=\"toc-text\">8、 异步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-1-event-loop%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">8.1 event loop、宏任务和微任务</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-2-Promise\"><span class=\"toc-text\">8.2 Promise</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-3-async-x2F-await-%E5%92%8C-Promise-%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">8.3 async&#x2F;await 和 Promise 的关系</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9%E3%80%81-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">9、 浏览器的垃圾回收机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10%E3%80%81-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-EventMitter-%E7%B1%BB\"><span class=\"toc-text\">10、 实现一个 EventMitter 类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81web-%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">四、web 存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81cookie\"><span class=\"toc-text\">1、cookie</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81localStorage-%E5%92%8C-sessionStorage\"><span class=\"toc-text\">2、localStorage 和 sessionStorage</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81Http\"><span class=\"toc-text\">五、Http</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81http-%E7%8A%B6%E6%80%81%E7%A0%81\"><span class=\"toc-text\">1、http 状态码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">1.1 状态码分类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81\"><span class=\"toc-text\">1.2 常见状态码</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-3-%E5%85%B3%E4%BA%8E%E5%8D%8F%E8%AE%AE%E5%92%8C%E8%A7%84%E8%8C%83\"><span class=\"toc-text\">1.3 关于协议和规范</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81http-%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">2、http 缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-%E5%85%B3%E4%BA%8E%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">4.1 关于缓存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">4.2 强制缓存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-3-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%88%E5%AF%B9%E6%AF%94%E7%BC%93%E5%AD%98%EF%BC%89\"><span class=\"toc-text\">4.3 协商缓存（对比缓存）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-4-%E7%BB%BC%E8%BF%B0\"><span class=\"toc-text\">4.4 综述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-4-%E4%B8%89%E7%A7%8D%E5%88%B7%E6%96%B0%E6%93%8D%E4%BD%9C%E5%AF%B9-http-%E7%BC%93%E5%AD%98%E7%9A%84%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">4.4 三种刷新操作对 http 缓存的影响</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E9%9D%A2%E8%AF%95\"><span class=\"toc-text\">3. 面试</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81React\"><span class=\"toc-text\">六、React</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81-React-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%8CReact-16-%E5%92%8C-React-17-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%8D%E5%90%8C\"><span class=\"toc-text\">1、 React 事件机制，React 16 和 React 17 事件机制的不同</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81class-component\"><span class=\"toc-text\">2、class component</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">2.1 生命周期</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-setState-%E5%90%8C%E6%AD%A5%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5\"><span class=\"toc-text\">2.2 setState 同步还是异步</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%AF%B9%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">3、对函数式编程的理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%E3%80%81react-hooks\"><span class=\"toc-text\">4、react hooks</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%9C%A8%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E4%B8%AD%E5%86%99-hook\"><span class=\"toc-text\">4.1 为什么不能在条件语句中写 hook</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-HOC-%E5%92%8C-hook-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.2 HOC 和 hook 的区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-3-useEffect-%E5%92%8C-useLayoutEffect-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.3 useEffect 和 useLayoutEffect 区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-4-useEffect-%E4%BE%9D%E8%B5%96%E4%B8%BA%E7%A9%BA%E6%95%B0%E7%BB%84%E4%B8%8E-componentDidMount-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.4 useEffect 依赖为空数组与 componentDidMount 区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-5-React-memo-%E5%92%8C-React-useMemo-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.5 React.memo() 和 React.useMemo() 的区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-6-React-useCallback-%E5%92%8C-React-useMemo-%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">4.6 React.useCallback() 和 React.useMemo() 的区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-7-React-forwardRef-%E6%98%AF%E4%BB%80%E4%B9%88%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">4.7 React.forwardRef 是什么及其作用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6%E3%80%81react-hooks-%E4%B8%8E-class-%E7%BB%84%E4%BB%B6%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">6、react hooks 与 class 组件对比</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7%E3%80%81%E4%BB%8B%E7%BB%8D-React-dom-diff-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">7、介绍 React dom diff 算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8%E3%80%81%E5%AF%B9-React-Fiber-%E7%9A%84%E7%90%86%E8%A7%A3\"><span class=\"toc-text\">8、对 React Fiber 的理解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9%E3%80%81React-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5\"><span class=\"toc-text\">9、React 性能优化手段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10%E3%80%81React-Redux\"><span class=\"toc-text\">10、React Redux</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%83%E3%80%81webpack\"><span class=\"toc-text\">七、webpack</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AB%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96\"><span class=\"toc-text\">八、模块化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B9%9D%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">九、性能优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E3%80%81%E5%B8%B8%E8%A7%81%E6%89%8B%E5%86%99\"><span class=\"toc-text\">十、常见手写</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81%E9%98%B2%E6%8A%96\"><span class=\"toc-text\">1、防抖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81%E8%8A%82%E6%B5%81\"><span class=\"toc-text\">2、节流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">3、快速排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%E3%80%81instanceof\"><span class=\"toc-text\">4、instanceof</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5%E3%80%81%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96\"><span class=\"toc-text\">5、数组扁平化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6%E3%80%81%E6%89%8B%E5%86%99-reduce\"><span class=\"toc-text\">6、手写 reduce</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7%E3%80%81%E5%B8%A6%E5%B9%B6%E5%8F%91%E7%9A%84%E5%BC%82%E6%AD%A5%E8%B0%83%E5%BA%A6%E5%99%A8-Scheduler\"><span class=\"toc-text\">7、带并发的异步调度器 Scheduler</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8%E3%80%81%E5%8E%BB%E9%87%8D\"><span class=\"toc-text\">8、去重</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%B8%80%E3%80%81%E5%85%B6%E5%AE%83\"><span class=\"toc-text\">十一、其它</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%81%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">十二、算法</span></a>","author":{"name":"析构理想","slug":"blog-author","avatar":"https://s1.ax1x.com/2020/07/04/NxaLkV.jpg","link":"/tech","description":"在这个世界上，最让人畏惧的恰恰是通向自己的道路 <br /> @ <b>公众号：析构理想</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"Github":{"icon":"/svg/github.svg","link":"https://github.com/idealdestructor"},"Twitter":{"icon":"/svg/twitter.svg","link":"https://twitter.com/idealdestructor"},"Instgram":{"icon":"/svg/instagram.svg","link":"https://instagram.com/idealdestructor"},"Weibo":{"icon":"/svg/weibo.svg","link":"https://weibo.com/6019347563/profile"},"Zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/idealdestructor"},"Bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/305094533?spm_id_from=333.1007.0.0"}}}},"mapped":true,"prev_post":{"title":"「前端面试」 JS 编程题目总结","uid":"436595af82415f3136acebc87ded2af2","slug":"「前端面试」 JS 编程题目总结","date":"2022-01-04T03:02:15.000Z","updated":"2022-05-18T11:15:56.378Z","comments":true,"path":"api/articles/「前端面试」 JS 编程题目总结.json","keywords":null,"cover":"https://source.unsplash.com/wh-RPfR_3_M/1600x900","text":" 前端面试中，手撕代码环节除了力扣上的算法题目之外，还有一些针对前端知识点的题目，大致有以下几类： 算法类 原理类 应用类 算法类 1. 手写快排、冒泡、选择排序 2. URL 拆解问题 3. 将 HTTP header 转换成 js 对象 注意到 这样的输入格式叫做 模板字符串...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[{"name":"Frontend","slug":"Frontend","count":2,"path":"api/categories/Frontend.json"}],"tags":[{"name":"面经","slug":"面经","count":2,"path":"api/tags/面经.json"}],"author":{"name":"析构理想","slug":"blog-author","avatar":"https://s1.ax1x.com/2020/07/04/NxaLkV.jpg","link":"/tech","description":"在这个世界上，最让人畏惧的恰恰是通向自己的道路 <br /> @ <b>公众号：析构理想</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"Github":{"icon":"/svg/github.svg","link":"https://github.com/idealdestructor"},"Twitter":{"icon":"/svg/twitter.svg","link":"https://twitter.com/idealdestructor"},"Instgram":{"icon":"/svg/instagram.svg","link":"https://instagram.com/idealdestructor"},"Weibo":{"icon":"/svg/weibo.svg","link":"https://weibo.com/6019347563/profile"},"Zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/idealdestructor"},"Bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/305094533?spm_id_from=333.1007.0.0"}}}},"feature":false},"next_post":{}}