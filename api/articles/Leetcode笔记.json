{"title":"Leetcode题解","uid":"90f2417d388e3c74c0ba506e56fcf375","slug":"Leetcode笔记","date":"2022-01-04T03:02:15.000Z","updated":"2022-05-18T11:15:56.376Z","comments":true,"path":"api/articles/Leetcode笔记.json","keywords":null,"cover":"https://source.unsplash.com/pOwKTIgjKjU/1200x628","content":"<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><h2 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h2><h3 id=\"704-二分查找\"><a href=\"#704-二分查找\" class=\"headerlink\" title=\"704.二分查找\"></a>704.二分查找</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int search(vector&lt;int&gt;&amp; nums, int target) &#123;\n        int left &#x3D; 0;\n        int right &#x3D; nums.size(); &#x2F;&#x2F; 定义target在左闭右开的区间里，即：[left, right)\n        while (left &lt; right) &#123; &#x2F;&#x2F; 因为left &#x3D;&#x3D; right的时候，在[left, right)是无效的空间，所以使用 &lt;\n            int middle &#x3D; left + ((right - left) &gt;&gt; 1);\n            if (nums[middle] &gt; target) &#123;\n                right &#x3D; middle; &#x2F;&#x2F; target 在左区间，在[left, middle)中\n            &#125; else if (nums[middle] &lt; target) &#123;\n                left &#x3D; middle + 1; &#x2F;&#x2F; target 在右区间，在[middle + 1, right)中\n            &#125; else &#123; &#x2F;&#x2F; nums[middle] &#x3D;&#x3D; target\n                return middle; &#x2F;&#x2F; 数组中找到目标值，直接返回下标\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 未找到目标值\n        return -1;\n    &#125;\n&#125;;</code></pre>\n\n<h2 id=\"快慢指针\"><a href=\"#快慢指针\" class=\"headerlink\" title=\"快慢指针\"></a>快慢指针</h2><h3 id=\"27-移除元素\"><a href=\"#27-移除元素\" class=\"headerlink\" title=\"27. 移除元素\"></a>27. 移除元素</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;\n        int slowIndex &#x3D; 0;\n        for (int fastIndex &#x3D; 0; fastIndex &lt; nums.size(); fastIndex++) &#123;\n            if (val !&#x3D; nums[fastIndex]) &#123;\n                nums[slowIndex++] &#x3D; nums[fastIndex];\n            &#125;\n        &#125;\n        return slowIndex;\n    &#125;\n&#125;;</code></pre>\n\n<h2 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h2><h3 id=\"209-长度最小的子数组\"><a href=\"#209-长度最小的子数组\" class=\"headerlink\" title=\"209.长度最小的子数组\"></a>209.长度最小的子数组</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;\n        int result &#x3D; INT32_MAX;\n        int sum &#x3D; 0; &#x2F;&#x2F; 滑动窗口数值之和\n        int i &#x3D; 0; &#x2F;&#x2F; 滑动窗口起始位置\n        int subLength &#x3D; 0; &#x2F;&#x2F; 滑动窗口的长度\n        for (int j &#x3D; 0; j &lt; nums.size(); j++) &#123;\n            sum +&#x3D; nums[j];\n            &#x2F;&#x2F; 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件\n            while (sum &gt;&#x3D; s) &#123;\n                subLength &#x3D; (j - i + 1); &#x2F;&#x2F; 取子序列的长度\n                result &#x3D; result &lt; subLength ? result : subLength;\n                sum -&#x3D; nums[i++]; &#x2F;&#x2F; 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列\n        return result &#x3D;&#x3D; INT32_MAX ? 0 : result;\n    &#125;\n&#125;;</code></pre>\n\n<h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a><strong>链表</strong></h1><h2 id=\"虚拟头结点\"><a href=\"#虚拟头结点\" class=\"headerlink\" title=\"虚拟头结点\"></a>虚拟头结点</h2><h3 id=\"203-移除链表元素\"><a href=\"#203-移除链表元素\" class=\"headerlink\" title=\"203.移除链表元素\"></a>203.移除链表元素</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    ListNode* removeElements(ListNode* head, int val) &#123;\n        ListNode* dummyHead &#x3D; new ListNode(0); &#x2F;&#x2F; 设置一个虚拟头结点\n        dummyHead-&gt;next &#x3D; head; &#x2F;&#x2F; 将虚拟头结点指向head，这样方面后面做删除操作\n        ListNode* cur &#x3D; dummyHead;\n        while (cur-&gt;next !&#x3D; NULL) &#123;\n            if(cur-&gt;next-&gt;val &#x3D;&#x3D; val) &#123;\n                ListNode* tmp &#x3D; cur-&gt;next;\n                cur-&gt;next &#x3D; cur-&gt;next-&gt;next;\n                delete tmp;\n            &#125; else &#123;\n                cur &#x3D; cur-&gt;next;\n            &#125;\n        &#125;\n        head &#x3D; dummyHead-&gt;next;\n        delete dummyHead;\n        return head;\n    &#125;\n&#125;;</code></pre>\n\n<h1 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a><strong>哈希表</strong></h1><h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><h3 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1. 两数之和\"></a>1. 两数之和</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\"></code></pre>\n\n","feature":true,"text":"数组二分查找704.二分查找class Solution &#123; public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left &#x3D; 0; int right &#x3D; n...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":1,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Leetcode","slug":"Leetcode","count":1,"path":"api/tags/Leetcode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">二分查找</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">704.二分查找</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88\"><span class=\"toc-text\">快慢指针</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">27. 移除元素</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3\"><span class=\"toc-text\">滑动窗口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">209.长度最小的子数组</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%A4%B4%E7%BB%93%E7%82%B9\"><span class=\"toc-text\">虚拟头结点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">203.移除链表元素</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%93%88%E5%B8%8C%E8%A1%A8\"><span class=\"toc-text\">哈希表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#map\"><span class=\"toc-text\">map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">1. 两数之和</span></a></li></ol></li></ol></li></ol>","author":{"name":"析构理想","slug":"blog-author","avatar":"https://s1.ax1x.com/2020/07/04/NxaLkV.jpg","link":"/","description":"在这个世界上，最让人畏惧的恰恰是通向自己的道路 <br /> @ <b>公众号：析构理想</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"Github":{"icon":"/svg/github.svg","link":"https://github.com/idealdestructor"},"Twitter":{"icon":"/svg/twitter.svg","link":"https://twitter.com/idealdestructor"},"Instgram":{"icon":"/svg/instagram.svg","link":"https://instagram.com/idealdestructor"},"Weibo":{"icon":"/svg/weibo.svg","link":"https://weibo.com/6019347563/profile"},"Zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/idealdestructor"},"Bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/305094533?spm_id_from=333.1007.0.0"}}}},"mapped":true,"prev_post":{"title":"机器学习笔记","uid":"87bd32def55d1658e30fe63fa209a657","slug":"机器学习笔记","date":"2022-01-04T03:02:15.000Z","updated":"2022-05-18T11:15:56.381Z","comments":true,"path":"api/articles/机器学习笔记.json","keywords":null,"cover":"https://source.unsplash.com/yQnyP1g5zl4/1200x628","text":"Boosting &amp; Bagging用抽样的方式从原始样本中进行有放回的多次抽样（或者是抽特征），这种方法叫做Bootstraping，抽取k次每次抽取n个样本，这样就生成了k个样本容量为n的数据集。原始数据集中的样本可能是多次被抽到也可能是没有被抽到。 boosting...","link":"","photos":[],"count_time":{"symbolsCount":400,"symbolsTime":"1 mins."},"categories":[{"name":"AI","slug":"AI","count":3,"path":"api/categories/AI.json"}],"tags":[{"name":"机器学习","slug":"机器学习","count":1,"path":"api/tags/机器学习.json"}],"author":{"name":"析构理想","slug":"blog-author","avatar":"https://s1.ax1x.com/2020/07/04/NxaLkV.jpg","link":"/","description":"在这个世界上，最让人畏惧的恰恰是通向自己的道路 <br /> @ <b>公众号：析构理想</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"Github":{"icon":"/svg/github.svg","link":"https://github.com/idealdestructor"},"Twitter":{"icon":"/svg/twitter.svg","link":"https://twitter.com/idealdestructor"},"Instgram":{"icon":"/svg/instagram.svg","link":"https://instagram.com/idealdestructor"},"Weibo":{"icon":"/svg/weibo.svg","link":"https://weibo.com/6019347563/profile"},"Zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/idealdestructor"},"Bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/305094533?spm_id_from=333.1007.0.0"}}}},"feature":true},"next_post":{"title":"「前端面试」 JS 编程题目总结","uid":"436595af82415f3136acebc87ded2af2","slug":"「前端面试」 JS 编程题目总结","date":"2022-01-04T03:02:15.000Z","updated":"2022-05-18T11:15:56.378Z","comments":true,"path":"api/articles/「前端面试」 JS 编程题目总结.json","keywords":null,"cover":"https://source.unsplash.com/wh-RPfR_3_M/1600x900","text":" 前端面试中，手撕代码环节除了力扣上的算法题目之外，还有一些针对前端知识点的题目，大致有以下几类： 算法类 原理类 应用类 算法类 1. 手写快排、冒泡、选择排序 2. URL 拆解问题 3. 将 HTTP header 转换成 js 对象 注意到 这样的输入格式叫做 模板字符串...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[{"name":"Frontend","slug":"Frontend","count":2,"path":"api/categories/Frontend.json"}],"tags":[{"name":"面经","slug":"面经","count":2,"path":"api/tags/面经.json"}],"author":{"name":"析构理想","slug":"blog-author","avatar":"https://s1.ax1x.com/2020/07/04/NxaLkV.jpg","link":"/","description":"在这个世界上，最让人畏惧的恰恰是通向自己的道路 <br /> @ <b>公众号：析构理想</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"Github":{"icon":"/svg/github.svg","link":"https://github.com/idealdestructor"},"Twitter":{"icon":"/svg/twitter.svg","link":"https://twitter.com/idealdestructor"},"Instgram":{"icon":"/svg/instagram.svg","link":"https://instagram.com/idealdestructor"},"Weibo":{"icon":"/svg/weibo.svg","link":"https://weibo.com/6019347563/profile"},"Zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/idealdestructor"},"Bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/305094533?spm_id_from=333.1007.0.0"}}}},"feature":false}}