{"title":"「前端面试」 JS 编程题目总结","uid":"436595af82415f3136acebc87ded2af2","slug":"「前端面试」 JS 编程题目总结","date":"2022-01-04T03:02:15.000Z","updated":"2022-03-15T12:20:54.891Z","comments":true,"path":"api/articles/「前端面试」 JS 编程题目总结.json","keywords":null,"cover":"https://source.unsplash.com/wh-RPfR_3_M/1600x900","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>前端面试中，手撕代码环节除了力扣上的算法题目之外，还有一些针对前端知识点的题目，大致有以下几类： 算法类 原理类 应用类 算法类 1. 手写快排、冒泡、选择排序 2. URL 拆解问题 3. 将 HTTP header 转换成 js 对象 注意到 这样的输入格式叫做 模板字符串。</p></blockquote>\n<p>前端面试中，手撕代码环节除了力扣上的算法题目之外，还有一些针对前端知识点的题目，大致有以下几类：</p>\n<ul>\n<li>算法类</li>\n<li>原理类</li>\n<li>应用类</li>\n</ul>\n<h2 id=\"算法类\"><a href=\"#算法类\" class=\"headerlink\" title=\"算法类\"></a><a href=\"#%E7%AE%97%E6%B3%95%E7%B1%BB\"></a>算法类</h2><p><strong>1. 手写快排、冒泡、选择排序</strong></p>\n<ul>\n<li>快速排序</li>\n<li>冒泡排序</li>\n<li>选择排序</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * --- 测试用例 ---\n *\n * 输入：[1, 34, 5, 76, 8, 6, 9, 7, 6, 3]\n * 输出：[1, 3, 5, 6, 6, 7, 8, 9, 34, 76]\n *\n * --- 说明 ---\n * \n * 思考：快速排序是稳定的吗？\n * 解答：base 的每次选择，会导致快排是不稳定排序。\n *&#x2F;\n\nconst quickSort &#x3D; (nums) &#x3D;&gt; &#123;\n    if (nums.length &lt; 2) &#123;\n        return nums;\n    &#125; else &#123;\n        var left &#x3D; [];\n        var right &#x3D; [];\n        var pivot &#x3D; Math.floor(nums.length &#x2F; 2); &#x2F;&#x2F; Math.floor 向下取整\n        var base &#x3D; nums.splice(pivot, 1)[0];\n        for (let i &#x3D; 0; i &lt; nums.length; i++) &#123;\n            if (nums[i] &lt; base) &#123;\n                left.push(nums[i]);\n            &#125; else &#123;\n                right.push(nums[i]);\n            &#125;\n        &#125;\n    &#125;\n    return quickSort(left).concat([base], quickSort(right));\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * --- 测试用例 ---\n *\n * 输入：[5, 2, 4, 7, 9, 8, 3, 6, 3, 8, 3]\n * 输出：[2, 3, 3, 3, 4, 5, 6, 7, 8, 8, 9]\n *\n * --- 说明 ---\n * \n * 思考：冒泡排序是稳定的吗？\n * 解答：稳定。相等的元素不发生交换\n *&#x2F;\n\nconst bubbleSort &#x3D; (nums) &#x3D;&gt; &#123;\n    for (var i &#x3D; 0; i &lt; nums.length - 1; i++) &#123;\n        for (var j &#x3D; 0; j &lt; nums.length - 1 - i; j++) &#123;\n            if (nums[j] &gt; nums[j + 1]) &#123;\n                let tmp &#x3D; nums[j];\n                nums[j] &#x3D; nums[j + 1];\n                nums[j + 1] &#x3D; tmp;\n            &#125;\n        &#125;\n    &#125;\n    return nums;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * --- 测试用例 ---\n *\n * 输入：[6, 45, 3, 2, 5, 6, 8, 4, 3, 4, 56, 67, 5]\n * 输出：[2, 3, 3, 4, 4, 5, 5, 6, 6, 8, 45, 56, 67]\n *\n * --- 说明 ---\n * \n * 思考：选择排序是稳定的吗？\n * 解答：要看代码是如何实现的，在本例中由于有交换，所以是不稳定排序。\n *&#x2F;\n\nconst selectSort &#x3D; (nums) &#x3D;&gt; &#123;\n    var idx; &#x2F;&#x2F; 最小值的索引\n    for (var i &#x3D; 0; i &lt; nums.length - 1; i++) &#123;\n        idx &#x3D; i;\n        for (var j &#x3D; i + 1; j &lt; nums.length; j++) &#123;\n            if (nums[j] &lt; nums[idx]) &#123;\n                idx &#x3D; j;\n            &#125;\n        &#125;\n        if (nums[i] &gt; nums[idx]) &#123;\n            let tmp &#x3D; nums[idx];\n            nums[idx] &#x3D; nums[i];\n            nums[i] &#x3D; tmp;\n        &#125;\n    &#125;\n    return nums;\n&#125;</code></pre>\n\n<p><strong>2. URL 拆解问题</strong></p>\n<ul>\n<li>题目一</li>\n<li>题目二</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * --- 题目描述 ---\n * \n * 实现一个函数，可以对 url 中的 query 部分做拆解，返回一个 key: value 形式的 object  \n * \n * --- 实例 ---\n * \n * 输入：&#39;http:&#x2F;&#x2F;sample.com&#x2F;?a&#x3D;1&amp;e&amp;b&#x3D;2&amp;c&#x3D;xx&amp;d#hash&#39; \n * 输出：&#123;a: 1, b: 2, c: &#39;xx&#39;, d: &#39;&#39;&#125;  \n *&#x2F;\n\nfunction getQueryObj(url) &#123;\n    &#x2F;&#x2F; TODO\n    let arr &#x3D; url.split(&#39;?&#39;)[1].split(&#39;#&#39;)[0].split(&#39;&amp;&#39;);\n    const res &#x3D; &#123;&#125;;\n    arr.forEach(e &#x3D;&gt; &#123;\n        const [key, value] &#x3D; e.split(&#39;&#x3D;&#39;);\n        if (!value) &#123;\n            res[key] &#x3D; &#39;&#39;;\n        &#125; else &#123;\n            res[key] &#x3D; value;\n        &#125;\n    &#125;)\n    return res;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * --- 题目描述 ---\n *\n * 实现一个 parseParem 函数，将 url 转化为指定结果\n *\n * --- 测试用例 ---\n *\n * 输入：url &#x3D; &#39;http:&#x2F;&#x2F;www.domain.com&#x2F;?user&#x3D;anonymous&amp;id&#x3D;123&amp;id&#x3D;456&amp;city&#x3D;%E5%8C%97%E4%BA%AC&amp;enabled&#39;\n * 输出：\n&#123;\n user:&#39;anonymous&#39;,\n id:[123,456],&#x2F;&#x2F; 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型\n city:&#39;北京&#39;,&#x2F;&#x2F; 中文需解码\n enabled: true &#x2F;&#x2F; 未指定值的 key 与约定为 true\n&#125;\n *&#x2F;\n\nconst parseParem &#x3D; (url) &#x3D;&gt; &#123;\n    const arr &#x3D; url.split(&#39;?&#39;)[1].split(&#39;&amp;&#39;);\n    const res &#x3D; &#123;&#125;;\n    arr.forEach((e) &#x3D;&gt; &#123;\n        let key &#x3D; e.split(&#39;&#x3D;&#39;)[0], value &#x3D; e.split(&#39;&#x3D;&#39;)[1];\n        if (value &#x3D;&#x3D;&#x3D; undefined) &#123;\n            res[key] &#x3D; true;\n        &#125; else &#123;\n            if (key in res) &#123;\n                Array.isArray(res[key]) ? res[key].push(value) : res[key] &#x3D; [res[key]].concat(value);\n            &#125; else &#123;\n                res[key] &#x3D; decodeURI(value)\n            &#125;\n        &#125;\n    &#125;)\n    return res;\n&#125;</code></pre>\n\n<p><strong>3. 将 HTTP header 转换成 js 对象</strong></p>\n<ul>\n<li>JavaScript</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * --- 题目描述 ---\n *\n * 实现一个方法，把 HTTP 文本形式(字符串)的 header 转换成 JS 对象。\n * \n * --- 测试用例 ---\n * \n * 输入：\n * &#96;Accept-Ranges: bytes \n * Cache-Control: max-age&#x3D;6000, public\n * Connection: keep-alive\n * Content-Type: application&#x2F;javascript&#96;\n * 输出：\n * &#123;\n *   &quot;Accept-Ranges&quot;: &quot;bytes&quot;,\n *   &quot;Cache-Control&quot;: &quot;max-age&#x3D;6000, public&quot;,\n *   Connection: &quot;keep-alive&quot;,\n *   &quot;Content-Type&quot;: &quot;application&#x2F;javascript&quot;\n * &#125;\n *\n * --- 解题思路 ---\n *\n * 1. 首先将每行数据作为数组的一个元素\n * 2. 将每个元素使用冒号分割，前面为 &#96;key&#96;，后面为 &#96;value&#96;。\n *&#x2F;\n\nconst solution &#x3D; (s) &#x3D;&gt; &#123;\n    let res &#x3D; &#123;&#125;;\n    let arr &#x3D; s.split(&quot;\\n&quot;);\n    arr.forEach((e) &#x3D;&gt; &#123;\n        let tmp &#x3D; e.split(&quot;: &quot;);\n        res[tmp[0]] &#x3D; tmp[1];\n    &#125;)\n    return res;\n&#125;</code></pre>\n\n<p>注意到</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#96;xxxxxx\nxxxxx\nxxxx&#96;</code></pre>\n\n<p>这样的输入格式叫做 <strong>模板字符串</strong>。</p>\n<p>输出如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#123;\n  &#39;Accept-Ranges&#39;: &#39;bytes&#39;,\n  &#39;Cache-Control&#39;: &#39;max-age&#x3D;6000, public&#39;,\n  Connection: &#39;keep-alive&#39;,\n  &#39;Content-Type&#39;: &#39;application&#x2F;javascript&#39;\n&#125;</code></pre>\n\n<p>注意到上面的输出结果中，<code>Connection</code> 没有带引号，这是为什么呢？</p>\n<p><strong>4. 将数组转化为树形结构</strong></p>\n<p>初始时，数组中的每个元素具有 4 个属性，其中有 <code>id</code> 和 <code>parent_id</code>，现在我们需要根据这两个 id 之间的关系，添加一个 <code>children</code> 属性，使之成为一棵树的结构。</p>\n<p>比如有如下数据：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var menu_list &#x3D; [&#123;\n    id: &#39;1&#39;,\n    menu_name: &#39;设置&#39;,\n    menu_url: &#39;setting&#39;,\n    parent_id: 0\n   &#125;, &#123;\n    id: &#39;1-1&#39;,\n    menu_name: &#39;权限设置&#39;,\n    menu_url: &#39;setting.permission&#39;,\n    parent_id: &#39;1&#39;\n   &#125;, &#123;\n    id: &#39;1-1-1&#39;,\n    menu_name: &#39;用户管理列表&#39;,\n    menu_url: &#39;setting.permission.user_list&#39;,\n    parent_id: &#39;1-1&#39;\n   &#125;, &#123;\n    id: &#39;1-1-2&#39;,\n    menu_name: &#39;用户管理新增&#39;,\n    menu_url: &#39;setting.permission.user_add&#39;,\n    parent_id: &#39;1-1&#39;\n   &#125;, &#123;\n    id: &#39;1-1-3&#39;,\n    menu_name: &#39;角色管理列表&#39;,\n    menu_url: &#39;setting.permission.role_list&#39;,\n    parent_id: &#39;1-1&#39;\n   &#125;, &#123;\n    id: &#39;1-2&#39;,\n    menu_name: &#39;菜单设置&#39;,\n    menu_url: &#39;setting.menu&#39;,\n    parent_id: &#39;1&#39;\n   &#125;, &#123;\n    id: &#39;1-2-1&#39;,\n    menu_name: &#39;菜单列表&#39;,\n    menu_url: &#39;setting.menu.menu_list&#39;,\n    parent_id: &#39;1-2&#39;\n   &#125;, &#123;\n    id: &#39;1-2-2&#39;,\n    menu_name: &#39;菜单添加&#39;,\n    menu_url: &#39;setting.menu.menu_add&#39;,\n    parent_id: &#39;1-2&#39;\n   &#125;, &#123;\n    id: &#39;2&#39;,\n    menu_name: &#39;订单&#39;,\n    menu_url: &#39;order&#39;,\n    parent_id: 0\n   &#125;, &#123;\n    id: &#39;2-1&#39;,\n    menu_name: &#39;报单审核&#39;,\n    menu_url: &#39;order.orderreview&#39;,\n    parent_id: &#39;2&#39;\n   &#125;, &#123;\n    id: &#39;2-2&#39;,\n    menu_name: &#39;退款管理&#39;,\n    menu_url: &#39;order.refundmanagement&#39;,\n    parent_id: &#39;2&#39;\n   &#125;\n ]</code></pre>\n\n<p>思路是先使用 <code>tmp</code> 将数组中的元素处理成 <code>id: &#123;id...menu_name...menu_url...parent_id&#125;</code> 类的格式，然后针对该数据处理成树状结构。</p>\n<p>实现代码如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const buildTree &#x3D; (arr) &#x3D;&gt; &#123;\n    tmp &#x3D; &#123;&#125;;\n    res &#x3D; &#123;&#125;;\n    for (let i in arr) &#123;\n        tmp[arr[i].id] &#x3D; arr[i];\n    &#125;\n\n    for (let i in tmp) &#123;\n        if (tmp[i].parent_id) &#123; &#x2F;&#x2F; 如果节点没有父节点，即该节点为根节点\n            if (!tmp[tmp[i].parent_id].children) &#123; &#x2F;&#x2F; 该节点的父节点和该节点没有形成关系\n                tmp[tmp[i].parent_id].children &#x3D; new Object();\n            &#125;\n            tmp[tmp[i].parent_id].children[tmp[i].id] &#x3D; tmp[i];\n        &#125; else &#123;\n            res[tmp[i].id] &#x3D; tmp[i];\n        &#125;\n    &#125;\n    return res;\n&#125;\n\nconsole.log(buildTree(menu_list)); &#x2F;&#x2F;测试代码，menu_list 为前面的数据。</code></pre>\n\n<p>据说这个代码可以使用数组的方法 <code>Array.prototype.find()</code> 来美化代码。如何实现呢？其实我也没太想好😂欢迎讨论。</p>\n<p><strong>5. 数组扁平化</strong></p>\n<p><strong>解法一：递归</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var arr &#x3D; [1, [2, [3, 4]]];\n\nfunction flatten(arr) &#123;\n    var result &#x3D; [];\n    for (var i &#x3D; 0, len &#x3D; arr.length; i &lt; len; i++) &#123;\n        if (Array.isArray(arr[i])) &#123;\n            result &#x3D; result.concat(flatten(arr[i]))\n        &#125;\n        else &#123;\n            result.push(arr[i])\n        &#125;\n    &#125;\n    return result;\n&#125;\n\n\nconsole.log(flatten(arr))</code></pre>\n\n<p><strong>解法二：es6 拓展运算符</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var arr &#x3D; [1, [2, [3, 4]]];\n\nfunction flatten(arr) &#123;\n\n    while (arr.some(item &#x3D;&gt; Array.isArray(item))) &#123;\n        arr &#x3D; [].concat(...arr);\n    &#125;\n    return arr;\n&#125;\n\nconsole.log(flatten(arr))</code></pre>\n\n<p><strong>原地解法：这是一次面试中，面试官看完递归解法之后，问我有没有原地解法。这也是感到迷惑的地方，目前猜测可能是想考察 flat 的用法。欢迎讨论。</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const arr1 &#x3D; [0, 1, 2, [[[3, 4]]]];\n\nconsole.log(arr1.flat(3)); &#x2F;&#x2F; 3 代表数组内最多嵌套层数\n&#x2F;&#x2F; expected output: [0, 1, 2, 3, 4]</code></pre>\n\n<p><strong>6. 模拟 lodash 中的 _.get() 函数</strong></p>\n<ul>\n<li>JavaScript</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * --- 题目描述 ---\n *\n * 补充函数的 TODO 部分，模拟 lodash 中的 _.get() 函数。\n *\n * --- 测试用例 ---\n *\n * 输入：\n * const obj &#x3D; &#123; selector: &#123; to: &#123; toutiao: &quot;FE Coder&quot;&#125; &#125;, target: [1, 2, &#123; name: &#39;byted&#39;&#125;]&#125;;\n * get(obj, &#39;selector.to.toutiao&#39;, &#39;target[0]&#39;, &#39;target[2].name&#39;)\n * 输出：\n * [&#39;FE coder&#39;, 1, &#39;byted&#39;]\n *&#x2F;\n\nfunction get(object, ...path) &#123;\n    return path.map((item) &#x3D;&gt; &#123;\n        item.replace(&#x2F;\\[&#x2F;g, &quot;.&quot;)\n            .replace(&#x2F;\\]&#x2F;g, &quot;&quot;)\n            .split(&#39;.&#39;)\n            .map(path &#x3D;&gt; object &#x3D; object &amp;&amp; object[path]);\n        return object;\n    &#125;)\n&#125;</code></pre>\n\n<h2 id=\"原理类\"><a href=\"#原理类\" class=\"headerlink\" title=\"原理类\"></a><a href=\"#%E5%8E%9F%E7%90%86%E7%B1%BB\"></a>原理类</h2><p><strong>1. 深拷贝</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; deepClone\nfunction deepClone(obj &#x3D; &#123;&#125;) &#123;\n    if (typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; obj 是 null 或者不是对象和数组，直接返回\n        return obj;\n    &#125;\n    let res;\n    if (obj instanceof Array) &#123;\n        res &#x3D; [];\n    &#125; else &#123;\n        res &#x3D; &#123;&#125;;\n    &#125;\n\n    for (let key in obj) &#123;\n        &#x2F;&#x2F; 判断自身中是否包含自身属性\n        if (obj.hasOwnProperty(key)) &#123;\n            res[key] &#x3D; deepClone(obj[key])\n        &#125;\n    &#125;\n    return res;\n&#125;\n&#x2F;&#x2F; 验证\no &#x3D; &#123;a: 1, d: &#123;c: &#39;4&#39;&#125;&#125;;\nres &#x3D; deepClone(o);\nconsole.log(res);\nconsole.log(res &#x3D;&#x3D; o);</code></pre>\n\n<p><strong>2. 浅拷贝</strong></p>\n<p>代码出处：<a href=\"https://leetcode-cn.com/link/?target=https://dmitripavlutin.com/javascript-shallow-clone-objects/\">https://dmitripavlutin.com/javascript-shallow-clone-objects/</a></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 首先定义一个对象\nconst hero &#x3D; &#123;\n  name: &#39;Batman&#39;,\n  city: &#39;Gotham&#39;\n&#125;;\n&#x2F;&#x2F; **********************方法一**********************\nconst heroEnhancedClone &#x3D; &#123;\n  ...hero,\n  name: &#39;Batman Clone&#39;,\n  realName: &#39;Bruce Wayne&#39;\n&#125;;\n\n&#x2F;&#x2F; 验证\nheroEnhancedClone;  &#x2F;&#x2F; &#123; name: &#39;Batman Clone&#39;, city: &#39;Gotham&#39;, realName: &#39;Bruce Wayne&#39; &#125;\n\n&#x2F;&#x2F; **********************方法二**********************\nconst &#123; ...heroClone &#125; &#x3D; hero;\n\n&#x2F;&#x2F; 验证\nheroClone; &#x2F;&#x2F; &#123; name: &#39;Batman&#39;, city: &#39;Gotham&#39; &#125;\nhero &#x3D;&#x3D;&#x3D; heroClone; &#x2F;&#x2F; &#x3D;&gt; false\n\n&#x2F;&#x2F; **********************方法三**********************\nconst hero &#x3D; &#123;\n  name: &#39;Batman&#39;,\n  city: &#39;Gotham&#39;\n&#125;;\n\n&#x2F;&#x2F; 验证\nconst heroClone &#x3D; Object.assign(&#123;&#125;, hero);\nheroClone; &#x2F;&#x2F; &#123; name: &#39;Batman&#39;, city: &#39;Gotham&#39; &#125;\nhero &#x3D;&#x3D;&#x3D; heroClone; &#x2F;&#x2F; &#x3D;&gt; false</code></pre>\n\n<p><strong>3. 手写 bind 函数</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 模拟 bind\nFunction.prototype.bind1 &#x3D; function() &#123;\n    &#x2F;&#x2F; 将参数拆解为数组\n    const args &#x3D; Array.prototype.slice.call(arguments) &#x2F;&#x2F; 变成数组\n    \n    &#x2F;&#x2F; 获取 this（数组第一项）\n    const t &#x3D; args.shift()\n    \n    &#x2F;&#x2F; fn1.bind(...) 中的 fn1\n    const self &#x3D; this\n    \n    &#x2F;&#x2F; 返回一个函数\n    return function() &#123;\n        return self.apply(t, args)\n    &#125;\n&#125;\nfunction fn1(a, b, c)&#123;\n    console.log(&#39;this&#39;, this)\n    console.log(a, b, c)\n    return &#39;this is fn1&#39;\n&#125;\nconst fn2 &#x3D; fn1.bind1(&#123;x: 100&#125;, 10, 20, 30)\nconst res &#x3D; fn2()\nconsole.log(res)</code></pre>\n\n<p><strong>4. 手写 new</strong></p>\n<p><strong>答案</strong></p>\n<ul>\n<li>JavaScript</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function funcNew(obj, ...args) &#123;\n    const newObj &#x3D; Object.create(obj.prototype);\n    const result &#x3D; obj.apply(newObj, args);\n    return (typeof result &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; result !&#x3D;&#x3D; null) ? result : newObj;\n&#125;</code></pre>\n\n<p><strong>解读</strong></p>\n<p>先通过一个例子来理解 <code>new</code> 的作用吧：</p>\n<ul>\n<li>JavaScript</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function Person(name) &#123;\n    this.name &#x3D; name;\n&#125;\n\nPerson.prototype.sayName &#x3D; function() &#123;\n    console.log(this.name);\n&#125; \n\nconst p &#x3D; new Person(&#39;orange&#39;)\nconsole.log(p.name) &#x2F;&#x2F; &#39;orange&#39;\np.sayName(); &#x2F;&#x2F; &#39;orange&#39;</code></pre>\n\n<p>代码中我们新建了一个对象 <code>Person</code>，它具有属性 <code>name</code>，且在 <code>Person.prototype</code> 上定义了函数 <code>sayName</code>。</p>\n<p>当我们通过 <code>new</code> 创建一个新的实例 <code>p</code> 时，便同时具有了属性 <code>p.name</code> 和 <code>p.sayName()</code>，关系如下图：</p>\n<p><img src=\"https://pic.leetcode-cn.com/1605358555-uUuIYq-1.png\"></p>\n<p>知道了原理，就可以自己实现了。也就是说，自己写一个函数 <code>funcNew()</code>，使得 <code>const p = new Person(&#39;orange&#39;)</code> 和 <code>const p = funcNew(&#39;orange&#39;)</code> 得到的 <code>p</code> 完全相同，于是得到了答案中的代码。</p>\n<p><strong>答案中最后一行代码如何理解？</strong></p>\n<p>前面的例子我们只考虑了 <code>Person</code> 中没有返回值的情况，如有有返回值，<code>new</code> 一个实例将会受到 <code>Person</code> 中返回值的影响。比如说：</p>\n<ul>\n<li>JavaScript</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;**\n * --- Person 中 return 一个对象，p 为该对象 ---\n *&#x2F;\n\nfunction Person(name) &#123;\n    this.name &#x3D; name;\n    return &#123;age: 35&#125;\n&#125;\n\nPerson.prototype.sayName &#x3D; function() &#123;\n    console.log(this.name);\n&#125; \n\nconst p &#x3D; new Person(&#39;orange&#39;)\nconsole.log(p) &#x2F;&#x2F; &#123; age: 35 &#125;\nconsole.log(p.name) &#x2F;&#x2F; undefined\np.sayName(); &#x2F;&#x2F; TypeError: p.sayName is not a function\n\n&#x2F;**\n * --- Person 返回非对象，return 不影响结果 ---\n *&#x2F;\n\nfunction Person(name) &#123;\n    this.name &#x3D; name;\n    return &#39;free&#39;\n&#125;\n\nPerson.prototype.sayName &#x3D; function() &#123;\n    console.log(this.name);\n&#125; \n\nconst p &#x3D; new Person(&#39;orange&#39;)\nconsole.log(p) &#x2F;&#x2F; Person &#123; name: &#39;orange&#39; &#125;\nconsole.log(p.name) &#x2F;&#x2F; orange\np.sayName(); &#x2F;&#x2F; orange</code></pre>\n\n<p>上面的例子中，如果返回了一个对象，我们需要返回该对象；如果不是对象，则 <code>return</code> 没用，正常处理。</p>\n<hr>\n<p><strong>5. 如何自己实现一个 <code>instanceof</code>？</strong></p>\n<p><strong>答案</strong></p>\n<ul>\n<li>JavaScript</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;*\n * --- 手动实现 instanceof ---\n *&#x2F;\n\nfunction newInstanceOf (leftValue, rightValue) &#123;\n    if (typeof leftValue !&#x3D;&#x3D; &#39;object&#39; || rightValue &#x3D;&#x3D; null) &#123; \n        return false;\n    &#125;\n    \n    let rightProto &#x3D; rightValue.prototype;\n    leftValue &#x3D; leftValue.__proto__;\n    \n    while (true) &#123;\n        if (leftValue &#x3D;&#x3D;&#x3D; null) return false;\n        if (leftValue &#x3D;&#x3D;&#x3D; rightProto) return true;\n        leftValue &#x3D; leftValue.__proto__;\n    &#125;\n&#125;\n\n&#x2F;*\n * --- 验证 ---\n *&#x2F;\n\nconst a &#x3D; [];\nconst b &#x3D; &#123;&#125;;\n\nfunction Foo () &#123;&#125;\n\nvar c &#x3D; new Foo()\nfunction Child () &#123;&#125;\nfunction Father() &#123;&#125;\nChild.prototype &#x3D; new Father()\nvar d &#x3D; new Child()\n\nconsole.log(newInstanceOf(a, Array)) &#x2F;&#x2F; true\nconsole.log(newInstanceOf(b, Object)) &#x2F;&#x2F; true\nconsole.log(newInstanceOf(b, Array)) &#x2F;&#x2F; false\nconsole.log(newInstanceOf(a, Object)) &#x2F;&#x2F; true\nconsole.log(newInstanceOf(c, Foo)) &#x2F;&#x2F; true\nconsole.log(newInstanceOf(d, Child)) &#x2F;&#x2F; true\nconsole.log(newInstanceOf(d, Father)) &#x2F;&#x2F; true\nconsole.log(newInstanceOf(123, Object)) &#x2F;&#x2F; false \nconsole.log(123 instanceof Object) &#x2F;&#x2F; false</code></pre>\n\n<p><strong>解读</strong></p>\n<p>这个问题既考察了 <code>instanceof</code> 的原理，又考察了原型链，还考察了代码能力，是一个好问题。</p>\n<p>在实现代码中，我们判断 <code>leftValue</code> 是否为 <code>rightValue</code> 的实例，思想是在 <code>leftValue</code> 的原型链上，即 <code>leftValue.__proto__</code> 上寻找是否存在 <code>rightValue.prototype</code>。原理图如下：</p>\n<p>![](<a href=\"https://pic.leetcode-cn.com/1605406941-RYnUaG-Untitled\">https://pic.leetcode-cn.com/1605406941-RYnUaG-Untitled</a> Diagram.png)</p>\n<p>这需要我们熟练掌握原型链的相关知识。</p>\n<p><strong>6. 实现 <code>Promise.all()</code></strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>引用 MDN: <code>Promise.all(iterable)</code> 方法返回一个 <code>Promise</code> 实例，此实例在 <code>iterable</code> 参数内所有的 <code>promise</code> 都 “完成（resolved）” 或参数中不包含 <code>promise</code> 时回调完成（resolve）；如果参数中 <code>promise</code> 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 <code>promise</code> 的结果。</p></blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function promiseAll(promises) &#123;\n  return new Promise(function(resolve, reject) &#123;\n    if (!isArray(promises)) &#123;\n      return reject(new TypeError(&#39;arguments must be an array&#39;));\n    &#125;\n    var resolvedCounter &#x3D; 0;\n    var promiseNum &#x3D; promises.length;\n    var resolvedValues &#x3D; new Array(promiseNum);\n    for (var i &#x3D; 0; i &lt; promiseNum; i++) &#123;\n        (function(i) &#123;\n            Promise.resolve(promises[i]).then(function(value) &#123;\n            resolvedCounter++\n            resolvedValues[i] &#x3D; value\n            if (resolvedCounter &#x3D;&#x3D; promiseNum) &#123;\n                return resolve(resolvedValues)\n            &#125;\n            &#125;, function(reason) &#123;\n            return reject(reason)\n            &#125;)\n        &#125;)(i)\n    &#125;\n  &#125;)\n&#125;</code></pre>\n\n<p><a href=\"https://leetcode-cn.com/link/?target=https://segmentfault.com/a/1190000010765655\">此代码出自 segmentfault</a></p>\n<h2 id=\"应用类\"><a href=\"#应用类\" class=\"headerlink\" title=\"应用类\"></a><a href=\"#%E5%BA%94%E7%94%A8%E7%B1%BB\"></a>应用类</h2><p><strong>1. 手写防抖（debounce）</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; debounce\nfunction debounce(fn, delay&#x3D;500) &#123;\n    &#x2F;&#x2F; timer 写在闭包中，因此防抖也是闭包的一个应用\n    let timer &#x3D; null;\n\n    return function() &#123;\n        if (timer) &#123;\n            clearTimeout(timer)\n        &#125;\n        timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n            fn.apply(this, arguments);\n            timer &#x3D; null;\n        &#125;, delay)\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 验证\ninput1.addEventListener(&#39;keyup&#39;, debounce(() &#x3D;&gt; &#123;\n    console.log(input1.value);\n&#125;), 600)</code></pre>\n\n<p><strong>2. 手写节流（throttle）</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 节流\nfunction throttle(fn, delay &#x3D; 100) &#123;\n    let timer &#x3D; null\n\n    return function() &#123;\n        if (timer) &#123;\n            return\n        &#125;\n        timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n            fn.apply(this, arguments)\n            timer &#x3D; null\n        &#125;, delay)\n    &#125;\n&#125;\n\ndiv1.addEventListener((&#39;drag&#39;, throttle(function (e) &#123;\n    console.log(e.offsetX, e.offsetY)\n&#125;)))</code></pre>\n\n<p><strong>3. DOM 题目</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>假设一个 <code>ul</code> 下有一万个 <code>li</code>，<code>li</code> 的 <code>innerHTML</code> 是从 <code>0</code> 到 <code>9999</code>，当点击某个 <code>li</code> 时输出该 <code>li</code> 代表的值，如何实现</p></blockquote>\n<p><strong>答案</strong></p>\n<p>采用事件委托：</p>\n<ul>\n<li>JavaScript</li>\n<li>HTML</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">window.onload &#x3D; function () &#123;\n    var uli &#x3D; document.getElementById(&quot;ul&quot;);\n    uli.onclick &#x3D; function(event) &#123;\n        alert(event.target.innerText);\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;ul id&#x3D;&quot;ul&quot;&gt;\n    &lt;li&gt;0&lt;&#x2F;li&gt;\n    &lt;li&gt;1&lt;&#x2F;li&gt;\n    &lt;li&gt;2&lt;&#x2F;li&gt;\n    ...\n    &lt;li&gt;9999&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;</code></pre>\n\n<p><strong>解读</strong></p>\n<p>首先，我们当然不可能为每一个 <code>li</code> 标签手动添加一个 <code>click</code> 事件（容易累死）；其次，我们可能会想到使用 <code>for</code> 循环遍历每个元素，然后为其添加 <code>click</code> 事件，但这样会频繁操作 DOM，降低性能，卡到爆炸。</p>\n<p>而事件委托意义就在于此：<strong>减少 DOM 操作，从而减少浏览器的重绘与重排次数，提升性能。</strong></p>\n<p>事件委托的原理是，将 <code>li</code> 上监听的 <code>click</code> 事件委托到 <code>ul</code> 上。这里运用到了 <a href=\"https://leetcode-cn.com/link/?target=https://juejin.im/post/6844903834075021326\">事件冒泡</a> 的机制，即 <code>onclick</code> 事件以 <code>li -&gt; ul -&gt; body -&gt; html -&gt; document</code> 的冒泡顺序逐步传递。</p>\n<p>所以，我们可以选择在其中的 <code>ul</code> 上监听 <code>click</code> 事件，从而实现事件委托。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如何创建 100000 个 <code>&lt;li&gt;</code> 呢？总不能复制粘贴 100000 次吧？</p></blockquote>\n<p>创建 100000 个 <code>&lt;li&gt;</code> 标签，思路是将 0∼9999 保存在数组中，然后转化为字符串 <code>&quot;&lt;li&gt;0&lt;/li&gt;&lt;li&gt;1&lt;/li&gt;...&lt;li&gt;9999&lt;/li&gt;&quot;</code>，最后将他们作为 <code>ul</code> 标签的 <code>innerHTML</code> 即可。</p>\n<ul>\n<li>JavaScript</li>\n<li>HTML</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;* --- create100000li.js --- *&#x2F;\n\nwindow.onload &#x3D; function() &#123;\n    var ul &#x3D; document.getElementsByTagName(&quot;ul&quot;);\n    var arr &#x3D; [];\n    for (let i &#x3D; 0; i &lt; 100000; i++) &#123;\n        arr.push(i);\n    &#125;\n    ul[0].innerHTML &#x3D; &#39;&lt;li&gt;&#39; + arr.join(&#39;&lt;&#x2F;li&gt;&lt;li&gt;&#39;) + &#39;&lt;&#x2F;li&gt;&#39;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;!-- index.html --&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;script src&#x3D;&quot;create100000li.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;body&gt;\n&lt;ul&gt;\n&lt;&#x2F;ul&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<p><a href=\"https://leetcode-cn.com/link/?target=https://github.com/z1ming/AKJS/tree/master/create100000Nodes\">源代码实现</a></p>\n<p><strong>4. 手写 Promise 加载一张图片</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function loadImg(src) &#123;\n    const p &#x3D;  new Promise(\n        (resolve, reject) &#x3D;&gt; &#123;\n            const img &#x3D; document.createElement(&#39;img&#39;)\n            img.onload &#x3D; () &#x3D;&gt; &#123;\n                resolve(img)\n            &#125;\n            img.onerror &#x3D; () &#x3D;&gt; &#123;\n                const err &#x3D; new Error(&#96;图片加载失败 $&#123;src&#125;&#96;)\n                reject(err)\n            &#125;\n            img.src &#x3D; src\n        &#125;\n    )\n    return p\n&#125;\n\nconst url &#x3D; &#39;https:&#x2F;&#x2F;pic.leetcode-cn.com&#x2F;1604237471-xbJgZl-%E5%9B%BE%E7%89%871.png&#39;;\nloadImg(url).then(img &#x3D;&gt; &#123;\n    console.log(img.width)\n    return img\n&#125;).then(img &#x3D;&gt; &#123;\n    console.log(img.height)\n&#125;).catch(ex &#x3D;&gt; console.error(ex))</code></pre>\n\n<p><strong>5. 如何用 ajax 原生实现一个 <code>post</code> 请求</strong></p>\n<p><strong>答案</strong></p>\n<ul>\n<li>JavaScript</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function ajax_post(url, data) &#123;\n    &#x2F;&#x2F; 1. 异步对象 ajax\n    var ajax &#x3D; new XMLHttpRequest();\n    \n    &#x2F;&#x2F; 2. url 方法\n    ajax.open(&#39;post&#39;, url);\n    \n    &#x2F;&#x2F; 3. 设置请求报文\n    ajax.setRequestHeader(&#39;Content-type&#39;, &#39;text&#x2F;plain&#39;);\n    \n    &#x2F;&#x2F; 4. 发送\n    if (data) &#123;\n        ajax.send(data);\n    &#125; else &#123;\n        ajax.send();\n    &#125;\n    \n    &#x2F;&#x2F; 5. 注册事件\n    ajax.onreadystatechange &#x3D; function () &#123;\n        if (ajax.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; ajax.status &#x3D;&#x3D;&#x3D; 200) &#123;\n            console.log(ajax.respenseText);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>6. 每隔一秒输出一个数字</strong></p>\n<ul>\n<li>使用 let(推荐)</li>\n<li>使用闭包</li>\n<li>使用第三个参数</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for (let i &#x3D; 0; i &lt; 10; i++) &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n        console.log(i);\n    &#125;, 1000 * i)\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for (var i &#x3D; 0; i &lt; 10; i++) &#123;\n    (function(j) &#123;\n        setTimeout(() &#x3D;&gt; &#123;\n            console.log(j);\n        &#125;, 1000 * j)\n    &#125;)(i)\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for(var i &#x3D; 0; i &lt;&#x3D; 5; i++)&#123;           \n    setTimeout((j) &#x3D;&gt; &#123;                \n        console.log(j);            \n    &#125;,i * 1000, i)        \n&#125;</code></pre>\n\n<p><strong>7. 判断两个对象是否相等</strong></p>\n<ul>\n<li>调库</li>\n<li>实现</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;*\n * @param x &#123;Object&#125; 对象1\n * @param y &#123;Object&#125; 对象2\n * @return  &#123;Boolean&#125; true 为相等，false 为不等\n *&#x2F;\n\nconsole.log(_.isEqual(x, y))</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;*\n * @param x &#123;Object&#125; 对象1\n * @param y &#123;Object&#125; 对象2\n * @return  &#123;Boolean&#125; true 为相等，false 为不等\n *&#x2F;\n\nconst deepEqual &#x3D; function(x, y) &#123;\n    &#x2F;&#x2F; 指向同一内存时\n    if (x &#x3D;&#x3D;&#x3D; y) &#123;\n        return true;\n    &#125; else if ((typeof x &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; x !&#x3D; null) &amp;&amp; (typeof y &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; y !&#x3D; null)) &#123;\n        if (Object.keys(x).length !&#x3D; Object.keys(y).length) &#123;\n            return false;\n        &#125;\n        for (let prop in x) &#123;\n            if (y.hasOwnProperty(prop)) &#123;\n                if (!deepEqual(x[prop], y[prop])) &#123;\n                    return false;\n                &#125;\n            &#125; else &#123;\n                return false;\n            &#125;\n        &#125; \n        return true;\n    &#125; \n    return false;\n&#125;</code></pre>\n\n<p>实现代码中，以下边界情况无法处理：</p>\n<ul>\n<li>其中某个属性本身是一个对象</li>\n<li>某个属性的值为 <code>NaN</code></li>\n<li>一个对象的属性的值为 <code>undefined</code>，另一个对象中没有这个属性</li>\n</ul>\n<p>对于所有边界情况的处理，请参考 Lodash 中的 <a href=\"https://leetcode-cn.com/link/?target=https://github.com/lessfish/underscore-analysis/blob/master/underscore-1.8.3.js/src/underscore-1.8.3.js#L1094-L1190\">_.isEqual( ) 源码</a></p>\n","feature":false,"text":" 前端面试中，手撕代码环节除了力扣上的算法题目之外，还有一些针对前端知识点的题目，大致有以下几类： 算法类 原理类 应用类 算法类 1. 手写快排、冒泡、选择排序 2. URL 拆解问题 3. 将 HTTP header 转换成 js 对象 注意到 这样的输入格式叫做 模板字符串...","link":"","photos":[],"count_time":{"symbolsCount":"23k","symbolsTime":"21 mins."},"categories":[{"name":"Frontend","slug":"Frontend","count":2,"path":"api/categories/Frontend.json"}],"tags":[{"name":"面经","slug":"面经","count":2,"path":"api/tags/面经.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E7%B1%BB\"><span class=\"toc-text\">算法类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86%E7%B1%BB\"><span class=\"toc-text\">原理类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E7%B1%BB\"><span class=\"toc-text\">应用类</span></a></li></ol>","author":{"name":"析构理想","slug":"blog-author","avatar":"https://s1.ax1x.com/2020/07/04/NxaLkV.jpg","link":"/","description":"在这个世界上，最让人畏惧的恰恰是通向自己的道路 <br /> @ <b>公众号：析构理想</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"Github":{"icon":"/svg/github.svg","link":"https://github.com/idealdestructor"},"Twitter":{"icon":"/svg/twitter.svg","link":"https://twitter.com/idealdestructor"},"Instgram":{"icon":"/svg/instagram.svg","link":"https://instagram.com/idealdestructor"},"Weibo":{"icon":"/svg/weibo.svg","link":"https://weibo.com/6019347563/profile"},"Zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/idealdestructor"},"Bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/305094533?spm_id_from=333.1007.0.0"}}}},"mapped":true,"prev_post":{"title":"Leetcode题解","uid":"90f2417d388e3c74c0ba506e56fcf375","slug":"Leetcode笔记","date":"2022-01-04T03:02:15.000Z","updated":"2022-03-16T04:04:26.584Z","comments":true,"path":"api/articles/Leetcode笔记.json","keywords":null,"cover":"https://source.unsplash.com/pOwKTIgjKjU/1200x628","text":"数组二分查找704.二分查找class Solution &#123; public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left &#x3D; 0; int right &#x3D; n...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":1,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"Leetcode","slug":"Leetcode","count":1,"path":"api/tags/Leetcode.json"}],"author":{"name":"析构理想","slug":"blog-author","avatar":"https://s1.ax1x.com/2020/07/04/NxaLkV.jpg","link":"/","description":"在这个世界上，最让人畏惧的恰恰是通向自己的道路 <br /> @ <b>公众号：析构理想</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"Github":{"icon":"/svg/github.svg","link":"https://github.com/idealdestructor"},"Twitter":{"icon":"/svg/twitter.svg","link":"https://twitter.com/idealdestructor"},"Instgram":{"icon":"/svg/instagram.svg","link":"https://instagram.com/idealdestructor"},"Weibo":{"icon":"/svg/weibo.svg","link":"https://weibo.com/6019347563/profile"},"Zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/idealdestructor"},"Bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/305094533?spm_id_from=333.1007.0.0"}}}},"feature":true},"next_post":{"title":"前端面经总结","uid":"329c2025145e0b6d6215dadb590fe2d6","slug":"前端面试复习计划","date":"2022-01-04T03:02:15.000Z","updated":"2022-03-15T12:21:04.056Z","comments":true,"path":"api/articles/前端面试复习计划.json","keywords":null,"cover":"https://source.unsplash.com/VivsxaizzVE/1200x628","text":"一、简历 简历在找工作过程中是非常非常重要的，无论你是什么途径去面试的，面试你的人一定会看你的简历。 推荐阅读：如何写「前端简历」，能敲开字节跳动的大门？一份优秀的前端开发工程师简历是怎么样的？ 1、重点 简历就像高考作文——阅卷时间非常短。 内容要简洁。 直击重点，表现出自己的...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"36 mins."},"categories":[{"name":"Frontend","slug":"Frontend","count":2,"path":"api/categories/Frontend.json"}],"tags":[{"name":"面经","slug":"面经","count":2,"path":"api/tags/面经.json"}],"author":{"name":"析构理想","slug":"blog-author","avatar":"https://s1.ax1x.com/2020/07/04/NxaLkV.jpg","link":"/","description":"在这个世界上，最让人畏惧的恰恰是通向自己的道路 <br /> @ <b>公众号：析构理想</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"Github":{"icon":"/svg/github.svg","link":"https://github.com/idealdestructor"},"Twitter":{"icon":"/svg/twitter.svg","link":"https://twitter.com/idealdestructor"},"Instgram":{"icon":"/svg/instagram.svg","link":"https://instagram.com/idealdestructor"},"Weibo":{"icon":"/svg/weibo.svg","link":"https://weibo.com/6019347563/profile"},"Zhihu":{"icon":"/svg/zhihu.svg","link":"https://www.zhihu.com/people/idealdestructor"},"Bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/305094533?spm_id_from=333.1007.0.0"}}}},"feature":false}}