[{"id":"79671d59bc212050ac45afc78a9bbb6a","title":"《深度学习推荐系统》读书笔记","content":"第一章：互联网的增长引擎 - 推荐系统首先是引入推荐系统，介绍其在互联网中的地位和作用，以及推荐系统的主要架构。作者将推荐系统的架构分为两部分：数据部分和模型部分。数据部分即离线大数据平台，实时 &#x2F; 准实时的流处理平台。模型部分则包含召回、排序、补充策略、离线评估、线上 A&#x2F;B test 等。\n第二章：推荐系统的进化之路这一章主要是传统推荐模型（机器学习类）的发展与演化。\n\n传统推荐模型的发展主要经历了四个阶段：\n\n协同过滤 CF 算法阶段：只需用户物品共现矩阵就可以构建推荐系统，根据相似度取值对象可分为 itemCF 和 userCF 两类，优势是简单易实现。CF 的问题是泛化能力弱，无法应对稀疏矩阵，而矩阵分解作为协同过滤的进化版，克服了 CF 的缺点。\n逻辑回归 LR 阶段：综合利用用户、物品、上下文等多种不同的特征，假设用户是否点击广告服从伯努利分布，将推荐问题转化为点击率预估 (CTR) 问题，预测正样本概率对物品进行排序。其数学形式是各个特征的加权和经过 sigmoid 函数，得到用户点击物品的概率。LR 的优势是可解释性强、易于并行化、模型简单、训练开销小。其局限性在于表达能力不强，需要大量具有业务背景知识的人工特征筛选与交叉。\n因子分解机 FM 阶段：为每个特征学习一个隐向量，在特征交叉时，使用两个特征隐向量的内积作为交叉特征的权重。虽然 FM 相比 POLY2 的完全交叉 + 单一权重记忆能力略弱，但解决了特征交叉过程中交叉特征对应的数据过于稀疏无法充分学习权重的问题。FFM 引入特征域进一步增强了模型的表达能力，做特征交叉时，每个特征选择与对方域对应的隐向量的内积作为交叉特征的权重，但 FFM 的计算复杂度也由 kn 上升到 kn*n。\n组合模型阶段：这一阶段主要是为了进一步提高特征交叉的维度，同时融合多个模型的优点。GBDT+LR 是组合模型的代表方案，GBDT 自动进行特征筛选和组合得到新的离散特征向量输入 LR 模型。GBDT+LR 的组合方式开启了特征工程模型化的趋势，真正实现端到端训练。\n\n这一章的最后作者单独介绍了阿里巴巴曾经的主流推荐模型：大规模分段线性模型 (LS-PLM)，又称为 MLR(Mixed Logistic Regression，混合逻辑回归)。该模型从淘宝的业务特性出发，对不同用户群体、不同使用场景下的样本单独进行 CTR 预估。具体方法是先对全量样本聚类，再对每个分类里的样本使用 LR 进行 CTR 预估。\nLS-PLM 模型的一大优势是端到端的非线性学习能力，样本聚类的方式能够让模型学习出数据中蕴藏的非线性模式，这里个人理解是 LS-PLM 模型的非线性学习能力强度还依赖于根据自身业务特性调节的超参 “分片数”。LS-PLM 因建模时引入了 L1 和 L2 范数，其中 L1 范数使得模型具有较高的稀疏度，这样一来，模型服务过程仅需使用非零权重，在线推断的效率很高。\n作者认为 LS-PLM 在推荐系统模型发展的历史中起到了承上启下的作用。LS-PLM 可以看做一个加入了注意力机制的三层神经网络模型，其中输入层是样本的特征向量，中间层是 m 个神经元组成的隐层，其中 m 是分片的个数，最后一层是单一神经元组成的输出层。其中注意力机制应用在隐层和输出层之间，神经元之间的权重是由分片函数输出的概率值即注意力得分确定的。\n第三章 深度学习在推荐系统中的应用推荐系统模型经过了机器学习阶段充分的发展后，终于进入了深度学习时代。与传统机器学习模型相比，深度学习模型具有表达能力更强，模型结构更灵活更贴合业务场景的优点。下图为深度学习阶段主流推荐模型的演化图谱：\n\n正如图谱所示，深度学习阶段的推荐模型从多层感知机 MLP 出发，通过改变神经网络的结构，演变为各种各样的深度学习推荐模型。总结起来，有七个演变方向：\n\n改变神经网络的复杂程度：增加深度神经网络的层数和结构复杂度。\n丰富特征交叉方式：改变特征向量的交叉方式，如 NeuralCF，PNN(Product-based Neural Network)。\n组合模型：组合两种不同特点、优势互补的网络，主要是指 Wide&amp;Deep 及其后续各种改进模型如 Deep&amp;Cross、DeepFM 等。\nFM 模型的深度学习演化：对 FM 模型的各种改进，包括 NFM(Neural Factorization Machine) 使用神经网络提升 FM 二阶交叉部分的特征交叉能力、FNN(Factorization-machine supported Neural Network) 利用 FM 的结果进行网络初始化、AFM(Attention neural Factorization Machine) 在 FM 中引入注意力机制。\n引入注意力机制：主要包括上述的 AFM 和 DIN(Deep Interest Network， 深度兴趣网络) 模型\n融合序列模型：使用序列模型模拟用户行为或用户兴趣的演化趋势，如 DIEN(Deep Interest Evolution Network，深度兴趣进化网络)\n结合强化学习：主要是为了模型的在线学习和实时更新，包括 DRN(Deep Reinforcement Learning Network, 深度强化学习网络)\n\n首先直接在 DNN 上演变的模型有：\n\nAutoRec：将自编码器 (AutoEncoder) 与协同过滤结合的单隐层神经网络模型，利用协同过滤中的共现矩阵，完成物品 &#x2F; 用户向量的自编码，基于自编码的结果得到用户对物品的预估评分，进而排序。AutoRec 模型结构和 word2vec 结构一致，相对简单，但优化目标和训练方法有所不同，AutoRec 表达能力有限。\nDeep Crossing：由微软于 2016 年发布，用于其搜索引擎 Bing 中的搜索广告推荐场景。Deep Crossing 完善了深度学习在推荐领域的实际应用流程，提出了一套完整的从特征工程、稀疏向量稠密化、多层神经网络进行优化目标拟合的解决方案，开启了无需任何人工特征工程的时代。其模型结构如下：\n\n\n\nNeuralCF：2017 年的 NCF 用 “多层神经网络 + 输出层” 的结构替代了矩阵分解中的简单内积操作，让用户 &#x2F; 物品向量做更充分的交叉，引入更多的非线性特征，增强模型表达能力。作者还提出一种 “广义矩阵分解”(Generalized Matrix Factorization) 模型融合了简单内积操作与多层神经网络两种特征交叉方式。NCF 模型同协同过滤一样只利用了用户物品的共现矩阵，并没有融合其他特征信息。模型结构如下图：\n\n\n\nPNN：2016 年的 PNN 模型在 Deep&amp;Crossing 的基础上使用乘积层 (Product Layer) 代替 Stacking 层。即不同特征的 Embedding 向量不再是简单的拼接，而是通过 Product 操作两两交互。这里的 Product 操作包含两种：内积操作和外积操作。PNN 模型如下图所示：\n\n\n如上图所示，  , 其中乘积层由两部分组成，z 来自于输入 Embedding 的线性变换，p 来自于上述 Product 操作的结果，这里 Product 如果选择的是内积，则称为 IPNN，若是外积，则称 OPNN。经过反复比对，书中关于这一点的描述和论文是有出入的，这里以论文为准。PNN 的出发点是丰富特征交叉方式，增强模型表达能力，而实际落地时，关于 OPNN 还是 IPNN 的选择以及各自对应的效率优化是需要根据业务场景权衡的。\n\nWide&amp;Deep：Google 于 2016 年提出 Wide&amp;Deep 模型，模型使用单输入层的 Wide 部分处理大量稀疏的 id 特征，提升记忆能力；使用 Embedding 和多隐层的 Deep 部分处理全量特征，赋予模型泛化能力。Wide 部分的输入特征除了原始的 id 特征（已安装应用和曝光应用）外，还包括转换后的特征，如叉乘变换 (Cross Product Transformation)，其实就是将单独的特征转换为组合特征，给模型增加非线性能力。\n\n\n\nDeep&amp;Cross：斯坦福和 Google 合作基于 Wide&amp;Deep 的改进。主要思路是使用 Cross 网络替代 Wide 部分，目的是通过多层交叉 (Cross layer) 增加特征之间的交互力度；Deep 部分则与 Wide&amp;Deep 保持一致。模型结构如下图所示：\n\n\n其中 Cross 网络的交叉方式与 OPNN 的外积操作十分类似，  , 其中  表示第 l 层和第 l+1 层 Cross 网络的输出，  是第 l 层的权重和偏置。每一层 Cross 网络都会在特征交叉变换后加上该层的输入，即变换函数 f 拟合的是残差  。具体过程如上述右图所示。  \nWide&amp;Deep 融合传统模型的记忆能力和深度模型的泛化能力，工程实现简单高效，在很多公司都成功落地，也正是从 Wide&amp;Deep 之后，深度推荐模型开始朝着结构多样化复杂化发展。其中之一就是 FM 与深度学习结合产生出 FM 交叉特征系列的演变模型：\n\nFNN：出自 2016 年伦敦大学论文《Deep Learning over Multi-field Categorical Data – A Case Study on User Response Prediction》，相比 DNN，改进之处在于使用 FM 参数初始化其 Embedding 层的权重,  ，下图 Dense Real 层中的各权重  与公式中是对应的，只是在训练 FM 的过程中，没有区分特征域，而 FNN 中特征被分成了不同的特征域，特征域内的 Embedding 是全连接，特征域之间无连接。论文中与 FNN 对比的是 SNN（Sparse Feature 层与 Embedding 层之间是全连接），此处不再赘述。\n\n\n\nDeepFM：2017 年由哈工大 &amp; 华为提出，使用 FM 替换 Wide&amp;Deep 的 Wide 部分，加强浅层网络组合特征的能力。DeepFM 的改进目的和 Deep&amp;Cross 的目的是一致的，只是采用的手段不同。\nNFM：2017 年新加坡国立大学提出 NeuralFM 模型，目的是使用表达能力更强的函数替换原本 FM 中二阶隐向量内积的部分，由  变为  。其中 f(x) 如下图所示。NFM 在 Embedding 层和多层神经网络之间增加了交叉池化层 (Bi-interaction Pooling layer)，用于将一组 Embedding 向量转换成一个向量，具体操作是对所有的 Embedding 向量做两两元素积，再对所有的元素积向量取和作为池化层的输出，输入上次的全连接网络。\n\n\n然后是 Attention 机制、序列模型与推荐系统的结合：\n\nAFM：AFM 既是 FM 系列模型的延续演化，也是 Attention 机制与推荐系统的结合发展。此处不再赘述。\nDIN：阿里巴巴根据其典型的电商广告推荐场景，于 2017 年提出 DNN 结合 Attention 机制的 DIN(Deep Interest Network) 模型。利用候选商品和用户历史交互商品之间的相关性得出注意力权重，以此根据用户历史交互商品计算出用户的加权和 Embedding，  ，其中  是用户的 Embedding 向量，  是候选广告商品的 Embedding 向量，  是用户 u 的第 i 次互动行为的 Embedding 向量，  为注意力得分，即候选广告与用户第 i 次行为的相似度。模型中注意力激活单元的设计是输入两个 Embedding 向量，经过元素减操作 (element-wise minus) 后，与原 Embedding 向量拼接后送入全连接层得出注意力分值。如下图右上角所示。\n\n\n\nDIEN：2019 年阿里提出 DIEN(Deep Interest Envole Network) 在 DIN 的基础上融合了序列模型，用于模拟用户兴趣随时间的变化过程。在电商广告推荐场景中，序列信息加强了用户最近行为对下次行为预测的影响，能够学习用户的购买趋势。出于这样的目的，阿里巴巴在 DIN 的基础上引入了兴趣进化网络学习用户的兴趣 Embedding。模型结构图如下：\n\n\nDIEN 的兴趣进化网络分为三层：行为序列 (Behavior Layer) 层，把原始的 id 类行为序列转换成 Embedding 行为序列；兴趣抽取 (Interest Extractor Layer) 层，抽取用户兴趣，模拟用户兴趣迁移；兴趣进化 (Interest Evolving Layer) 层，增加注意力机制，模拟与目标广告相关的兴趣进化过程。其中兴趣抽取层的基本结构是 GRU(Gated Recurrent Unit)，将用户的行为向量 Embedding 转换成兴趣状态向量。兴趣进化层也是通过 AUGRU(GRU with Attentional Update gate)引入注意力机制的，在原 GRU 的更新门结构上增加了注意力得分。\n\nMIND：DIEN 之后，阿里天猫团队又提出使用胶囊网络提取用户的多样兴趣，再加上基于标签的注意力机制，提升召回的丰富度和准确度，此模型并未包含在书中，但笔者认为 MIND 模型还是有很多值得探究的地方，也有实际落地的效果和意义。关于胶囊网络的理解感兴趣的小伙伴可自行阅读相关论文，此处只解释 MIND 模型中的用法。用户交互的物品 Embedding 集合作为多样兴趣提取 (Multi-interest Extractor Layer) 层的输入，经过胶囊网络的动态路由算法生成一组用户兴趣 Embedding(可以视为用户行为的软聚类)。用户基础画像属性的 Embedding 分别与用户兴趣 Embedding 拼接，经过两层全连接，得到一组用户 Embedding。再根据 label 的 Embedding 与用户 Embedding 求相似度作为注意力权重。MIND 网络结构如下图所示：\n\n\n最后是强化学习与推荐系统的融合：\n\nDRN：强化学习相比传统深度模型的优势在于强化学习模型能够进行 “在线学习”，不断利用新学到的知识更新自己，及时调整和反馈。DRN(Deep Reinforcement Learning) 框架中起决定作用的是 DQN(Deep Q-Network), 对 DQN 感兴趣的小伙伴可以自行阅读相关论文，这里只说推荐系统中如何使用 DQN。DQN 把用户特征和环境特征归为和具体行动无关的状态向量，把用户 - 新闻交叉特征以及新闻特征归为与推荐内容这一行动相关的行动特征。DQN 的网络结构如下图所示。用户特征和环境特征经过左侧多层神经网络拟合得到价值得分  ，利用状态向量和行动向量生成优势得分  , 综合二者分值，得到最终的质量得分  。\n\n\nDRN 中使用的一种新的在线训练方法 - 竞争梯度下降算法 (Dueling Bandit Gradient Descent Algorithm) 是其能够在线学习的原因，其主要步骤如下：  \n\n\n对于已经训练好的当前网络 Q，对其模型参数 W 添加一个较小的随机扰动  ，得到新的模型参数  ，这里  即为探索网络  .\n\n\n\n对于当前网络 Q 和探索网络  ，分别生成推荐列表 L 和  ，用 Interleaving 方法将合并两个推荐列表后推送给用户。\n\n\n\n实时收集用户反馈，如果探索网络  的反馈好于当前网络 Q，则用探索网络替代当前网络，进入下一轮迭代；反之则保留当前网络。\n\n\n\n第四章 Embedding 技术在推荐系统中的应用推荐系统中的 Embedding 技术主要是指将高维稀疏特征向量转换成低维稠密向量，便于深度神经网络的处理，同时具有综合信息能力强、易于线上部署的特点。\n首先是经典 Embedding 方法：\n\nword2Vec:2013 年由 Google 提出，从 nlp 推广到广告、搜索、图像、推荐等深度学习应用领域。w2v 是生成对 “词” 的向量表达的模型。对于由单词组成句子，句子组成文档的语料库，w2v 假设每个词都跟其相邻词组成的上下文相关, 或决定上下文 (Skip-gram) 或由上下文决定(CBOW)。对任意一个句子，目标词前后各选 c 个词作为上下文，在句子中滑动此长度 2c+1 的滑动窗口，每移动一次就是一个训练样本。\n\n以 skip-gram 为例，既然每个词都决定了上下文中的词，根据极大似然估计，对于一个完整的句子，为了使滑动窗口内单词的条件概率  之积最大，转换成对数概率后的目标函数为最大化平均对数概率:  , 在原始 skip-gram 中条件概率  使用  , 书中此处公式与论文中不同，本文以论文为准。  为输入目标词，$W_O$ 指上下文单词。  和  分别为单词 w 的输入输出表示，这里每个单词都有一个输入表示对应下图网络结构中的  参数中的 Embedding，与一个输出表示对应  参数中的 Embedding，所以前面的  是用目标词的左侧 Embedding 与上下文各单词的右侧 Embedding 的乘积做 softmax。\n\nword2vec 有两种加速训练方法：负采样和 Hierarchical softmax，其中负采样实现简单高效，使用比较广泛。原本负样本集合为词典中除目标词外的所有词，计算复杂度高，只采样其中几个作为负样本可大幅提高训练速度也不会降低训练效果。\n\nItem2Vec: 2016 年微软提出的 Item2Vec 与 Word2vec 基本类似，只是把背景从 nlp 推广到推荐领域。Item2Vec 把用户的浏览、购买等行为交互的物品列表作为 “句子”。Item2Vec 与 Word2Vec 唯一的不同在于，Item2Vec 中没有时间窗口一说，即用户交互的物品序列中任意两个物品都相关，因此目标函数也是最大化序列中两两物品的对数概率之和:  。这里作者将 Item2Vec 扩展到了广义上的 “双塔” 中的“物品塔”，都是将物品相关的原始特征转换为物品的 Embedding 向量。Item2Vec 是学习序列物品表示的最优选择，但序列数据也是 Item2Vec 的局限所在。\n\n经典 Embedding 方法都存在只能应用在序列数据的局限性，而互联网场景下更多的是网络图结构的数据，就有了 graph embedding– 学习图中节点 Embedding 的方法：\n\nDeepWalk：2014 年被提出，主要思路是在物品组成的图结构上随机游走，产生大量物品序列，然后基于这些物品序列进行 Word2Vec 训练得到物品的 Embedding。DeepWalk 随机游走过程中的跳转概率可根据业务灵活定义。\n\n\n\nLINE：为提升大规模网络图结构上节点 Embedding 学习的效率，2015 年微软 &amp; 北大提出了 LINE 模型。论文还提出了衡量图中节点的两种相似度的两种指标：一阶相似度 (first-order proximity) 即有直接连接的顶点之间是相似的，  ；二阶相似度 (second-order proximity) 邻近网络结构的相似性即共享邻居节点的节点是相似的,  。学习节点 Embedding 时通过保留这两种相似度来保留原始的图结构信息。为降低复杂度，论文采用分别训练一阶相似模型和二阶相似模型，然后将两个向量拼接成一个更长的向量的方法，并使用负采样、边采样等方法优化模型速度。\n\nNode2Vec: 2016 年斯坦福提出图数据结构的两种性质：网络的同质性 (homophily)，距离相近的节点的 Embedding 应尽量相似；网络的结构性 (structural equivalence)，结构上相似的节点的 Embedding 应尽量相似。这两种性质可以认为是一阶二阶相似度的扩展，在推荐系统中的解释是，同质性相同的物品很可能是同品类、同属性或经常被一同购买的物品，而结构性相同则是各品类中的爆款、最佳凑单物品。Node2Vec 通过调整随机游走权重控制节点间跳转概率进而决定节点 Embedding 结果倾向于同质性还是结构性。从节点 v 跳转到下一个节点 x 的概率  定义如下图。\n\n\n\n\nEGES: 2018 年阿里巴巴公布淘宝使用的 graph Embedding 方法，EGES(Enhanced Graph Embedding with side Information)，基本思想是在 Deepwalk 生成的 Graph Embedding 基础上引入节点的其他属性信息作为冷启动时的补充信息，因此一个节点可能拥有多个 Embedding 向量，EGES 将这多个向量加权平均后输入 softmax 层，学习出每个 Embedding 的权重。\n\n上述这些 GraphEmbedding 方法可以认为都是直推式学习 (transductive learning), 即在固定的图上学习每个节点的 Embedding，每次学习只考虑当前数据，不能适应图结构经常变化的情况，因为图结构发生变化后需要重新学习全图 Embedding。而归纳学习(inductive learning) 是学习在图上生成节点 Embedding 的方法，这一类中目前已经落地的是 Pinsage 算法：\n\nGraphSage &amp; PinSage：2017 年斯坦福发表 GraphSage 论文，2018 年斯坦福和 Pinterest 公司合作落地 PinSage。GraphSage 的核心是学习如何聚合节点的邻居特征生成当前节点的信息，学习到这样一个聚合函数之后，不管图结构和图信息如何变化，都可以通过当前已知各个节点的特征和邻居关系，生成节点的 embedding。GraphSage 算法主要由两个操作组成：Sample 采样和 Aggregate 聚合。采样是为了避免全图计算，每次只计算部分节点的 Embedding。聚合操作则是学习一个聚合函数。关于 GraphSage 和 PinSage 的详细讲解，感兴趣的小伙伴可以参考：\n\n一块小蛋糕：全面理解 PinSagezhuanlan.zhihu.com\n最后是 Embedding 在推荐系统中的使用方式：\n\n转换高维稀疏特征：使用深度模型处理高维稀疏特征向量几乎都会在输入层到全连接层之间加入 Embedding 层，将高维稀疏特征转换为低维稠密 Embedding。但 Embedding 层存在一个缺点，维度超高导致模型收敛速度变慢。\n\n预训练：将 Embedding 的训练单独进行，得到稀疏特征的稠密表达后与其他特征一起送入神经网络训练。比如 Graph Embedding 的训练过程一般都是独立于推荐模型的。\n\n召回：利用 Embedding 进行候选物品召回，代表方案是 YouTube 推荐召回层的方式，模型部署时无需部署整个深度神经网络，只需将用户 Embedding 和物品 Embedding 存储到线上内存数据库通过内积运算再排序的方式就可以得到物品的排序。\n\n在线服务：以高维空间快速搜索最近邻操作代替 Embedding 之间的内积运算。工程实践上主流的快速 Embedding 向量最近邻搜索方法：局部敏感哈希 (Locality Sensitive Hashing)，其基本思想是让相邻的点落入同一个 bucket，在进行最近邻搜索时，只需搜索一个或几个 bucket 即可。LSH 背后的理论依据是低维空间可以部分保存高维空间的近似距离信息。LSH 采用多个哈希函数同时进行分桶，在多桶集合的并集或交集组成的相邻点的候选集合中搜索 K 近邻。\n\n\n第五章 多角度审视推荐系统这一章主要是总结了推荐领域的一些特有问题。\n\n特征选取和处理：推荐系统特征工程应该遵循的原则是尽可能地让特征工程抽取出一组特征能够保留推荐环境及用户行为过程中的所有有用信息，尽量摒弃冗余信息。推荐系统中常用的特征数据包括用户行为数据、用户关系数据、属性标签类数据、内容类数据、上下文信息、统计类特征、组合类特征。常用的特征处理方法包括连续特征归一化、离散化、加非线性函数；类别特征 one-hot 或 multi-hot 编码等。\n\n召回层策略：多路召回、基于 Embedding 召回。\n\n推荐系统实时性：推荐系统的实时性体现在能实时地感知用户反馈满足用户期望。这里的实时性包含两大要素: 特征实时性，即实时地收集和更新推荐模型的输入特征使推荐系统总能以最新的特征进行预测和推荐；模型实时性，即更快地捕获全局最新数据模式、发现数据中的新趋势和相关性。模型的实时性与模型的更新方式相关：全量更新、增量更新和在线学习。而实际应用中除了这三种更新方式还有模型的局部更新及客户端模型实时更新（更新用户自身 Embedding）两种方式。\n\n设定推荐模型的优化目标：合理的推荐系统优化目标由公司的商业目标决定，确保模型的优化方向与应用场景保持一致。例如 YouTube 以观看时长为优化目标，电商场景以 CVR、CTR 为优化目标。\n\n根据业务改进模型结构：推荐模型的结构不是构建一个好的推荐系统的 “银弹”，对用户行为和应用场景的观察分析才是。以 Netflix 和阿里巴巴对各自推荐模型结构的改进为例，都是根据自家业务场景分析的结果。\n\n冷启动问题：主要是用户冷启动、物品冷启动、系统冷启动三种。主流的冷启动策略有基于规则的冷启动过程、丰富冷启动过程中可获得的用户和物品特征、利用主动学习以及迁移学习和探索利用机制。\n\n探索与利用策略：E&amp;E 策略主要用于解决冷启动问题、挖掘用户新兴趣、增加推荐结果的多样性。传统的探索与利用方法有  、Thompson Sampling 和 UCB。这类方法中不考虑用户上下文等因素。个性化的探索与利用策略主要是 LinUCB。而基于模型的探索与利用方法主要是 DRN。\n\n\n第六章 深度学习推荐系统的工程实现实现深度学习推荐流的一些工程问题\n\n数据流工程：基于 Lambda 架构或 Kappa 架构的数据平台加入机器学习层，将机器学习与数据处理融为一体。\n\n模型的离线训练：分布式机器学习训练有三个主流方案：Spark MLib、Parameter Server 和 TensorFlow。其中 Spark MLib 的模型并行训练过程是 “数据并行” 的过程，采用全局广播的方式在每轮迭代前广播全部模型参数，同步更新梯度，不支持复杂深度学习网络和大量可调试超参。\n\n\n而 Parameter Server 方案则完美解决了机器学习模型的分布式训练问题，其中的 server 节点保存模型参数、接收 worker 节点计算出的局部梯度、汇总计算全局梯度并更新模型参数；worker 节点保存部分训练数据，从 server 节点拉取最新的模型参数，根据训练数据计算局部梯度，上传给 server 节点。worker 之间，server 之间并不通信，只有 worker 和 server 之间存在数据交流。相比 spark 只支持同步更新梯度，PS 架构既支持同步更新也支持异步更新策略，同时使用一致性哈希、参数范围拉取、参数范围推送等工程手段避免广播造成全局网络阻塞。\nTensorFlow 中基于各种操作 op 组成的任务关系图进行并行训练，存在依赖关系的任务节点或子图之间需要串行执行，不存在依赖关系的任务节点或子图之间可以并行执行。tf 的分布式策略有多种，一般使用的是 Parameter Server 策略，和 PS 方案一致。\n\n模型的线上部署：最简单直接的方法是将离线环境下生成的每个用户的推荐结果预存到线上数据库如 Redis 等。好处是无需线上推断且服务延迟极低。但无法提供实时推荐效果且随着用户增长线上资源要求越来越高。其次是预训练 Embedding + 轻量级线上模型，线上预存用户和物品的 Embedding，推断时只实现最后输出层的逻辑。还有一个选择是利用 PMML 转换并部署模型，例如使用 Spark 训练完模型后保存为 PMML 文件，Java Server 进行 PMML 文件的解析并恢复模型进行推断。最后一个选择就是 TensorFlow Serving，其服务流程和 PMML 一致，只是模型文件是 tf 自带的序列化标准。\n\n第七章 推荐系统的评估推荐系统的评估用于指导推荐系统的优化方向：\n\n离线评估：主要有 Holdout 检验，交叉检验，自助法三种。模型离线评估指标包括准确率、精确率、召回率、均方根误差、对数损失等。推荐序列的离线评估指标则包括 P-R 曲线，ROC 曲线，平均精度均值 mAP，归一化折扣累计收益 NDCG，覆盖率，多样性等。\n\n离线仿真评估 Replay：生成每天的数据快照，使用历史样本数据进行重放。Replay 适用于几乎所有推荐模型的离线评估，而且是强化学习类模型唯一的离线评估方法。\n\n线上 A&#x2F;B test：利用控制变量法保持单一变量的前提下，将 A，B 两组数据对比得出实验结论 。相比于离线评估无法消除数据有偏影响、无法完全还原线上环境、无法计算一些线上商业指标 (如用户点击率，留存时长，PV 访问量等)。A&#x2F;B test 测试原则：层与层之间的流量正交，即实验中每组的流量穿越该层后都会被再次随机打散，且均匀分布在下个实验的每个实验组中；同层之间的流量互斥，即同层不同测试之间的流量不重叠。\n\n快速线上评估 - Interleaving：线上 A&#x2F;B test 的预选阶段，能够快速地将最初的候选算法集合进行缩减，比 A&#x2F;B test 能更快确定最优算法。Interleaving 是把不同的被测对象同时提供给受试者，最后根据受试者喜好得出评估结果。优点是所需样本少、测试速度快、结果与 A&#x2F;B test 无明显差异。虽然 Interleaving 指标与 A&#x2F;B test 测试评估指标之间存在非常强的相关性，但 Interleaving 无法完全替代 A&#x2F;B test。\n\n\n","slug":"《深度学习推荐系统》读书笔记","date":"2022-01-04T03:02:15.000Z","categories_index":"AI","tags_index":"推荐系统","author_index":"析构理想"},{"id":"747ecc98a7de37667350d5bf3e99a77c","title":"Boosting & Bagging","content":"Boosting &amp; Bagging用抽样的方式从原始样本中进行有放回的多次抽样（或者是抽特征），这种方法叫做Bootstraping，抽取k次每次抽取n个样本，这样就生成了k个样本容量为n的数据集。原始数据集中的样本可能是多次被抽到也可能是没有被抽到。\nboosting与bagging不同的是，bagging是多个模型“并行”，voting决定结果；而boosting是多个模型串行，通过多个模型的结果相加得到最终的结果。\nAdaBoosting方式每次使用的是全部的样本，每轮训练改变样本的权重。下一轮训练的目标是找到一个函数f 来拟合上一轮的残差。当残差足够小或者达到设置的最大迭代次数则停止。Boosting会减小在上一轮训练正确的样本的权重，增大错误样本的权重。（对的残差小，错的残差大）\n梯度提升的Boosting方式是使用代价函数对上一轮训练出的模型函数f的偏导来拟合残差。\n","slug":"机器学习笔记","date":"2022-01-04T03:02:15.000Z","categories_index":"AI","tags_index":"机器学习","author_index":"析构理想"},{"id":"90f2417d388e3c74c0ba506e56fcf375","title":"Leetcode题解","content":"数组二分查找704.二分查找class Solution &#123;\npublic:\n    int search(vector&lt;int&gt;&amp; nums, int target) &#123;\n        int left &#x3D; 0;\n        int right &#x3D; nums.size(); &#x2F;&#x2F; 定义target在左闭右开的区间里，即：[left, right)\n        while (left &lt; right) &#123; &#x2F;&#x2F; 因为left &#x3D;&#x3D; right的时候，在[left, right)是无效的空间，所以使用 &lt;\n            int middle &#x3D; left + ((right - left) &gt;&gt; 1);\n            if (nums[middle] &gt; target) &#123;\n                right &#x3D; middle; &#x2F;&#x2F; target 在左区间，在[left, middle)中\n            &#125; else if (nums[middle] &lt; target) &#123;\n                left &#x3D; middle + 1; &#x2F;&#x2F; target 在右区间，在[middle + 1, right)中\n            &#125; else &#123; &#x2F;&#x2F; nums[middle] &#x3D;&#x3D; target\n                return middle; &#x2F;&#x2F; 数组中找到目标值，直接返回下标\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 未找到目标值\n        return -1;\n    &#125;\n&#125;;\n\n快慢指针27. 移除元素class Solution &#123;\npublic:\n    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;\n        int slowIndex &#x3D; 0;\n        for (int fastIndex &#x3D; 0; fastIndex &lt; nums.size(); fastIndex++) &#123;\n            if (val !&#x3D; nums[fastIndex]) &#123;\n                nums[slowIndex++] &#x3D; nums[fastIndex];\n            &#125;\n        &#125;\n        return slowIndex;\n    &#125;\n&#125;;\n\n滑动窗口209.长度最小的子数组class Solution &#123;\npublic:\n    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;\n        int result &#x3D; INT32_MAX;\n        int sum &#x3D; 0; &#x2F;&#x2F; 滑动窗口数值之和\n        int i &#x3D; 0; &#x2F;&#x2F; 滑动窗口起始位置\n        int subLength &#x3D; 0; &#x2F;&#x2F; 滑动窗口的长度\n        for (int j &#x3D; 0; j &lt; nums.size(); j++) &#123;\n            sum +&#x3D; nums[j];\n            &#x2F;&#x2F; 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件\n            while (sum &gt;&#x3D; s) &#123;\n                subLength &#x3D; (j - i + 1); &#x2F;&#x2F; 取子序列的长度\n                result &#x3D; result &lt; subLength ? result : subLength;\n                sum -&#x3D; nums[i++]; &#x2F;&#x2F; 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列\n        return result &#x3D;&#x3D; INT32_MAX ? 0 : result;\n    &#125;\n&#125;;\n\n链表虚拟头结点203.移除链表元素class Solution &#123;\npublic:\n    ListNode* removeElements(ListNode* head, int val) &#123;\n        ListNode* dummyHead &#x3D; new ListNode(0); &#x2F;&#x2F; 设置一个虚拟头结点\n        dummyHead-&gt;next &#x3D; head; &#x2F;&#x2F; 将虚拟头结点指向head，这样方面后面做删除操作\n        ListNode* cur &#x3D; dummyHead;\n        while (cur-&gt;next !&#x3D; NULL) &#123;\n            if(cur-&gt;next-&gt;val &#x3D;&#x3D; val) &#123;\n                ListNode* tmp &#x3D; cur-&gt;next;\n                cur-&gt;next &#x3D; cur-&gt;next-&gt;next;\n                delete tmp;\n            &#125; else &#123;\n                cur &#x3D; cur-&gt;next;\n            &#125;\n        &#125;\n        head &#x3D; dummyHead-&gt;next;\n        delete dummyHead;\n        return head;\n    &#125;\n&#125;;\n\n哈希表map1. 两数之和\n\n","slug":"Leetcode笔记","date":"2022-01-04T03:02:15.000Z","categories_index":"Algorithm","tags_index":"Leetcode","author_index":"析构理想"},{"id":"436595af82415f3136acebc87ded2af2","title":"「前端面试」 JS 编程题目总结","content":"\n\n\n\n\n\n\n\n\n前端面试中，手撕代码环节除了力扣上的算法题目之外，还有一些针对前端知识点的题目，大致有以下几类： 算法类 原理类 应用类 算法类 1. 手写快排、冒泡、选择排序 2. URL 拆解问题 3. 将 HTTP header 转换成 js 对象 注意到 这样的输入格式叫做 模板字符串。\n前端面试中，手撕代码环节除了力扣上的算法题目之外，还有一些针对前端知识点的题目，大致有以下几类：\n\n算法类\n原理类\n应用类\n\n算法类1. 手写快排、冒泡、选择排序\n\n快速排序\n冒泡排序\n选择排序\n\n&#x2F;**\n * --- 测试用例 ---\n *\n * 输入：[1, 34, 5, 76, 8, 6, 9, 7, 6, 3]\n * 输出：[1, 3, 5, 6, 6, 7, 8, 9, 34, 76]\n *\n * --- 说明 ---\n * \n * 思考：快速排序是稳定的吗？\n * 解答：base 的每次选择，会导致快排是不稳定排序。\n *&#x2F;\n\nconst quickSort &#x3D; (nums) &#x3D;&gt; &#123;\n    if (nums.length &lt; 2) &#123;\n        return nums;\n    &#125; else &#123;\n        var left &#x3D; [];\n        var right &#x3D; [];\n        var pivot &#x3D; Math.floor(nums.length &#x2F; 2); &#x2F;&#x2F; Math.floor 向下取整\n        var base &#x3D; nums.splice(pivot, 1)[0];\n        for (let i &#x3D; 0; i &lt; nums.length; i++) &#123;\n            if (nums[i] &lt; base) &#123;\n                left.push(nums[i]);\n            &#125; else &#123;\n                right.push(nums[i]);\n            &#125;\n        &#125;\n    &#125;\n    return quickSort(left).concat([base], quickSort(right));\n&#125;\n\n&#x2F;**\n * --- 测试用例 ---\n *\n * 输入：[5, 2, 4, 7, 9, 8, 3, 6, 3, 8, 3]\n * 输出：[2, 3, 3, 3, 4, 5, 6, 7, 8, 8, 9]\n *\n * --- 说明 ---\n * \n * 思考：冒泡排序是稳定的吗？\n * 解答：稳定。相等的元素不发生交换\n *&#x2F;\n\nconst bubbleSort &#x3D; (nums) &#x3D;&gt; &#123;\n    for (var i &#x3D; 0; i &lt; nums.length - 1; i++) &#123;\n        for (var j &#x3D; 0; j &lt; nums.length - 1 - i; j++) &#123;\n            if (nums[j] &gt; nums[j + 1]) &#123;\n                let tmp &#x3D; nums[j];\n                nums[j] &#x3D; nums[j + 1];\n                nums[j + 1] &#x3D; tmp;\n            &#125;\n        &#125;\n    &#125;\n    return nums;\n&#125;\n\n&#x2F;**\n * --- 测试用例 ---\n *\n * 输入：[6, 45, 3, 2, 5, 6, 8, 4, 3, 4, 56, 67, 5]\n * 输出：[2, 3, 3, 4, 4, 5, 5, 6, 6, 8, 45, 56, 67]\n *\n * --- 说明 ---\n * \n * 思考：选择排序是稳定的吗？\n * 解答：要看代码是如何实现的，在本例中由于有交换，所以是不稳定排序。\n *&#x2F;\n\nconst selectSort &#x3D; (nums) &#x3D;&gt; &#123;\n    var idx; &#x2F;&#x2F; 最小值的索引\n    for (var i &#x3D; 0; i &lt; nums.length - 1; i++) &#123;\n        idx &#x3D; i;\n        for (var j &#x3D; i + 1; j &lt; nums.length; j++) &#123;\n            if (nums[j] &lt; nums[idx]) &#123;\n                idx &#x3D; j;\n            &#125;\n        &#125;\n        if (nums[i] &gt; nums[idx]) &#123;\n            let tmp &#x3D; nums[idx];\n            nums[idx] &#x3D; nums[i];\n            nums[i] &#x3D; tmp;\n        &#125;\n    &#125;\n    return nums;\n&#125;\n\n2. URL 拆解问题\n\n题目一\n题目二\n\n&#x2F;**\n * --- 题目描述 ---\n * \n * 实现一个函数，可以对 url 中的 query 部分做拆解，返回一个 key: value 形式的 object  \n * \n * --- 实例 ---\n * \n * 输入：&#39;http:&#x2F;&#x2F;sample.com&#x2F;?a&#x3D;1&amp;e&amp;b&#x3D;2&amp;c&#x3D;xx&amp;d#hash&#39; \n * 输出：&#123;a: 1, b: 2, c: &#39;xx&#39;, d: &#39;&#39;&#125;  \n *&#x2F;\n\nfunction getQueryObj(url) &#123;\n    &#x2F;&#x2F; TODO\n    let arr &#x3D; url.split(&#39;?&#39;)[1].split(&#39;#&#39;)[0].split(&#39;&amp;&#39;);\n    const res &#x3D; &#123;&#125;;\n    arr.forEach(e &#x3D;&gt; &#123;\n        const [key, value] &#x3D; e.split(&#39;&#x3D;&#39;);\n        if (!value) &#123;\n            res[key] &#x3D; &#39;&#39;;\n        &#125; else &#123;\n            res[key] &#x3D; value;\n        &#125;\n    &#125;)\n    return res;\n&#125;\n\n&#x2F;**\n * --- 题目描述 ---\n *\n * 实现一个 parseParem 函数，将 url 转化为指定结果\n *\n * --- 测试用例 ---\n *\n * 输入：url &#x3D; &#39;http:&#x2F;&#x2F;www.domain.com&#x2F;?user&#x3D;anonymous&amp;id&#x3D;123&amp;id&#x3D;456&amp;city&#x3D;%E5%8C%97%E4%BA%AC&amp;enabled&#39;\n * 输出：\n&#123;\n user:&#39;anonymous&#39;,\n id:[123,456],&#x2F;&#x2F; 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型\n city:&#39;北京&#39;,&#x2F;&#x2F; 中文需解码\n enabled: true &#x2F;&#x2F; 未指定值的 key 与约定为 true\n&#125;\n *&#x2F;\n\nconst parseParem &#x3D; (url) &#x3D;&gt; &#123;\n    const arr &#x3D; url.split(&#39;?&#39;)[1].split(&#39;&amp;&#39;);\n    const res &#x3D; &#123;&#125;;\n    arr.forEach((e) &#x3D;&gt; &#123;\n        let key &#x3D; e.split(&#39;&#x3D;&#39;)[0], value &#x3D; e.split(&#39;&#x3D;&#39;)[1];\n        if (value &#x3D;&#x3D;&#x3D; undefined) &#123;\n            res[key] &#x3D; true;\n        &#125; else &#123;\n            if (key in res) &#123;\n                Array.isArray(res[key]) ? res[key].push(value) : res[key] &#x3D; [res[key]].concat(value);\n            &#125; else &#123;\n                res[key] &#x3D; decodeURI(value)\n            &#125;\n        &#125;\n    &#125;)\n    return res;\n&#125;\n\n3. 将 HTTP header 转换成 js 对象\n\nJavaScript\n\n&#x2F;**\n * --- 题目描述 ---\n *\n * 实现一个方法，把 HTTP 文本形式(字符串)的 header 转换成 JS 对象。\n * \n * --- 测试用例 ---\n * \n * 输入：\n * &#96;Accept-Ranges: bytes \n * Cache-Control: max-age&#x3D;6000, public\n * Connection: keep-alive\n * Content-Type: application&#x2F;javascript&#96;\n * 输出：\n * &#123;\n *   &quot;Accept-Ranges&quot;: &quot;bytes&quot;,\n *   &quot;Cache-Control&quot;: &quot;max-age&#x3D;6000, public&quot;,\n *   Connection: &quot;keep-alive&quot;,\n *   &quot;Content-Type&quot;: &quot;application&#x2F;javascript&quot;\n * &#125;\n *\n * --- 解题思路 ---\n *\n * 1. 首先将每行数据作为数组的一个元素\n * 2. 将每个元素使用冒号分割，前面为 &#96;key&#96;，后面为 &#96;value&#96;。\n *&#x2F;\n\nconst solution &#x3D; (s) &#x3D;&gt; &#123;\n    let res &#x3D; &#123;&#125;;\n    let arr &#x3D; s.split(&quot;\\n&quot;);\n    arr.forEach((e) &#x3D;&gt; &#123;\n        let tmp &#x3D; e.split(&quot;: &quot;);\n        res[tmp[0]] &#x3D; tmp[1];\n    &#125;)\n    return res;\n&#125;\n\n注意到\n&#96;xxxxxx\nxxxxx\nxxxx&#96;\n\n这样的输入格式叫做 模板字符串。\n输出如下：\n&#123;\n  &#39;Accept-Ranges&#39;: &#39;bytes&#39;,\n  &#39;Cache-Control&#39;: &#39;max-age&#x3D;6000, public&#39;,\n  Connection: &#39;keep-alive&#39;,\n  &#39;Content-Type&#39;: &#39;application&#x2F;javascript&#39;\n&#125;\n\n注意到上面的输出结果中，Connection 没有带引号，这是为什么呢？\n4. 将数组转化为树形结构\n初始时，数组中的每个元素具有 4 个属性，其中有 id 和 parent_id，现在我们需要根据这两个 id 之间的关系，添加一个 children 属性，使之成为一棵树的结构。\n比如有如下数据：\nvar menu_list &#x3D; [&#123;\n    id: &#39;1&#39;,\n    menu_name: &#39;设置&#39;,\n    menu_url: &#39;setting&#39;,\n    parent_id: 0\n   &#125;, &#123;\n    id: &#39;1-1&#39;,\n    menu_name: &#39;权限设置&#39;,\n    menu_url: &#39;setting.permission&#39;,\n    parent_id: &#39;1&#39;\n   &#125;, &#123;\n    id: &#39;1-1-1&#39;,\n    menu_name: &#39;用户管理列表&#39;,\n    menu_url: &#39;setting.permission.user_list&#39;,\n    parent_id: &#39;1-1&#39;\n   &#125;, &#123;\n    id: &#39;1-1-2&#39;,\n    menu_name: &#39;用户管理新增&#39;,\n    menu_url: &#39;setting.permission.user_add&#39;,\n    parent_id: &#39;1-1&#39;\n   &#125;, &#123;\n    id: &#39;1-1-3&#39;,\n    menu_name: &#39;角色管理列表&#39;,\n    menu_url: &#39;setting.permission.role_list&#39;,\n    parent_id: &#39;1-1&#39;\n   &#125;, &#123;\n    id: &#39;1-2&#39;,\n    menu_name: &#39;菜单设置&#39;,\n    menu_url: &#39;setting.menu&#39;,\n    parent_id: &#39;1&#39;\n   &#125;, &#123;\n    id: &#39;1-2-1&#39;,\n    menu_name: &#39;菜单列表&#39;,\n    menu_url: &#39;setting.menu.menu_list&#39;,\n    parent_id: &#39;1-2&#39;\n   &#125;, &#123;\n    id: &#39;1-2-2&#39;,\n    menu_name: &#39;菜单添加&#39;,\n    menu_url: &#39;setting.menu.menu_add&#39;,\n    parent_id: &#39;1-2&#39;\n   &#125;, &#123;\n    id: &#39;2&#39;,\n    menu_name: &#39;订单&#39;,\n    menu_url: &#39;order&#39;,\n    parent_id: 0\n   &#125;, &#123;\n    id: &#39;2-1&#39;,\n    menu_name: &#39;报单审核&#39;,\n    menu_url: &#39;order.orderreview&#39;,\n    parent_id: &#39;2&#39;\n   &#125;, &#123;\n    id: &#39;2-2&#39;,\n    menu_name: &#39;退款管理&#39;,\n    menu_url: &#39;order.refundmanagement&#39;,\n    parent_id: &#39;2&#39;\n   &#125;\n ]\n\n思路是先使用 tmp 将数组中的元素处理成 id: &#123;id...menu_name...menu_url...parent_id&#125; 类的格式，然后针对该数据处理成树状结构。\n实现代码如下：\nconst buildTree &#x3D; (arr) &#x3D;&gt; &#123;\n    tmp &#x3D; &#123;&#125;;\n    res &#x3D; &#123;&#125;;\n    for (let i in arr) &#123;\n        tmp[arr[i].id] &#x3D; arr[i];\n    &#125;\n\n    for (let i in tmp) &#123;\n        if (tmp[i].parent_id) &#123; &#x2F;&#x2F; 如果节点没有父节点，即该节点为根节点\n            if (!tmp[tmp[i].parent_id].children) &#123; &#x2F;&#x2F; 该节点的父节点和该节点没有形成关系\n                tmp[tmp[i].parent_id].children &#x3D; new Object();\n            &#125;\n            tmp[tmp[i].parent_id].children[tmp[i].id] &#x3D; tmp[i];\n        &#125; else &#123;\n            res[tmp[i].id] &#x3D; tmp[i];\n        &#125;\n    &#125;\n    return res;\n&#125;\n\nconsole.log(buildTree(menu_list)); &#x2F;&#x2F;测试代码，menu_list 为前面的数据。\n\n据说这个代码可以使用数组的方法 Array.prototype.find() 来美化代码。如何实现呢？其实我也没太想好😂欢迎讨论。\n5. 数组扁平化\n解法一：递归\nvar arr &#x3D; [1, [2, [3, 4]]];\n\nfunction flatten(arr) &#123;\n    var result &#x3D; [];\n    for (var i &#x3D; 0, len &#x3D; arr.length; i &lt; len; i++) &#123;\n        if (Array.isArray(arr[i])) &#123;\n            result &#x3D; result.concat(flatten(arr[i]))\n        &#125;\n        else &#123;\n            result.push(arr[i])\n        &#125;\n    &#125;\n    return result;\n&#125;\n\n\nconsole.log(flatten(arr))\n\n解法二：es6 拓展运算符\nvar arr &#x3D; [1, [2, [3, 4]]];\n\nfunction flatten(arr) &#123;\n\n    while (arr.some(item &#x3D;&gt; Array.isArray(item))) &#123;\n        arr &#x3D; [].concat(...arr);\n    &#125;\n    return arr;\n&#125;\n\nconsole.log(flatten(arr))\n\n原地解法：这是一次面试中，面试官看完递归解法之后，问我有没有原地解法。这也是感到迷惑的地方，目前猜测可能是想考察 flat 的用法。欢迎讨论。\nconst arr1 &#x3D; [0, 1, 2, [[[3, 4]]]];\n\nconsole.log(arr1.flat(3)); &#x2F;&#x2F; 3 代表数组内最多嵌套层数\n&#x2F;&#x2F; expected output: [0, 1, 2, 3, 4]\n\n6. 模拟 lodash 中的 _.get() 函数\n\nJavaScript\n\n&#x2F;**\n * --- 题目描述 ---\n *\n * 补充函数的 TODO 部分，模拟 lodash 中的 _.get() 函数。\n *\n * --- 测试用例 ---\n *\n * 输入：\n * const obj &#x3D; &#123; selector: &#123; to: &#123; toutiao: &quot;FE Coder&quot;&#125; &#125;, target: [1, 2, &#123; name: &#39;byted&#39;&#125;]&#125;;\n * get(obj, &#39;selector.to.toutiao&#39;, &#39;target[0]&#39;, &#39;target[2].name&#39;)\n * 输出：\n * [&#39;FE coder&#39;, 1, &#39;byted&#39;]\n *&#x2F;\n\nfunction get(object, ...path) &#123;\n    return path.map((item) &#x3D;&gt; &#123;\n        item.replace(&#x2F;\\[&#x2F;g, &quot;.&quot;)\n            .replace(&#x2F;\\]&#x2F;g, &quot;&quot;)\n            .split(&#39;.&#39;)\n            .map(path &#x3D;&gt; object &#x3D; object &amp;&amp; object[path]);\n        return object;\n    &#125;)\n&#125;\n\n原理类1. 深拷贝\n&#x2F;&#x2F; deepClone\nfunction deepClone(obj &#x3D; &#123;&#125;) &#123;\n    if (typeof obj !&#x3D;&#x3D; &#39;object&#39; || obj &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; obj 是 null 或者不是对象和数组，直接返回\n        return obj;\n    &#125;\n    let res;\n    if (obj instanceof Array) &#123;\n        res &#x3D; [];\n    &#125; else &#123;\n        res &#x3D; &#123;&#125;;\n    &#125;\n\n    for (let key in obj) &#123;\n        &#x2F;&#x2F; 判断自身中是否包含自身属性\n        if (obj.hasOwnProperty(key)) &#123;\n            res[key] &#x3D; deepClone(obj[key])\n        &#125;\n    &#125;\n    return res;\n&#125;\n&#x2F;&#x2F; 验证\no &#x3D; &#123;a: 1, d: &#123;c: &#39;4&#39;&#125;&#125;;\nres &#x3D; deepClone(o);\nconsole.log(res);\nconsole.log(res &#x3D;&#x3D; o);\n\n2. 浅拷贝\n代码出处：https://dmitripavlutin.com/javascript-shallow-clone-objects/\n&#x2F;&#x2F; 首先定义一个对象\nconst hero &#x3D; &#123;\n  name: &#39;Batman&#39;,\n  city: &#39;Gotham&#39;\n&#125;;\n&#x2F;&#x2F; **********************方法一**********************\nconst heroEnhancedClone &#x3D; &#123;\n  ...hero,\n  name: &#39;Batman Clone&#39;,\n  realName: &#39;Bruce Wayne&#39;\n&#125;;\n\n&#x2F;&#x2F; 验证\nheroEnhancedClone;  &#x2F;&#x2F; &#123; name: &#39;Batman Clone&#39;, city: &#39;Gotham&#39;, realName: &#39;Bruce Wayne&#39; &#125;\n\n&#x2F;&#x2F; **********************方法二**********************\nconst &#123; ...heroClone &#125; &#x3D; hero;\n\n&#x2F;&#x2F; 验证\nheroClone; &#x2F;&#x2F; &#123; name: &#39;Batman&#39;, city: &#39;Gotham&#39; &#125;\nhero &#x3D;&#x3D;&#x3D; heroClone; &#x2F;&#x2F; &#x3D;&gt; false\n\n&#x2F;&#x2F; **********************方法三**********************\nconst hero &#x3D; &#123;\n  name: &#39;Batman&#39;,\n  city: &#39;Gotham&#39;\n&#125;;\n\n&#x2F;&#x2F; 验证\nconst heroClone &#x3D; Object.assign(&#123;&#125;, hero);\nheroClone; &#x2F;&#x2F; &#123; name: &#39;Batman&#39;, city: &#39;Gotham&#39; &#125;\nhero &#x3D;&#x3D;&#x3D; heroClone; &#x2F;&#x2F; &#x3D;&gt; false\n\n3. 手写 bind 函数\n&#x2F;&#x2F; 模拟 bind\nFunction.prototype.bind1 &#x3D; function() &#123;\n    &#x2F;&#x2F; 将参数拆解为数组\n    const args &#x3D; Array.prototype.slice.call(arguments) &#x2F;&#x2F; 变成数组\n    \n    &#x2F;&#x2F; 获取 this（数组第一项）\n    const t &#x3D; args.shift()\n    \n    &#x2F;&#x2F; fn1.bind(...) 中的 fn1\n    const self &#x3D; this\n    \n    &#x2F;&#x2F; 返回一个函数\n    return function() &#123;\n        return self.apply(t, args)\n    &#125;\n&#125;\nfunction fn1(a, b, c)&#123;\n    console.log(&#39;this&#39;, this)\n    console.log(a, b, c)\n    return &#39;this is fn1&#39;\n&#125;\nconst fn2 &#x3D; fn1.bind1(&#123;x: 100&#125;, 10, 20, 30)\nconst res &#x3D; fn2()\nconsole.log(res)\n\n4. 手写 new\n答案\n\nJavaScript\n\nfunction funcNew(obj, ...args) &#123;\n    const newObj &#x3D; Object.create(obj.prototype);\n    const result &#x3D; obj.apply(newObj, args);\n    return (typeof result &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; result !&#x3D;&#x3D; null) ? result : newObj;\n&#125;\n\n解读\n先通过一个例子来理解 new 的作用吧：\n\nJavaScript\n\nfunction Person(name) &#123;\n    this.name &#x3D; name;\n&#125;\n\nPerson.prototype.sayName &#x3D; function() &#123;\n    console.log(this.name);\n&#125; \n\nconst p &#x3D; new Person(&#39;orange&#39;)\nconsole.log(p.name) &#x2F;&#x2F; &#39;orange&#39;\np.sayName(); &#x2F;&#x2F; &#39;orange&#39;\n\n代码中我们新建了一个对象 Person，它具有属性 name，且在 Person.prototype 上定义了函数 sayName。\n当我们通过 new 创建一个新的实例 p 时，便同时具有了属性 p.name 和 p.sayName()，关系如下图：\n\n知道了原理，就可以自己实现了。也就是说，自己写一个函数 funcNew()，使得 const p = new Person(&#39;orange&#39;) 和 const p = funcNew(&#39;orange&#39;) 得到的 p 完全相同，于是得到了答案中的代码。\n答案中最后一行代码如何理解？\n前面的例子我们只考虑了 Person 中没有返回值的情况，如有有返回值，new 一个实例将会受到 Person 中返回值的影响。比如说：\n\nJavaScript\n\n&#x2F;**\n * --- Person 中 return 一个对象，p 为该对象 ---\n *&#x2F;\n\nfunction Person(name) &#123;\n    this.name &#x3D; name;\n    return &#123;age: 35&#125;\n&#125;\n\nPerson.prototype.sayName &#x3D; function() &#123;\n    console.log(this.name);\n&#125; \n\nconst p &#x3D; new Person(&#39;orange&#39;)\nconsole.log(p) &#x2F;&#x2F; &#123; age: 35 &#125;\nconsole.log(p.name) &#x2F;&#x2F; undefined\np.sayName(); &#x2F;&#x2F; TypeError: p.sayName is not a function\n\n&#x2F;**\n * --- Person 返回非对象，return 不影响结果 ---\n *&#x2F;\n\nfunction Person(name) &#123;\n    this.name &#x3D; name;\n    return &#39;free&#39;\n&#125;\n\nPerson.prototype.sayName &#x3D; function() &#123;\n    console.log(this.name);\n&#125; \n\nconst p &#x3D; new Person(&#39;orange&#39;)\nconsole.log(p) &#x2F;&#x2F; Person &#123; name: &#39;orange&#39; &#125;\nconsole.log(p.name) &#x2F;&#x2F; orange\np.sayName(); &#x2F;&#x2F; orange\n\n上面的例子中，如果返回了一个对象，我们需要返回该对象；如果不是对象，则 return 没用，正常处理。\n\n5. 如何自己实现一个 instanceof？\n答案\n\nJavaScript\n\n&#x2F;*\n * --- 手动实现 instanceof ---\n *&#x2F;\n\nfunction newInstanceOf (leftValue, rightValue) &#123;\n    if (typeof leftValue !&#x3D;&#x3D; &#39;object&#39; || rightValue &#x3D;&#x3D; null) &#123; \n        return false;\n    &#125;\n    \n    let rightProto &#x3D; rightValue.prototype;\n    leftValue &#x3D; leftValue.__proto__;\n    \n    while (true) &#123;\n        if (leftValue &#x3D;&#x3D;&#x3D; null) return false;\n        if (leftValue &#x3D;&#x3D;&#x3D; rightProto) return true;\n        leftValue &#x3D; leftValue.__proto__;\n    &#125;\n&#125;\n\n&#x2F;*\n * --- 验证 ---\n *&#x2F;\n\nconst a &#x3D; [];\nconst b &#x3D; &#123;&#125;;\n\nfunction Foo () &#123;&#125;\n\nvar c &#x3D; new Foo()\nfunction Child () &#123;&#125;\nfunction Father() &#123;&#125;\nChild.prototype &#x3D; new Father()\nvar d &#x3D; new Child()\n\nconsole.log(newInstanceOf(a, Array)) &#x2F;&#x2F; true\nconsole.log(newInstanceOf(b, Object)) &#x2F;&#x2F; true\nconsole.log(newInstanceOf(b, Array)) &#x2F;&#x2F; false\nconsole.log(newInstanceOf(a, Object)) &#x2F;&#x2F; true\nconsole.log(newInstanceOf(c, Foo)) &#x2F;&#x2F; true\nconsole.log(newInstanceOf(d, Child)) &#x2F;&#x2F; true\nconsole.log(newInstanceOf(d, Father)) &#x2F;&#x2F; true\nconsole.log(newInstanceOf(123, Object)) &#x2F;&#x2F; false \nconsole.log(123 instanceof Object) &#x2F;&#x2F; false\n\n解读\n这个问题既考察了 instanceof 的原理，又考察了原型链，还考察了代码能力，是一个好问题。\n在实现代码中，我们判断 leftValue 是否为 rightValue 的实例，思想是在 leftValue 的原型链上，即 leftValue.__proto__ 上寻找是否存在 rightValue.prototype。原理图如下：\n![](https://pic.leetcode-cn.com/1605406941-RYnUaG-Untitled Diagram.png)\n这需要我们熟练掌握原型链的相关知识。\n6. 实现 Promise.all()\n\n\n\n\n\n\n\n\n\n引用 MDN: Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都 “完成（resolved）” 或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 promise 的结果。\nfunction promiseAll(promises) &#123;\n  return new Promise(function(resolve, reject) &#123;\n    if (!isArray(promises)) &#123;\n      return reject(new TypeError(&#39;arguments must be an array&#39;));\n    &#125;\n    var resolvedCounter &#x3D; 0;\n    var promiseNum &#x3D; promises.length;\n    var resolvedValues &#x3D; new Array(promiseNum);\n    for (var i &#x3D; 0; i &lt; promiseNum; i++) &#123;\n        (function(i) &#123;\n            Promise.resolve(promises[i]).then(function(value) &#123;\n            resolvedCounter++\n            resolvedValues[i] &#x3D; value\n            if (resolvedCounter &#x3D;&#x3D; promiseNum) &#123;\n                return resolve(resolvedValues)\n            &#125;\n            &#125;, function(reason) &#123;\n            return reject(reason)\n            &#125;)\n        &#125;)(i)\n    &#125;\n  &#125;)\n&#125;\n\n此代码出自 segmentfault\n应用类1. 手写防抖（debounce）\n&#x2F;&#x2F; debounce\nfunction debounce(fn, delay&#x3D;500) &#123;\n    &#x2F;&#x2F; timer 写在闭包中，因此防抖也是闭包的一个应用\n    let timer &#x3D; null;\n\n    return function() &#123;\n        if (timer) &#123;\n            clearTimeout(timer)\n        &#125;\n        timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n            fn.apply(this, arguments);\n            timer &#x3D; null;\n        &#125;, delay)\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 验证\ninput1.addEventListener(&#39;keyup&#39;, debounce(() &#x3D;&gt; &#123;\n    console.log(input1.value);\n&#125;), 600)\n\n2. 手写节流（throttle）\n&#x2F;&#x2F; 节流\nfunction throttle(fn, delay &#x3D; 100) &#123;\n    let timer &#x3D; null\n\n    return function() &#123;\n        if (timer) &#123;\n            return\n        &#125;\n        timer &#x3D; setTimeout(() &#x3D;&gt; &#123;\n            fn.apply(this, arguments)\n            timer &#x3D; null\n        &#125;, delay)\n    &#125;\n&#125;\n\ndiv1.addEventListener((&#39;drag&#39;, throttle(function (e) &#123;\n    console.log(e.offsetX, e.offsetY)\n&#125;)))\n\n3. DOM 题目\n\n\n\n\n\n\n\n\n\n假设一个 ul 下有一万个 li，li 的 innerHTML 是从 0 到 9999，当点击某个 li 时输出该 li 代表的值，如何实现\n答案\n采用事件委托：\n\nJavaScript\nHTML\n\nwindow.onload &#x3D; function () &#123;\n    var uli &#x3D; document.getElementById(&quot;ul&quot;);\n    uli.onclick &#x3D; function(event) &#123;\n        alert(event.target.innerText);\n    &#125;\n&#125;\n\n&lt;ul id&#x3D;&quot;ul&quot;&gt;\n    &lt;li&gt;0&lt;&#x2F;li&gt;\n    &lt;li&gt;1&lt;&#x2F;li&gt;\n    &lt;li&gt;2&lt;&#x2F;li&gt;\n    ...\n    &lt;li&gt;9999&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n解读\n首先，我们当然不可能为每一个 li 标签手动添加一个 click 事件（容易累死）；其次，我们可能会想到使用 for 循环遍历每个元素，然后为其添加 click 事件，但这样会频繁操作 DOM，降低性能，卡到爆炸。\n而事件委托意义就在于此：减少 DOM 操作，从而减少浏览器的重绘与重排次数，提升性能。\n事件委托的原理是，将 li 上监听的 click 事件委托到 ul 上。这里运用到了 事件冒泡 的机制，即 onclick 事件以 li -&gt; ul -&gt; body -&gt; html -&gt; document 的冒泡顺序逐步传递。\n所以，我们可以选择在其中的 ul 上监听 click 事件，从而实现事件委托。\n\n\n\n\n\n\n\n\n\n如何创建 100000 个 &lt;li&gt; 呢？总不能复制粘贴 100000 次吧？\n创建 100000 个 &lt;li&gt; 标签，思路是将 0∼9999 保存在数组中，然后转化为字符串 &quot;&lt;li&gt;0&lt;/li&gt;&lt;li&gt;1&lt;/li&gt;...&lt;li&gt;9999&lt;/li&gt;&quot;，最后将他们作为 ul 标签的 innerHTML 即可。\n\nJavaScript\nHTML\n\n&#x2F;* --- create100000li.js --- *&#x2F;\n\nwindow.onload &#x3D; function() &#123;\n    var ul &#x3D; document.getElementsByTagName(&quot;ul&quot;);\n    var arr &#x3D; [];\n    for (let i &#x3D; 0; i &lt; 100000; i++) &#123;\n        arr.push(i);\n    &#125;\n    ul[0].innerHTML &#x3D; &#39;&lt;li&gt;&#39; + arr.join(&#39;&lt;&#x2F;li&gt;&lt;li&gt;&#39;) + &#39;&lt;&#x2F;li&gt;&#39;\n&#125;\n\n&lt;!-- index.html --&gt;\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;script src&#x3D;&quot;create100000li.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;body&gt;\n&lt;ul&gt;\n&lt;&#x2F;ul&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n源代码实现\n4. 手写 Promise 加载一张图片\nfunction loadImg(src) &#123;\n    const p &#x3D;  new Promise(\n        (resolve, reject) &#x3D;&gt; &#123;\n            const img &#x3D; document.createElement(&#39;img&#39;)\n            img.onload &#x3D; () &#x3D;&gt; &#123;\n                resolve(img)\n            &#125;\n            img.onerror &#x3D; () &#x3D;&gt; &#123;\n                const err &#x3D; new Error(&#96;图片加载失败 $&#123;src&#125;&#96;)\n                reject(err)\n            &#125;\n            img.src &#x3D; src\n        &#125;\n    )\n    return p\n&#125;\n\nconst url &#x3D; &#39;https:&#x2F;&#x2F;pic.leetcode-cn.com&#x2F;1604237471-xbJgZl-%E5%9B%BE%E7%89%871.png&#39;;\nloadImg(url).then(img &#x3D;&gt; &#123;\n    console.log(img.width)\n    return img\n&#125;).then(img &#x3D;&gt; &#123;\n    console.log(img.height)\n&#125;).catch(ex &#x3D;&gt; console.error(ex))\n\n5. 如何用 ajax 原生实现一个 post 请求\n答案\n\nJavaScript\n\nfunction ajax_post(url, data) &#123;\n    &#x2F;&#x2F; 1. 异步对象 ajax\n    var ajax &#x3D; new XMLHttpRequest();\n    \n    &#x2F;&#x2F; 2. url 方法\n    ajax.open(&#39;post&#39;, url);\n    \n    &#x2F;&#x2F; 3. 设置请求报文\n    ajax.setRequestHeader(&#39;Content-type&#39;, &#39;text&#x2F;plain&#39;);\n    \n    &#x2F;&#x2F; 4. 发送\n    if (data) &#123;\n        ajax.send(data);\n    &#125; else &#123;\n        ajax.send();\n    &#125;\n    \n    &#x2F;&#x2F; 5. 注册事件\n    ajax.onreadystatechange &#x3D; function () &#123;\n        if (ajax.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; ajax.status &#x3D;&#x3D;&#x3D; 200) &#123;\n            console.log(ajax.respenseText);\n        &#125;\n    &#125;\n&#125;\n\n6. 每隔一秒输出一个数字\n\n使用 let(推荐)\n使用闭包\n使用第三个参数\n\nfor (let i &#x3D; 0; i &lt; 10; i++) &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n        console.log(i);\n    &#125;, 1000 * i)\n&#125;\n\nfor (var i &#x3D; 0; i &lt; 10; i++) &#123;\n    (function(j) &#123;\n        setTimeout(() &#x3D;&gt; &#123;\n            console.log(j);\n        &#125;, 1000 * j)\n    &#125;)(i)\n&#125;\n\nfor(var i &#x3D; 0; i &lt;&#x3D; 5; i++)&#123;           \n    setTimeout((j) &#x3D;&gt; &#123;                \n        console.log(j);            \n    &#125;,i * 1000, i)        \n&#125;\n\n7. 判断两个对象是否相等\n\n调库\n实现\n\n&#x2F;*\n * @param x &#123;Object&#125; 对象1\n * @param y &#123;Object&#125; 对象2\n * @return  &#123;Boolean&#125; true 为相等，false 为不等\n *&#x2F;\n\nconsole.log(_.isEqual(x, y))\n\n&#x2F;*\n * @param x &#123;Object&#125; 对象1\n * @param y &#123;Object&#125; 对象2\n * @return  &#123;Boolean&#125; true 为相等，false 为不等\n *&#x2F;\n\nconst deepEqual &#x3D; function(x, y) &#123;\n    &#x2F;&#x2F; 指向同一内存时\n    if (x &#x3D;&#x3D;&#x3D; y) &#123;\n        return true;\n    &#125; else if ((typeof x &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; x !&#x3D; null) &amp;&amp; (typeof y &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; y !&#x3D; null)) &#123;\n        if (Object.keys(x).length !&#x3D; Object.keys(y).length) &#123;\n            return false;\n        &#125;\n        for (let prop in x) &#123;\n            if (y.hasOwnProperty(prop)) &#123;\n                if (!deepEqual(x[prop], y[prop])) &#123;\n                    return false;\n                &#125;\n            &#125; else &#123;\n                return false;\n            &#125;\n        &#125; \n        return true;\n    &#125; \n    return false;\n&#125;\n\n实现代码中，以下边界情况无法处理：\n\n其中某个属性本身是一个对象\n某个属性的值为 NaN\n一个对象的属性的值为 undefined，另一个对象中没有这个属性\n\n对于所有边界情况的处理，请参考 Lodash 中的 _.isEqual( ) 源码\n","slug":"「前端面试」 JS 编程题目总结","date":"2022-01-04T03:02:15.000Z","categories_index":"Frontend","tags_index":"面经","author_index":"析构理想"},{"id":"329c2025145e0b6d6215dadb590fe2d6","title":"前端面经总结","content":"一、简历\n简历在找工作过程中是非常非常重要的，无论你是什么途径去面试的，面试你的人一定会看你的简历。\n推荐阅读：如何写「前端简历」，能敲开字节跳动的大门？一份优秀的前端开发工程师简历是怎么样的？\n1、重点\n简历就像高考作文——阅卷时间非常短。\n内容要简洁。\n直击重点，表现出自己的优势（只要是符合招人单位要求的都是优势，不是别人不会的你会才叫优势）。\n\n2、简历包含的内容\n个人信息。\n专业技能。\n工作经历。\n项目经历。\n社区贡献。\n\n2.1 基本信息\n必备：姓名 电话 邮箱。\n年龄（最好写上，在这个行业年龄还是比较重要的），学历（写好是哪一届）。\n头像无所谓（好看就放上呗）。\n可以放 github 链接，前提是有内容。\n\n2.2 专业技能\n表现出自己的核心竞争力（只要是符合招人单位要求的都是优势）。\n内容不要太多，3、5 条即可。\n太基础的不要写，例如会用 vscode、lodash。\n\n2.3 工作经历\n如实写。\n写明公司，职位，入职离职时间即可，多写无益。\n如果有空窗期，如实写明即可。\n\n2.4 项目经历\n写 2-4 个具有说服力的项目（不要什么项目都写，没用）。\n项目名称，项目描述，技术栈，个人角色。\n\n2.5 社区贡献\n有博客或者开源作品，会让你更有竞争力。\n切记：需要真的有内容，不可临时抱佛脚。\n\n3、注意事项\n界面不能太花哨，简洁明了即可。\n注意用词，“精通”“熟练” 等慎用，可用 “熟悉”。\n不可造假，会被拉入黑名单。\n\n4、面试前准备\n看 JD，是否需要临时准备一下。\n打印纸质简历，带着纸和笔（增加好印象）。\n最好带着自己电脑，现场可能手写代码（带一个帆布包最适合，又优雅又方便）。\n要有时间观念，如果迟到或者推迟，要提前说。\n衣着适当，不用正装，也不要太随意。\n为何离职？—— 不要吐槽前东家，说自己的原因（想找一个更好的发展平台等）。\n能加班吗？—— 能！除非你特别自信，能找到其他机会。\n不要挑战面试官，即便他错了（面试一定要保证愉快）。\n遇到不会的问题，要表现出自己积极的一面（不好意思哈，确实是我的知识盲区，可以跟我说下 xxx 吗，我回去研究一下）。\n\n二、HTML+CSS 面试题HTML 和 CSS 面试题答不出来基本可以回去了。\n1、HTML 面试题以下是针对 HTML 相关的面试题，一般来说这地方不会出太多题，面试官也不愿意花太多时间在这上面。\n1.1 如何理解 HTML 语义化？\n让人更容易读懂（增加代码可读性）。\n让搜索引擎更容易读懂，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重（SEO）。\n在没有 CSS 样式下，页面也能呈现出很好地内容结构、代码结构。\n\n1.2 script 标签中 defer 和 async 的区别？\nscript ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。\nasync script ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。\ndefer script：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。\n\n下图清晰地展示了三种 script 的过程： \n\n\n\n\n\n\n\n\n\n推荐文章：\n\n图解 script 标签中的 async 和 defer 属性\n\n1.3 从浏览器地址栏输入 url 到请求返回发生了什么先阅读这篇科普性质的：从 URL 输入到页面展现到底发生什么？ 先阅读篇文章：从输入 URL 开始建立前端知识体系。\n\n输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。\n\n\n强缓存。\n协商缓存。\n\n\nDNS 域名解析。（字节面试被虐后，是时候搞懂 DNS 了）\n\nTCP 连接。\n\n\n\n\n\n\n\n\n\n总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。\n\nhttp 请求。\n\n服务器处理请求并返回 HTTP 报文。\n\n浏览器渲染页面。\n\n\n\n\n断开 TCP 连接。\n\n2、CSS 面试题以下是针对 CSS 相关的面试题，这些题答不出来会给人非常不好的技术印象。\n2.1 盒模型介绍CSS3 中的盒模型有以下两种：标准盒模型、IE（替代）盒模型。\n两种盒子模型都是由 content + padding + border + margin 构成，其大小都是由 content + padding + border 决定的，但是盒子内容宽 &#x2F; 高度（即 width/height）的计算范围根据盒模型的不同会有所不同：\n\n标准盒模型：只包含 content 。\nIE（替代）盒模型：content + padding + border 。\n\n可以通过 box-sizing 来改变元素的盒模型：\n\nbox-sizing: content-box ：标准盒模型（默认值）。\nbox-sizing: border-box ：IE（替代）盒模型。\n\n2.2 css 选择器和优先级首先我们要知道有哪些选择器：选择器参考表。\n常规来说，大家都知道样式的优先级一般为 !important &gt; style &gt; id &gt; class ，但是涉及多类选择器作用于同一个元素时候怎么判断优先级呢？相信我，你在改一些第三方库（比如 antd 😂）样式时，理解这个会帮助很大！\n这篇文章写的非常清晰易懂，强烈推荐，看完之后就没啥问题了：深入理解 CSS 选择器优先级。\n\n\n\n\n\n\n\n\n\n上述文章中核心内容： 优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：\n\n如果存在内联样式，那么 A = 1，否则 A = 0 ；\nB 的值等于 ID选择器（#id） 出现的次数；\nC 的值等于 类选择器（.class） 和 属性选择器（a[href=&quot;https://example.org&quot;]） 和 伪类（:first-child） 出现的总次数；\nD 的值等于 标签选择器（h1,a,div） 和 伪元素（::before,::after） 出现的总次数。\n\n\n\n\n\n\n\n\n\n\n从左至右比较，如果是样式优先级相等，取后面出现的样式。\n2.3 重排（reflow）和重绘（repaint）的理解简单地总结下两者的概念：\n\n重排：无论通过什么方式影响了元素的几何信息 (元素在视口内的位置和尺寸大小)，浏览器需要重新计算元素在视口内的几何属性，这个过程叫做重排。\n重绘：通过构造渲染树和重排（回流）阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息 (元素在视口内的位置和尺寸大小)，接下来就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘。\n\n如何减少重排和重绘？\n\n最小化重绘和重排，比如样式集中改变，使用添加新样式类名 .class 或 cssText 。\n批量操作 DOM，比如读取某元素 offsetWidth 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 document.createDocumentFragment() 来添加要被添加的节点，处理完之后再插入到实际 DOM 中。\n使用 **absolute** 或 **fixed** 使元素脱离文档流，这在制作复杂的动画时对性能的影响比较明显。\n开启 GPU 加速，利用 css 属性 transform 、will-change 等，比如改变元素位置，我们使用 translate 会比使用绝对定位改变其 left 、top 等来的高效，因为它不会触发重排或重绘，transform 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。\n\n这里推荐腾讯 IVWEB 团队的这篇文章：你真的了解回流和重绘吗，好好认真看完，面试应该没问题的。\n2.4 对 BFC 的理解BFC 即块级格式上下文，根据盒模型可知，每个元素都被定义为一个矩形盒子，然而盒子的布局会受到尺寸，定位，盒子的子元素或兄弟元素，视口的尺寸等因素决定，所以这里有一个浏览器计算的过程，计算的规则就是由一个叫做视觉格式化模型的东西所定义的，BFC 就是来自这个概念，它是 CSS 视觉渲染的一部分，用于决定块级盒的布局及浮动相互影响范围的一个区域。\nBFC 具有一些特性：\n\n块级元素会在垂直方向一个接一个的排列，和文档流的排列方式一致。\n在 BFC 中上下相邻的两个容器的 margin  会重叠，创建新的 BFC 可以避免外边距重叠。\n计算 BFC 的高度时，需要计算浮动元素的高度。\nBFC 区域不会与浮动的容器发生重叠。\nBFC 是独立的容器，容器内部元素不会影响外部元素。\n每个元素的左 margin  值和容器的左 border  相接触。\n\n利用这些特性，我们可以解决以下问题：\n\n利用 4  和 6 ，我们可以实现三栏（或两栏）自适应布局。\n利用 2 ，我们可以避免 margin  重叠问题。\n利用 3 ，我们可以避免高度塌陷。\n\n创建 BFC 的方式：\n\n绝对定位元素（position 为 absolute 或 fixed ）。\n行内块元素，即 display 为 inline-block 。\noverflow 的值不为 visible 。\n\n推荐文章：可能是最好的 BFC 解析了…\n2.5 实现两栏布局（左侧固定 + 右侧自适应布局）现在有以下 DOM 结构：\n&lt;div class&#x3D;&quot;outer&quot;&gt;\n  &lt;div class&#x3D;&quot;left&quot;&gt;左侧&lt;&#x2F;div&gt;\n  &lt;div class&#x3D;&quot;right&quot;&gt;右侧&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n复制代码\n\n\n利用浮动，左边元素宽度固定 ，设置向左浮动。将右边元素的 margin-left 设为固定宽度 。注意，因为右边元素的 width 默认为 auto ，所以会自动撑满父元素。\n\n.outer &#123;\n  height: 100px;\n&#125;\n.left &#123;\n  float: left;\n  width: 200px;\n  height: 100%;\n  background: lightcoral;\n&#125;\n.right &#123;\n  margin-left: 200px;\n  height: 100%;\n  background: lightseagreen;\n&#125;\n复制代码\n\n\n同样利用浮动，左边元素宽度固定 ，设置向左浮动。右侧元素设置 overflow: hidden; 这样右边就触发了 BFC ，BFC 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。\n\n.outer &#123;\n  height: 100px;\n&#125;\n.left &#123;\n  float: left;\n  width: 200px;\n  height: 100%;\n  background: lightcoral;\n&#125;\n.right &#123;\n  overflow: auto;\n  height: 100%;\n  background: lightseagreen;\n&#125;\n复制代码\n\n\n利用 flex 布局，左边元素固定宽度，右边的元素设置 flex: 1 。\n\n.outer &#123;\n  display: flex;\n  height: 100px;\n&#125;\n.left &#123;\n  width: 200px;\n  height: 100%;\n  background: lightcoral;\n&#125;\n.right &#123;\n  flex: 1;\n  height: 100%;\n  background: lightseagreen;\n&#125;\n复制代码\n\n\n利用绝对定位，父级元素设为相对定位。左边元素 absolute  定位，宽度固定。右边元素的 margin-left  的值设为左边元素的宽度值。\n\n.outer &#123;\n  position: relative;\n  height: 100px;\n&#125;\n.left &#123;\n  position: absolute;\n  width: 200px;\n  height: 100%;\n  background: lightcoral;\n&#125;\n.right &#123;\n  margin-left: 200px;\n  height: 100%;\n  background: lightseagreen;\n&#125;\n复制代码\n\n\n利用绝对定位，父级元素设为相对定位。左边元素宽度固定，右边元素 absolute  定位， left  为宽度大小，其余方向定位为 0 。\n\n.outer &#123;\n  position: relative;\n  height: 100px;\n&#125;\n.left &#123;\n  width: 200px;\n  height: 100%;\n  background: lightcoral;\n&#125;\n.right &#123;\n  position: absolute;\n  left: 200px;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  height: 100%;\n  background: lightseagreen;\n&#125;\n复制代码\n\n2.6 实现圣杯布局和双飞翼布局（经典三分栏布局）圣杯布局和双飞翼布局的目的：\n\n三栏布局，中间一栏最先加载和渲染（内容最重要，这就是为什么还需要了解这种布局的原因）。\n两侧内容固定，中间内容随着宽度自适应。\n一般用于 PC 网页。\n\n圣杯布局和双飞翼布局的技术总结：\n\n使用 float  布局。\n两侧使用 margin 负值，以便和中间内容横向重叠。\n防止中间内容被两侧覆盖，圣杯布局用 padding ，双飞翼布局用 margin 。\n\n圣杯布局： HTML 结构：\n&lt;div id&#x3D;&quot;container&quot; class&#x3D;&quot;clearfix&quot;&gt;\n  &lt;p class&#x3D;&quot;center&quot;&gt;我是中间&lt;&#x2F;p&gt;\n  &lt;p class&#x3D;&quot;left&quot;&gt;我是左边&lt;&#x2F;p&gt;\n  &lt;p class&#x3D;&quot;right&quot;&gt;我是右边&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n复制代码\n\nCSS 样式：\n#container &#123;\n  padding-left: 200px;\n  padding-right: 150px;\n  overflow: auto;\n&#125;\n#container p &#123;\n  float: left;\n&#125;\n.center &#123;\n  width: 100%;\n  background-color: lightcoral;\n&#125;\n.left &#123;\n  width: 200px;\n  position: relative;\n  left: -200px;\n  margin-left: -100%;\n  background-color: lightcyan;\n&#125;\n.right &#123;\n  width: 150px;\n  margin-right: -150px;\n  background-color: lightgreen;\n&#125;\n.clearfix:after &#123;\n  content: &quot;&quot;;\n  display: table;\n  clear: both;\n&#125;\n复制代码\n\n双飞翼布局： HTML 结构：\n&lt;div id&#x3D;&quot;main&quot; class&#x3D;&quot;float&quot;&gt;\n  &lt;div id&#x3D;&quot;main-wrap&quot;&gt;main&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\n&lt;div id&#x3D;&quot;left&quot; class&#x3D;&quot;float&quot;&gt;left&lt;&#x2F;div&gt;\n&lt;div id&#x3D;&quot;right&quot; class&#x3D;&quot;float&quot;&gt;right&lt;&#x2F;div&gt;\n复制代码\n\nCSS 样式：\n.float &#123;\n  float: left;\n&#125;\n#main &#123;\n  width: 100%;\n  height: 200px;\n  background-color: lightpink;\n&#125;\n#main-wrap &#123;\n  margin: 0 190px 0 190px;\n&#125;\n#left &#123;\n  width: 190px;\n  height: 200px;\n  background-color: lightsalmon;\n  margin-left: -100%;\n&#125;\n#right &#123;\n  width: 190px;\n  height: 200px;\n  background-color: lightskyblue;\n  margin-left: -190px;\n&#125;\n复制代码\n\ntips：上述代码中 margin-left: -100%  相对的是父元素的 content  宽度，即不包含 paddig 、 border  的宽度。\n其实以上问题需要掌握 margin 负值问题 即可很好理解。\n2.7 水平垂直居中多种实现方式\n利用绝对定位，设置 left: 50%  和 top: 50%  现将子元素左上角移到父元素中心位置，然后再通过 translate  来调整子元素的中心点到父元素的中心。该方法可以不定宽高。\n\n.father &#123;\n  position: relative;\n&#125;\n.son &#123;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n&#125;\n复制代码\n\n\n利用绝对定位，子元素所有方向都为 0 ，将 margin  设置为 auto ，由于宽高固定，对应方向实现平分，该方法必须盒子有宽高。\n\n.father &#123;\n  position: relative;\n&#125;\n.son &#123;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0px;\n  margin: auto;\n  height: 100px;\n  width: 100px;\n&#125;\n复制代码\n\n\n利用绝对定位，设置 left: 50% 和 top: 50% 现将子元素左上角移到父元素中心位置，然后再通过 margin-left  和 margin-top  以子元素自己的一半宽高进行负值赋值。该方法必须定宽高。\n\n.father &#123;\n  position: relative;\n&#125;\n.son &#123;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  width: 200px;\n  height: 200px;\n  margin-left: -100px;\n  margin-top: -100px;\n&#125;\n复制代码\n\n\n利用 flex ，最经典最方便的一种了，不用解释，定不定宽高无所谓的。\n\n.father &#123;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n&#125;\n复制代码\n\n其实还有很多方法，比如 display: grid  或 display: table-cell  来做，有兴趣点击下面这篇文章可以了解下：面试官：你能实现多少种水平垂直居中的布局（定宽高和不定宽高）。\n2.8 flex 布局这一块内容看 Flex 布局教程 就够了。\n这里有个小问题，很多时候我们会用到 flex: 1 ，它具体包含了以下的意思：\n\nflex-grow: 1 ：该属性默认为 0 ，如果存在剩余空间，元素也不放大。设置为 1  代表会放大。\nflex-shrink: 1 ：该属性默认为 1 ，如果空间不足，元素缩小。\nflex-basis: 0% ：该属性定义在分配多余空间之前，元素占据的主轴空间。浏览器就是根据这个属性来计算是否有多余空间的。默认值为 auto ，即项目本身大小。设置为 0%  之后，因为有 flex-grow  和 flex-shrink  的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 flex-basis  设为 auto  的话，其本身大小将会是 0 。\n\n2.9 line-height 如何继承？\n父元素的 line-height 写了具体数值，比如 30px，则子元素 line-height 继承该值。\n父元素的 line-height 写了比例，比如 1.5 或 2，则子元素 line-height 也是继承该比例。\n父元素的 line-height 写了百分比，比如 200%，则子元素 line-height 继承的是父元素 font-size * 200% 计算出来的值。\n\n三、js 基础js 的考察其实来回就那些东西，不过就我自己而已学习的时候理解是真的理解了，但是忘也确实会忘（大家都说理解了一定不会忘，但是要答全的话还是需要理解 + 背）。\n1、数据类型以下是比较重要的几个 js 变量要掌握的点。\n1.1 基本的数据类型介绍，及值类型和引用类型的理解在 JS 中共有 8  种基础的数据类型，分别为： Undefined 、 Null 、 Boolean 、 Number 、 String 、 Object 、 Symbol 、 BigInt 。\n其中 Symbol  和 BigInt  是 ES6 新增的数据类型，可能会被单独问：\n\nSymbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。\nBigInt 可以表示任意大小的整数。\n\n值类型的赋值变动过程如下：\nlet a &#x3D; 100;\nlet b &#x3D; a;\na &#x3D; 200;\nconsole.log(b); &#x2F;&#x2F; 200\n复制代码\n\n 值类型是直接存储在 ** 栈（stack）** 中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n引用类型的赋值变动过程如下：\nlet a &#x3D; &#123; age: 20 &#125;;\nlet b &#x3D; a;\nb.age &#x3D; 30;\nconsole.log(a.age); &#x2F;&#x2F; 30\n复制代码\n\n 引用类型存储在 ** 堆（heap）** 中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；\n1.2 数据类型的判断\ntypeof：能判断所有值类型，函数。不可对 null、对象、数组进行精确判断，因为都返回 object 。\n\nconsole.log(typeof undefined); &#x2F;&#x2F; undefined\nconsole.log(typeof 2); &#x2F;&#x2F; number\nconsole.log(typeof true); &#x2F;&#x2F; boolean\nconsole.log(typeof &quot;str&quot;); &#x2F;&#x2F; string\nconsole.log(typeof Symbol(&quot;foo&quot;)); &#x2F;&#x2F; symbol\nconsole.log(typeof 2172141653n); &#x2F;&#x2F; bigint\nconsole.log(typeof function () &#123;&#125;); &#x2F;&#x2F; function\n&#x2F;&#x2F; 不能判别\nconsole.log(typeof []); &#x2F;&#x2F; object\nconsole.log(typeof &#123;&#125;); &#x2F;&#x2F; object\nconsole.log(typeof null); &#x2F;&#x2F; object\n复制代码\n\n\ninstanceof：能判断对象类型，不能判断基本数据类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。比如考虑以下代码：\n\nclass People &#123;&#125;\nclass Student extends People &#123;&#125;\n\nconst vortesnail &#x3D; new Student();\n\nconsole.log(vortesnail instanceof People); &#x2F;&#x2F; true\nconsole.log(vortesnail instanceof Student); &#x2F;&#x2F; true\n复制代码\n\n其实现就是顺着原型链去找，如果能找到对应的 Xxxxx.prototype  即为 true 。比如这里的 vortesnail  作为实例，顺着原型链能找到 Student.prototype  及 People.prototype ，所以都为 true 。\n\n**Object.prototype.toString.call()**：所有原始数据类型都是能判断的，还有 Error 对象，Date 对象等。\n\nObject.prototype.toString.call(2); &#x2F;&#x2F; &quot;[object Number]&quot;\nObject.prototype.toString.call(&quot;&quot;); &#x2F;&#x2F; &quot;[object String]&quot;\nObject.prototype.toString.call(true); &#x2F;&#x2F; &quot;[object Boolean]&quot;\nObject.prototype.toString.call(undefined); &#x2F;&#x2F; &quot;[object Undefined]&quot;\nObject.prototype.toString.call(null); &#x2F;&#x2F; &quot;[object Null]&quot;\nObject.prototype.toString.call(Math); &#x2F;&#x2F; &quot;[object Math]&quot;\nObject.prototype.toString.call(&#123;&#125;); &#x2F;&#x2F; &quot;[object Object]&quot;\nObject.prototype.toString.call([]); &#x2F;&#x2F; &quot;[object Array]&quot;\nObject.prototype.toString.call(function () &#123;&#125;); &#x2F;&#x2F; &quot;[object Function]&quot;\n复制代码\n\n在面试中有一个经常被问的问题就是：如何判断变量是否为数组？\nArray.isArray(arr); &#x2F;&#x2F; true\narr.__proto__ &#x3D;&#x3D;&#x3D; Array.prototype; &#x2F;&#x2F; true\narr instanceof Array; &#x2F;&#x2F; true\nObject.prototype.toString.call(arr); &#x2F;&#x2F; &quot;[object Array]&quot;\n复制代码\n\n1.3 手写深拷贝这个题一定要会啊！笔者面试过程中疯狂被问到！\n文章推荐：如何写出一个惊艳面试官的深拷贝?\n&#x2F;**\n * 深拷贝\n * @param &#123;Object&#125; obj 要拷贝的对象\n * @param &#123;Map&#125; map 用于存储循环引用对象的地址\n *&#x2F;\n\nfunction deepClone(obj &#x3D; &#123;&#125;, map &#x3D; new Map()) &#123;\n  if (typeof obj !&#x3D;&#x3D; &quot;object&quot;) &#123;\n    return obj;\n  &#125;\n  if (map.get(obj)) &#123;\n    return map.get(obj);\n  &#125;\n\n  let result &#x3D; &#123;&#125;;\n  &#x2F;&#x2F; 初始化返回结果\n  if (\n    obj instanceof Array ||\n    &#x2F;&#x2F; 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此\n    Object.prototype.toString(obj) &#x3D;&#x3D;&#x3D; &quot;[object Array]&quot;\n  ) &#123;\n    result &#x3D; [];\n  &#125;\n  &#x2F;&#x2F; 防止循环引用\n  map.set(obj, result);\n  for (const key in obj) &#123;\n    &#x2F;&#x2F; 保证 key 不是原型属性\n    if (obj.hasOwnProperty(key)) &#123;\n      &#x2F;&#x2F; 递归调用\n      result[key] &#x3D; deepClone(obj[key], map);\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 返回结果\n  return result;\n&#125;\n复制代码\n\n1.4 根据 0.1+0.2 ! &#x3D;&#x3D; 0.3，讲讲 IEEE 754 ，如何让其相等？建议先阅读这篇文章了解 IEEE 754 ：硬核基础二进制篇（一）0.1 + 0.2 !&#x3D; 0.3 和 IEEE-754 标准。 再阅读这篇文章了解如何运算：0.1 + 0.2 不等于 0.3？为什么 JavaScript 有这种 “骚” 操作？。 \n原因总结：\n\n进制转换 ：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环 ，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。\n对阶运算 ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0舍1入），尾数位移时可能会发生数丢失的情况，影响精度。\n\n解决办法：\n\n转为整数（大数）运算。\n\nfunction add(a, b) &#123;\n  const maxLen &#x3D; Math.max(\n    a.toString().split(&quot;.&quot;)[1].length,\n    b.toString().split(&quot;.&quot;)[1].length\n  );\n  const base &#x3D; 10 ** maxLen;\n  const bigA &#x3D; BigInt(base * a);\n  const bigB &#x3D; BigInt(base * b);\n  const bigRes &#x3D; (bigA + bigB) &#x2F; BigInt(base); &#x2F;&#x2F; 如果是 (1n + 2n) &#x2F; 10n 是等于 0n的。。。\n  return Number(bigRes);\n&#125;\n复制代码\n\n这里代码是有问题的，因为最后计算 bigRes 的大数相除（即 /）是会把小数部分截掉的，所以我很疑惑为什么网络上很多文章都说可以通过先转为整数运算再除回去，为了防止转为的整数超出 js 表示范围，还可以运用到 ES6 新增的大数类型，我真的很疑惑，希望有好心人能解答下。\n\n使用 Number.EPSILON 误差范围。\n\nfunction isEqual(a, b) &#123;\n  return Math.abs(a - b) &lt; Number.EPSILON;\n&#125;\n\nconsole.log(isEqual(0.1 + 0.2, 0.3)); &#x2F;&#x2F; true\n复制代码\n\nNumber.EPSILON 的实质是一个可以接受的最小误差范围，一般来说为 Math.pow(2, -52) 。 \n\n转成字符串，对字符串做加法运算。\n\n&#x2F;&#x2F; 字符串数字相加\nvar addStrings &#x3D; function (num1, num2) &#123;\n  let i &#x3D; num1.length - 1;\n  let j &#x3D; num2.length - 1;\n  const res &#x3D; [];\n  let carry &#x3D; 0;\n  while (i &gt;&#x3D; 0 || j &gt;&#x3D; 0) &#123;\n    const n1 &#x3D; i &gt;&#x3D; 0 ? Number(num1[i]) : 0;\n    const n2 &#x3D; j &gt;&#x3D; 0 ? Number(num2[j]) : 0;\n    const sum &#x3D; n1 + n2 + carry;\n    res.unshift(sum % 10);\n    carry &#x3D; Math.floor(sum &#x2F; 10);\n    i--;\n    j--;\n  &#125;\n  if (carry) &#123;\n    res.unshift(carry);\n  &#125;\n  return res.join(&quot;&quot;);\n&#125;;\n\nfunction isEqual(a, b, sum) &#123;\n  const [intStr1, deciStr1] &#x3D; a.toString().split(&quot;.&quot;);\n  const [intStr2, deciStr2] &#x3D; b.toString().split(&quot;.&quot;);\n  const inteSum &#x3D; addStrings(intStr1, intStr2); &#x2F;&#x2F; 获取整数相加部分\n  const deciSum &#x3D; addStrings(deciStr1, deciStr2); &#x2F;&#x2F; 获取小数相加部分\n  return inteSum + &quot;.&quot; + deciSum &#x3D;&#x3D;&#x3D; String(sum);\n&#125;\n\nconsole.log(isEqual(0.1, 0.2, 0.3)); &#x2F;&#x2F; true\n复制代码\n\n这是 leetcode 上一道原题：415. 字符串相加。区别在于原题没有考虑小数，但是也是很简单的，我们分为两个部分计算就行。\n2、 原型和原型链可以说这部分每家面试官都会问了。。首先理解的话，其实一张图即可，一段代码即可。\nfunction Foo() &#123;&#125;\n\nlet f1 &#x3D; new Foo();\nlet f2 &#x3D; new Foo();\n复制代码\n\n千万别畏惧下面这张图，特别有用，一定要搞懂，熟到提笔就能默画出来。 \n总结：\n\n原型：每一个 JavaScript 对象（null 除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型 “继承” 属性，其实就是 prototype 对象。\n原型链：由相互关联的原型组成的链状结构就是原型链。\n\n先说出总结的话，再举例子说明如何顺着原型链找到某个属性。\n推荐的阅读：JavaScript 深入之从原型到原型链 掌握基本概念，再阅读这篇文章轻松理解 JS 原型原型链加深上图的印象。\n3、 作用域与作用域链\n作用域：规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。换句话说，作用域决定了代码区块中变量和其他资源的可见性。（全局作用域、函数作用域、块级作用域）\n作用域链：从当前作用域开始一层层往上找某个变量，如果找到全局作用域还没找到，就放弃寻找 。这种层级关系就是作用域链。（由多个执行上下文的变量对象构成的链表就叫做作用域链，学习下面的内容之后再考虑这句话）\n\n需要注意的是，js 采用的是静态作用域，所以函数的作用域在函数定义时就确定了。\n推荐阅读：先阅读 JavaScript 深入之词法作用域和动态作用域，再阅读深入理解 JavaScript 作用域和作用域链。 \n4、 执行上下文这部分一定要按顺序连续读这几篇文章，必须多读几遍：\n\nJavaScript 深入之执行上下文栈；\nJavaScript 深入之变量对象；\nJavaScript 深入之作用域链；\nJavaScript 深入之执行上下文。\n\n总结：当 JavaScript 代码执行一段可执行代码时，会创建对应的执行上下文。对于每个执行上下文，都有三个重要属性：\n\n变量对象（Variable object，VO）；\n作用域链（Scope chain）；\nthis。（关于 this 指向问题，在上面推荐的深入系列也有讲从 ES 规范讲的，但是实在是难懂，对于应付面试来说以下这篇阮一峰的文章应该就可以了：JavaScript 的 this 原理）\n\n5、 闭包根据 MDN 中文的定义，闭包的定义如下：\n\n\n\n\n\n\n\n\n\n在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。可以在一个内层函数中访问到其外层函数的作用域。\n也可以这样说：\n\n\n\n\n\n\n\n\n\n闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 闭包 &#x3D; 函数 + 函数能够访问的自由变量。\n在经过上一小节 “执行上下文” 的学习，再来阅读这篇文章：JavaScript 深入之闭包，你会对闭包的实质有一定的了解。在回答时，我们这样答：\n在某个内部函数的执行上下文创建时，会将父级函数的活动对象加到内部函数的 [[scope]] 中，形成作用域链，所以即使父级函数的执行上下文销毁（即执行上下文栈弹出父级函数的执行上下文），但是因为其活动对象还是实际存储在内存中可被内部函数访问到的，从而实现了闭包。\n闭包应用： 函数作为参数被传递：\nfunction print(fn) &#123;\n  const a &#x3D; 200;\n  fn();\n&#125;\n\nconst a &#x3D; 100;\nfunction fn() &#123;\n  console.log(a);\n&#125;\n\nprint(fn); &#x2F;&#x2F; 100\n复制代码\n\n函数作为返回值被返回：\nfunction create() &#123;\n  const a &#x3D; 100;\n\n  return function () &#123;\n    console.log(a);\n  &#125;;\n&#125;\n\nconst fn &#x3D; create();\nconst a &#x3D; 200;\nfn(); &#x2F;&#x2F; 100\n复制代码\n\n闭包：自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在执行的地方。 ****\n应用实例：比如缓存工具，隐藏数据，只提供 API 。\nfunction createCache() &#123;\n  const data &#x3D; &#123;&#125;; &#x2F;&#x2F; 闭包中被隐藏的数据，不被外界访问\n  return &#123;\n    set: function (key, val) &#123;\n      data[key] &#x3D; val;\n    &#125;,\n    get: function (key) &#123;\n      return data[key];\n    &#125;,\n  &#125;;\n&#125;\n\nconst c &#x3D; createCache();\nc.set(&quot;a&quot;, 100);\nconsole.log(c.get(&quot;a&quot;)); &#x2F;&#x2F; 100\n复制代码\n\n6、 call、apply、bind 实现这部分实现还是要知道的，就算工作中不会自己手写，但是说不准面试官就是要问，知道点原理也好，可以扩宽我们写代码的思路。\ncall\n\n\n\n\n\n\n\n\n\ncall() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。\n举个例子：\nvar obj &#x3D; &#123;\n  value: &quot;vortesnail&quot;,\n&#125;;\n\nfunction fn() &#123;\n  console.log(this.value);\n&#125;\n\nfn.call(obj); &#x2F;&#x2F; vortesnail\n复制代码\n\n通过 call 方法我们做到了以下两点：\n\ncall 改变了 this 的指向，指向到 obj 。\nfn 函数执行了。\n\n那么如果我们自己写 call 方法的话，可以怎么做呢？我们先考虑改造 obj 。\nvar obj &#x3D; &#123;\n  value: &quot;vortesnail&quot;,\n  fn: function () &#123;\n    console.log(this.value);\n  &#125;,\n&#125;;\n\nobj.fn(); &#x2F;&#x2F; vortesnail\n复制代码\n\n这时候 this 就指向了 obj ，但是这样做我们手动给 obj 增加了一个 fn 属性，这显然是不行的，不用担心，我们执行完再使用对象属性的删除方法（delete）不就行了？\nobj.fn &#x3D; fn;\nobj.fn();\ndelete obj.fn;\n复制代码\n\n根据这个思路，我们就可以写出来了：\nFunction.prototype.myCall &#x3D; function (context) &#123;\n  &#x2F;&#x2F; 判断调用对象\n  if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;\n    throw new Error(&quot;Type error&quot;);\n  &#125;\n  &#x2F;&#x2F; 首先获取参数\n  let args &#x3D; [...arguments].slice(1);\n  let result &#x3D; null;\n  &#x2F;&#x2F; 判断 context 是否传入，如果没有传就设置为 window\n  context &#x3D; context || window;\n  &#x2F;&#x2F; 将被调用的方法设置为 context 的属性\n  &#x2F;&#x2F; this 即为我们要调用的方法\n  context.fn &#x3D; this;\n  &#x2F;&#x2F; 执行要被调用的方法\n  result &#x3D; context.fn(...args);\n  &#x2F;&#x2F; 删除手动增加的属性方法\n  delete context.fn;\n  &#x2F;&#x2F; 将执行结果返回\n  return result;\n&#125;;\n复制代码\n\napply\n我们会了 call 的实现之后，apply 就变得很简单了，他们没有任何区别，除了传参方式。\nFunction.prototype.myApply &#x3D; function (context) &#123;\n  if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;\n    throw new Error(&quot;Type error&quot;);\n  &#125;\n  let result &#x3D; null;\n  context &#x3D; context || window;\n  &#x2F;&#x2F; 与上面代码相比，我们使用 Symbol 来保证属性唯一\n  &#x2F;&#x2F; 也就是保证不会重写用户自己原来定义在 context 中的同名属性\n  const fnSymbol &#x3D; Symbol();\n  context[fnSymbol] &#x3D; this;\n  &#x2F;&#x2F; 执行要被调用的方法\n  if (arguments[1]) &#123;\n    result &#x3D; context[fnSymbol](...arguments[1]);\n  &#125; else &#123;\n    result &#x3D; context[fnSymbol]();\n  &#125;\n  delete context[fnSymbol];\n  return result;\n&#125;;\n复制代码\n\nbind\nbind 返回的是一个函数，这个地方可以详细阅读这篇文章，讲的非常清楚：解析 bind 原理，并手写 bind 实现。\nFunction.prototype.myBind &#x3D; function (context) &#123;\n  &#x2F;&#x2F; 判断调用对象是否为函数\n  if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;\n    throw new Error(&quot;Type error&quot;);\n  &#125;\n  &#x2F;&#x2F; 获取参数\n  const args &#x3D; [...arguments].slice(1),\n  const fn &#x3D; this;\n  return function Fn() &#123;\n    return fn.apply(\n      this instanceof Fn ? this : context,\n      &#x2F;&#x2F; 当前的这个 arguments 是指 Fn 的参数\n      args.concat(...arguments)\n    );\n  &#125;;\n&#125;;\n复制代码\n\n7、 new 实现\n首先创一个新的空对象。\n根据原型链，设置空对象的 __proto__ 为构造函数的 prototype 。\n构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。\n判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象。\n\nfunction myNew(context) &#123;\n  const obj &#x3D; new Object();\n  obj.__proto__ &#x3D; context.prototype;\n  const res &#x3D; context.apply(obj, [...arguments].slice(1));\n  return typeof res &#x3D;&#x3D;&#x3D; &quot;object&quot; ? res : obj;\n&#125;\n复制代码\n\n8、 异步这部分着重要理解 Promise、async awiat、event loop 等。\n8.1 event loop、宏任务和微任务首先推荐一个可以在线看代码流程的网站：loupe。 然后看下这个视频学习下：到底什么是 Event Loop 呢？\n简单的例子：\nconsole.log(&quot;Hi&quot;);\n\nsetTimeout(function cb() &#123;\n  console.log(&quot;cb&quot;); &#x2F;&#x2F; cb 即 callback\n&#125;, 5000);\n\nconsole.log(&quot;Bye&quot;);\n复制代码\n\n它的执行过程是这样的：  Web APIs 会创建对应的线程，比如 setTimeout 会创建定时器线程，ajax 请求会创建 http 线程。。。这是由 js 的运行环境决定的，比如浏览器。\n看完上面的视频之后，至少大家画 Event Loop 的图讲解不是啥问题了，但是涉及到宏任务和微任务，我们还得拜读一下这篇文章：这一次，彻底弄懂 JavaScript 执行机制。如果意犹未尽，不如再读下这篇非常详细带有大量动图的文章：做一些动图，学习一下 EventLoop。想了解事件循环和页面渲染之间关系的又可以再阅读这篇文章：深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调（动图演示）。\n注意：1.Call Stack 调用栈空闲 -&gt; 2. 尝试 DOM 渲染 -&gt; 触发 Event loop。\n\n每次 Call Stack 清空（即每次轮询结束），即同步任务执行完。\n都是 DOM 重新渲染的机会，DOM 结构有改变则重新渲染。\n然后再去触发下一次 Event loop。\n\n宏任务：setTimeout，setInterval，Ajax，DOM 事件。 微任务：Promise async&#x2F;await。\n两者区别：\n\n宏任务：DOM 渲染后触发，如 setTimeout 、setInterval 、DOM 事件 、script 。\n微任务：DOM 渲染前触发，如 Promise.then 、MutationObserver 、Node 环境下的 process.nextTick 。\n\n从 event loop 解释，为何微任务执行更早？\n\n微任务是 ES6 语法规定的（被压入 micro task queue）。\n宏任务是由浏览器规定的（通过 Web APIs 压入 Callback queue）。\n宏任务执行时间一般比较长。\n每一次宏任务开始之前一定是伴随着一次 event loop 结束的，而微任务是在一次 event loop 结束前执行的。\n\n8.2 Promise关于这一块儿没什么好说的，最好是实现一遍 Promise A+ 规范，多少有点印象，当然面试官也不会叫你默写一个完整的出来，但是你起码要知道实现原理。\n\n\n\n\n\n\n\n\n\n关于 Promise 的所有使用方式，可参照这篇文章：ECMAScript 6 入门 - Promise 对象。 手写 Promise 源码的解析文章，可阅读此篇文章：从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节。 关于 Promise 的面试题，可参考这篇文章：要就来 45 道 Promise 面试题一次爽到底。\n实现一个 Promise.all：\nPromise.all &#x3D; function (promises) &#123;\n  return new Promise((resolve, reject) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 参数可以不是数组，但必须具有 Iterator 接口\n    if (typeof promises[Symbol.iterator] !&#x3D;&#x3D; &quot;function&quot;) &#123;\n      reject(&quot;Type error&quot;);\n    &#125;\n    if (promises.length &#x3D;&#x3D;&#x3D; 0) &#123;\n      resolve([]);\n    &#125; else &#123;\n      const res &#x3D; [];\n      let count &#x3D; 0;\n      const len &#x3D; promises.length;\n      for (let i &#x3D; 0; i &lt; len; i++) &#123;\n        &#x2F;&#x2F;考虑到 promises[i] 可能是 thenable 对象也可能是普通值\n        Promise.resolve(promises[i])\n          .then((data) &#x3D;&gt; &#123;\n            res[i] &#x3D; data;\n            if (++count &#x3D;&#x3D;&#x3D; len) &#123;\n              resolve(res);\n            &#125;\n          &#125;)\n          .catch((err) &#x3D;&gt; &#123;\n            reject(err);\n          &#125;);\n      &#125;\n    &#125;\n  &#125;);\n&#125;;\n复制代码\n\n8.3 async&#x2F;await 和 Promise 的关系\nasync&#x2F;await 是消灭异步回调的终极武器。\n但和 Promise 并不互斥，反而，两者相辅相成。\n执行 async 函数，返回的一定是 Promise 对象。\nawait 相当于 Promise 的 then。\ntru…catch 可捕获异常，代替了 Promise 的 catch。\n\n9、 浏览器的垃圾回收机制这里看这篇文章即可：「硬核 JS」你真的了解垃圾回收机制吗。\n总结一下：\n有两种垃圾回收策略：\n\n标记清除：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。\n引用计数：它把对象是否不再需要简化定义为对象有没有其他对象引用到它。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。\n\n标记清除的缺点：\n\n内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。\n分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。\n\n解决以上的缺点可以使用 ** 标记整理（Mark-Compact）算法 **，标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图） \n引用计数的缺点：\n\n需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。\n解决不了循环引用导致的无法回收问题。\n\nV8 的垃圾回收机制也是基于标记清除算法，不过对其做了一些优化。\n\n针对新生区采用并行回收。\n针对老生区采用增量标记与惰性回收。\n\n10、 实现一个 EventMitter 类EventMitter 就是发布订阅模式的典型应用：\nexport class EventEmitter &#123;\n  private _events: Record&lt;string, Array&lt;Function&gt;&gt;;\n\n  constructor() &#123;\n    this._events &#x3D; Object.create(null);\n  &#125;\n\n  emit(evt: string, ...args: any[]) &#123;\n    if (!this._events[evt]) return false;\n\n    const fns &#x3D; [...this._events[evt]];\n    fns.forEach((fn) &#x3D;&gt; &#123;\n      fn.apply(this, args);\n    &#125;);\n\n    return true;\n  &#125;\n\n  on(evt: string, fn: Function) &#123;\n    if (typeof fn !&#x3D;&#x3D; &quot;function&quot;) &#123;\n      throw new TypeError(&quot;The evet-triggered callback must be a function&quot;);\n    &#125;\n    if (!this._events[evt]) &#123;\n      this._events[evt] &#x3D; [fn];\n    &#125; else &#123;\n      this._events[evt].push(fn);\n    &#125;\n  &#125;\n\n  once(evt: string, fn: Function) &#123;\n    const execFn &#x3D; () &#x3D;&gt; &#123;\n      fn.apply(this);\n      this.off(evt, execFn);\n    &#125;;\n    this.on(evt, execFn);\n  &#125;\n\n  off(evt: string, fn?: Function) &#123;\n    if (!this._events[evt]) return;\n    if (!fn) &#123;\n      this._events[evt] &amp;&amp; (this._events[evt].length &#x3D; 0);\n    &#125;\n\n    let cb;\n    const cbLen &#x3D; this._events[evt].length;\n    for (let i &#x3D; 0; i &lt; cbLen; i++) &#123;\n      cb &#x3D; this._events[evt][i];\n      if (cb &#x3D;&#x3D;&#x3D; fn) &#123;\n        this._events[evt].splice(i, 1);\n        break;\n      &#125;\n    &#125;\n  &#125;\n\n  removeAllListeners(evt?: string) &#123;\n    if (evt) &#123;\n      this._events[evt] &amp;&amp; (this._events[evt].length &#x3D; 0);\n    &#125; else &#123;\n      this._events &#x3D; Object.create(null);\n    &#125;\n  &#125;\n&#125;\n复制代码\n\n四、web 存储要掌握 cookie，localStorage 和 sessionStorage。\n1、cookie\n本身用于浏览器和 server 通讯。\n被 “借用” 到本地存储来的。\n可用 document.cookie &#x3D; ‘…’ 来修改。\n\n其缺点：\n\n存储大小限制为 4KB。\nhttp 请求时需要发送到服务端，增加请求数量。\n只能用 document.cookie &#x3D; ‘…’ 来修改，太过简陋。\n\n2、localStorage 和 sessionStorage\nHTML5 专门为存储来设计的，最大可存 5M。\nAPI 简单易用， setItem getItem。\n不会随着 http 请求被发送到服务端。\n\n它们的区别：\n\nlocalStorage 数据会永久存储，除非代码删除或手动删除。\nsessionStorage 数据只存在于当前会话，浏览器关闭则清空。\n一般用 localStorage 会多一些。\n\n五、Http前端工程师做出网页，需要通过网络请求向后端获取数据，因此 http 协议是前端面试的必考内容。\n1、http 状态码1.1 状态码分类\n1xx - 服务器收到请求。\n2xx - 请求成功，如 200。\n3xx - 重定向，如 302。\n4xx - 客户端错误，如 404。\n5xx - 服务端错误，如 500。\n\n1.2 常见状态码\n200 - 成功。\n301 - 永久重定向（配合 location，浏览器自动处理）。\n302 - 临时重定向（配合 location，浏览器自动处理）。\n304 - 资源未被修改。\n403 - 没权限。\n404 - 资源未找到。\n500 - 服务器错误。\n504 - 网关超时。\n\n1.3 关于协议和规范\n状态码都是约定出来的。\n要求大家都跟着执行。\n不要违反规范，例如 IE 浏览器。\n\n2、http 缓存\n关于缓存的介绍。\nhttp 缓存策略（强制缓存 + 协商缓存）。\n刷新操作方式，对缓存的影响。\n\n4.1 关于缓存什么是缓存？ 把一些不需要重新获取的内容再重新获取一次\n为什么需要缓存？ 网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。\n哪些资源可以被缓存？ 静态资源，比如 js css img。\n4.2 强制缓存\nCache-Control：\n\n在 Response Headers 中。\n控制强制缓存的逻辑。\n例如 Cache-Control: max-age&#x3D;3153600（单位是秒）\n\nCache-Control 有哪些值：\n\nmax-age：缓存最大过期时间。\nno-cache：可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。\nno-store：永远都不要在客户端存储资源，永远都去原始服务器去获取资源。\n\n4.3 协商缓存（对比缓存）\n服务端缓存策略。\n服务端判断客户端资源，是否和服务端资源一样。\n一致则返回 304，否则返回 200 和最新的资源。\n\n 资源标识：\n\n在 Response Headers 中，有两种。\nLast-Modified：资源的最后修改时间。\nEtag：资源的唯一标识（一个字符串，类似于人类的指纹）。\n\nLast-Modified：  服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304 ，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。\nEtag：  其实 Etag 和 Last-Modified 一样的，只不过 Etag 是服务端对资源按照一定方式（比如 contenthash）计算出来的唯一标识，就像人类指纹一样，传给客户端之后，客户端再传过来时候，服务端会将其与现在的资源计算出来的唯一标识做比较，一致则返回 304，不一致就返回 200 和新的资源及新的 Etag。\n两者比较：\n\n优先使用 Etag。\nLast-Modified 只能精确到秒级。\n如果资源被重复生成，而内容不变，则 Etag 更精确。\n\n4.4 综述\n4.4 三种刷新操作对 http 缓存的影响\n正常操作：地址栏输入 url，跳转链接，前进后退等。\n手动刷新：f5，点击刷新按钮，右键菜单刷新。\n强制刷新：ctrl + f5，shift+command+r。\n\n正常操作：强制缓存有效，协商缓存有效。 手动刷新：强制缓存失效，协商缓存有效。 强制刷新：强制缓存失效，协商缓存失效。 ****\n3. 面试对于更多面试中可能出现的问题，我还是建议精读这篇三元的文章：HTTP 灵魂之问，巩固你的 HTTP 知识体系。\n比如会被经常问到的： GET 和 POST 的区别。\n\n从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。\n从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。\n从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。\n从幂等性的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)\n从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)\n\nHTTP&#x2F;2 有哪些改进？（很大可能问原理）\n\n头部压缩。\n多路复用。\n服务器推送。\n\n关于 HTTPS 的一些原理，可以阅读这篇文章：这一次，彻底理解 https 原理。接着你可以观看这个视频进行更进一步的学习：HTTPS 底层原理，面试官直接下跪，唱征服！\n关于跨域问题，大部分文章都是理论性比较强，还不如读这篇文章，聊聊跨域的原理与解决方法，讲的非常清晰，我个人觉得对付面试就是先知道使用流程，把这个流程能自己说出来，然后再讲下原理即可。\n六、React1、 React 事件机制，React 16 和 React 17 事件机制的不同阅读这篇文章即可：一文吃透 react 事件系统原理。\n为什么要自定义事件机制？\n\n抹平浏览器差异，实现更好的跨平台。\n避免垃圾回收，React 引入事件池，在事件池中获取或释放事件对象，避免频繁地去创建和销毁。\n方便事件统一管理和事务机制。\n\n2、class component不排除现在还会有面试官问关于 class component 的问题。\n2.1 生命周期\n初始化阶段。\n\n发生在 constructor 中的内容，在 constructor 中进行 state 、props 的初始化，在这个阶段修改 state，不会执行更新阶段的生命周期，可以直接对 state 赋值。\n\n挂载阶段。\n\n1. componentWillMount\n   发生在 render 函数之前，还没有挂载 Dom\n2. render\n3. componentDidMount\n   发生在 render 函数之后，已经挂载 Dom\n复制代码\n\n\n更新阶段。\n\n更新阶段分为由 state 更新引起和 props 更新引起。\nprops 更新时：\n1. componentWillReceiveProps(nextProps,nextState)\n   这个生命周期主要为我们提供对 props 发生改变的监听，如果你需要在 props 发生改变后，相应改变组件的一些 state。在这个方法中改变 state 不会二次渲染，而是直接合并 state。\n2. shouldComponentUpdate(nextProps,nextState)\n   这个生命周期需要返回一个 Boolean 类型的值，判断是否需要更新渲染组件，优化 react 应用的主要手段之一，当返回 false 就不会再向下执行生命周期了，在这个阶段不可以 setState()，会导致循环调用。\n3. componentWillUpdate(nextProps,nextState)\n   这个生命周期主要是给我们一个时机能够处理一些在 Dom 发生更新之前的事情，如获得 Dom 更新前某些元素的坐标、大小等，在这个阶段不可以 setState()，会导致循环调用。\n    **一直到这里 this.props 和 this.state 都还未发生更新**\n4. render\n5. componentDidUpdate(prevProps, prevState)\n   在此时已经完成渲染，Dom 已经发生变化，state 已经发生更新，prevProps、prevState 均为上一个状态的值。\n\nstate 更新时（具体同上）\n1. shouldComponentUpdate\n2. componentWillUpdate\n3. render\n4. componentDidUpdate\n复制代码\n\n\n卸载阶段。\n\n1. componentWillUnmount\n   在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount  中创建的订阅等。componentWillUnmount 中不应调用 setState，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。\n\n复制代码\n\n在 React 16 中官方已经建议删除以下三个方法，非要使用必须加前缀：UNSAVE_ 。\ncomponentWillMount;\ncomponentWillReceiveProps;\ncomponentWillUpdate;\n复制代码\n\n取代这两三个生命周期的以下两个新的。\n1. static getDerivedStateFromProps(nextProps,nextState)\n   在组件实例化、接收到新的 props 、组件状态更新时会被调用\n2. getSnapshotBeforeUpdate（prevProps,prevState）\n   在这个阶段我们可以拿到上一个状态 Dom 元素的坐标、大小的等相关信息。用于替代旧的生命周期中的 componentWillUpdate。\n   该函数的返回值将会作为 componentDidUpdate 的第三个参数出现。\n复制代码\n\n需要注意的是，一般都会问为什么要废弃三个生命周期，原因是什么。\n2.2 setState 同步还是异步setState 本身代码的执行肯定是同步的，这里的异步是指是多个 state 会合成到一起进行批量更新。 同步还是异步取决于它被调用的环境。\n\n如果 setState 在 React 能够控制的范围被调用，它就是异步的。比如合成事件处理函数，生命周期函数， 此时会进行批量更新，也就是将状态合并后再进行 DOM 更新。\n如果 setState 在原生 JavaScript 控制的范围被调用，它就是同步的。比如原生事件处理函数，定时器回调函数，Ajax 回调函数中，此时 setState 被调用后会立即更新 DOM 。\n\n3、对函数式编程的理解这篇文章写的真的太好了，一定要读：简明 JavaScript 函数式编程——入门篇。\n总结一下： 函数式编程有两个核心概念。\n\n数据不可变（无副作用）： 它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。\n无状态： 主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。\n\n纯函数带来的意义。\n\n便于测试和优化：这个意义在实际项目开发中意义非常大，由于纯函数对于相同的输入永远会返回相同的结果，因此我们可以轻松断言函数的执行结果，同时也可以保证函数的优化不会影响其他代码的执行。\n可缓存性：因为相同的输入总是可以返回相同的输出，因此，我们可以提前缓存函数的执行结果。\n更少的 Bug：使用纯函数意味着你的函数中不存在指向不明的 this，不存在对全局变量的引用，不存在对参数的修改，这些共享状态往往是绝大多数 bug 的源头。\n\n4、react hooks现在应该大多数面试官会问 hooks 相关的啦。这里我强烈推荐三篇文章，即使没看过源码，也能比较好地理解一些原理：用动画和实战打开 React Hooks（一）：useState 和 useEffect用动画和实战打开 React Hooks（二）：自定义 Hook 和 useCallback用动画和实战打开 React Hooks（三）：useReducer 和 useContext\n4.1 为什么不能在条件语句中写 hook推荐这篇文章：我打破了 React Hook 必须按顺序、不能在条件语句中调用的枷锁。\nhook 在每次渲染时的查找是根据一个 “全局” 的下标对链表进行查找的，如果放在条件语句中使用，有一定几率会造成拿到的状态出现错乱。\n4.2 HOC 和 hook 的区别hoc 能复用逻辑和视图，hook 只能复用逻辑。\n4.3 useEffect 和 useLayoutEffect 区别对于 React 的函数组件来说，其更新过程大致分为以下步骤：\n\n因为某个事件 state 发生变化。\nReact 内部更新 state 变量。\nReact 处理更新组件中 return 出来的 DOM 节点（进行一系列 dom diff 、调度等流程）。\n将更新过后的 DOM 数据绘制到浏览器中。\n用户看到新的页面。\n\nuseEffect 在第 4 步之后执行，且是异步的，保证了不会阻塞浏览器进程。 useLayoutEffect 在第 3 步至第 4 步之间执行，且是同步代码，所以会阻塞后面代码的执行。\n4.4 useEffect 依赖为空数组与 componentDidMount 区别在 render 执行之后，componentDidMount 会执行，如果在这个生命周期中再一次 setState ，会导致再次 render ，返回了新的值，浏览器只会渲染第二次 render 返回的值，这样可以避免闪屏。\n但是 useEffect 是在真实的 DOM 渲染之后才会去执行，这会造成两次 render ，有可能会闪屏。\n实际上 useLayoutEffect 会更接近 componentDidMount 的表现，它们都同步执行且会阻碍真实的 DOM 渲染的。\n4.5 React.memo() 和 React.useMemo() 的区别\nmemo 是一个高阶组件，默认情况下会对 props 进行浅比较，如果相等不会重新渲染。多数情况下我们比较的都是引用类型，浅比较就会失效，所以我们可以传入第二个参数手动控制。\nuseMemo 返回的是一个缓存值，只有依赖发生变化时才会去重新执行作为第一个参数的函数，需要记住的是，useMemo 是在 render 阶段执行的，所以不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴。\n\n4.6 React.useCallback() 和 React.useMemo() 的区别\nuseCallback 可缓存函数，其实就是避免每次重新渲染后都去重新执行一个新的函数。\nuseMemo 可缓存值。\n\n有很多时候，我们在 useEffect 中使用某个定义的外部函数，是要添加到 deps 数组中的，如果不用 useCallback 缓存，这个函数在每次重新渲染时都是一个完全新的函数，也就是引用地址发生了变化，这就会导致 useEffect 总会无意义的执行。\n4.7 React.forwardRef 是什么及其作用这里还是阅读官方文档来的清晰：React.forwardRef。 一般在父组件要拿到子组件的某个实际的 DOM 元素时会用到。\n6、react hooks 与 class 组件对比react hooks 与 class 组件对比 函数式组件与类组件有何不同\n7、介绍 React dom diff 算法让虚拟 DOM 和 DOM-diff 不再成为你的绊脚石。\n8、对 React Fiber 的理解关于这块儿我觉得可以好好阅读下这篇无敌的博客了：Build your own React。 它可以教你一步步实现一个简单的基于 React Fiber 的 React，可以学到很多 React 的设计思想，毕竟为了面试我们可能大多数人是没有时间或能力去阅读源码的了。\n然后我们再阅读下其它作者对于 React Fiber 的理解，再转化为我们自己的思考总结，以下是推荐文章： 这可能是最通俗的 React Fiber(时间分片) 打开方式\n9、React 性能优化手段推荐文章：React 性能优化的 8 种方式了解一下？\n\n使用 React.memo 来缓存组件。\n使用 React.useMemo 缓存大量的计算。\n避免使用匿名函数。\n利用 React.lazy 和 React.Suspense 延迟加载不是立即需要的组件。\n尽量使用 CSS 而不是强制加载和卸载组件。\n使用 React.Fragment 避免添加额外的 DOM。\n\n10、React ReduxRedux 包教包会（一）：介绍 Redux 三大核心概念\n七、webpack原理初探：当面试官问 Webpack 的时候他想知道什么简易实现：面试官：webpack 原理都不会，手写一个 webpack，看看 AST 怎么用加料：简单易懂的 webpack 打包后 JS 的运行过程，Webpack 手写 loader 和 plugin热更新原理：Webpack HMR 原理解析面试题：「吐血整理」再来一打 Webpack 面试题\n这里要注意，应该还会考 webpack5 和 4 有哪些区别。\n八、模块化前端模块化详解 (完整版) （这里面没有讲 umd）可能是最详细的 UMD 模块入门指南\n九、性能优化代码层面：\n\n防抖和节流（resize，scroll，input）。\n减少回流（重排）和重绘。\n事件委托。\ncss 放 ，js 脚本放 最底部。\n减少 DOM 操作。\n按需加载，比如 React 中使用 React.lazy 和 React.Suspense ，通常需要与 webpack 中的 splitChunks 配合。\n\n构建方面：\n\n压缩代码文件，在 webpack 中使用 terser-webpack-plugin 压缩 Javascript 代码；使用 css-minimizer-webpack-plugin 压缩 CSS 代码；使用 html-webpack-plugin 压缩 html 代码。\n开启 gzip 压缩，webpack 中使用 compression-webpack-plugin ，node 作为服务器也要开启，使用 compression。\n常用的第三方库使用 CDN 服务，在 webpack 中我们要配置 externals，将比如 React， Vue 这种包不打倒最终生成的文件中。而是采用 CDN 服务。\n\n其它：\n\n使用 http2。因为解析速度快，头部压缩，多路复用，服务器推送静态资源。\n使用服务端渲染。\n图片压缩。\n使用 http 缓存，比如服务端的响应中添加 Cache-Control / Expires 。\n\n十、常见手写以下的内容是上面没有提到的手写，比如 new 、Promise.all 这种上面内容中已经提到了如何写。\n1、防抖JavaScript 专题之跟着 underscore 学防抖 \nfunction debounce(func, wait, immediate) &#123;\n  let timeout;\n\n  return function () &#123;\n    let context &#x3D; this;\n    let args &#x3D; arguments;\n\n    if (timeout) clearTimeout(timeout);\n    if (immediate) &#123;\n      let callNow &#x3D; !timeout;\n      timeout &#x3D; setTimeout(function () &#123;\n        timeout &#x3D; null;\n      &#125;, wait);\n      if (callNow) func.apply(context, args);\n    &#125; else &#123;\n      timeout &#x3D; setTimeout(function () &#123;\n        func.apply(context, args);\n      &#125;, wait);\n    &#125;\n  &#125;;\n&#125;\n复制代码\n\n2、节流JavaScript 专题之跟着 underscore 学节流\n&#x2F;&#x2F; 使用时间戳\nfunction throttle(func, wait) &#123;\n  let preTime &#x3D; 0;\n\n  return function () &#123;\n    let nowTime &#x3D; +new Date();\n    let context &#x3D; this;\n    let args &#x3D; arguments;\n\n    if (nowTime - preTime &gt; wait) &#123;\n      func.apply(context, args);\n      preTime &#x3D; nowTime;\n    &#125;\n  &#125;;\n&#125;\n\n&#x2F;&#x2F; 定时器实现\nfunction throttle(func, wait) &#123;\n  let timeout;\n\n  return function () &#123;\n    let context &#x3D; this;\n    let args &#x3D; arguments;\n\n    if (!timeout) &#123;\n      timeout &#x3D; setTimeout(function () &#123;\n        timeout &#x3D; null;\n        func.apply(context, args);\n      &#125;, wait);\n    &#125;\n  &#125;;\n&#125;\n复制代码\n\n3、快速排序这里对快排思想不太明白的同学可以看下这个讲解的很清晰的视频：快速排序算法。\nfunction sortArray(nums) &#123;\n  quickSort(0, nums.length - 1, nums);\n  return nums;\n&#125;\n\nfunction quickSort(start, end, arr) &#123;\n  if (start &lt; end) &#123;\n    const mid &#x3D; sort(start, end, arr);\n    quickSort(start, mid - 1, arr);\n    quickSort(mid + 1, end, arr);\n  &#125;\n&#125;\n\nfunction sort(start, end, arr) &#123;\n  const base &#x3D; arr[start];\n  let left &#x3D; start;\n  let right &#x3D; end;\n  while (left !&#x3D;&#x3D; right) &#123;\n    while (arr[right] &gt;&#x3D; base &amp;&amp; right &gt; left) &#123;\n      right--;\n    &#125;\n    arr[left] &#x3D; arr[right];\n    while (arr[left] &lt;&#x3D; base &amp;&amp; right &gt; left) &#123;\n      left++;\n    &#125;\n    arr[right] &#x3D; arr[left];\n  &#125;\n  arr[left] &#x3D; base;\n  return left;\n&#125;\n复制代码\n\n4、instanceof这个手写一定要懂原型及原型链。\nfunction myInstanceof(target, origin) &#123;\n  if (typeof target !&#x3D;&#x3D; &quot;object&quot; || target &#x3D;&#x3D;&#x3D; null) return false;\n  if (typeof origin !&#x3D;&#x3D; &quot;function&quot;)\n    throw new TypeError(&quot;origin must be function&quot;);\n  let proto &#x3D; Object.getPrototypeOf(target); &#x2F;&#x2F; 相当于 proto &#x3D; target.__proto__;\n  while (proto) &#123;\n    if (proto &#x3D;&#x3D;&#x3D; origin.prototype) return true;\n    proto &#x3D; Object.getPrototypeOf(proto);\n  &#125;\n  return false;\n&#125;\n复制代码\n\n5、数组扁平化重点，不要觉得用不到就不管，这道题就是考察你对 js 语法的熟练程度以及手写代码的基本能力。\nfunction flat(arr, depth &#x3D; 1) &#123;\n  if (depth &gt; 0) &#123;\n    &#x2F;&#x2F; 以下代码还可以简化，不过为了可读性，还是....\n    return arr.reduce((pre, cur) &#x3D;&gt; &#123;\n      return pre.concat(Array.isArray(cur) ? flat(cur, depth - 1) : cur);\n    &#125;, []);\n  &#125;\n  return arr.slice();\n&#125;\n复制代码\n\n6、手写 reduce先不考虑第二个参数初始值：\nArray.prototype.reduce &#x3D; function (cb) &#123;\n  const arr &#x3D; this; &#x2F;&#x2F;this就是调用reduce方法的数组\n  let total &#x3D; arr[0]; &#x2F;&#x2F; 默认为数组的第一项\n  for (let i &#x3D; 1; i &lt; arr.length; i++) &#123;\n    total &#x3D; cb(total, arr[i], i, arr);\n  &#125;\n  return total;\n&#125;;\n复制代码\n\n考虑上初始值：\nArray.prototype.reduce &#x3D; function (cb, initialValue) &#123;\n  const arr &#x3D; this;\n  let total &#x3D; initialValue || arr[0];\n  &#x2F;&#x2F; 有初始值的话从0遍历，否则从1遍历\n  for (let i &#x3D; initialValue ? 0 : 1; i &lt; arr.length; i++) &#123;\n    total &#x3D; cb(total, arr[i], i, arr);\n  &#125;\n  return total;\n&#125;;\n复制代码\n\n7、带并发的异步调度器 SchedulerJS 实现一个带并发限制的异度调度器 Scheduler，保证同时运行的任务最多有两个。完善下面代码中的 Scheduler 类，使得以下程序能正确输出。\nclass Scheduler &#123;\n  add(promiseMaker) &#123;&#125;\n&#125;\n\nconst timeout &#x3D; (time) &#x3D;&gt;\n  new Promise((resolve) &#x3D;&gt; &#123;\n    setTimeout(resolve, time);\n  &#125;);\n\nconst scheduler &#x3D; new Scheduler();\nconst addTask &#x3D; (time, order) &#x3D;&gt; &#123;\n  scheduler.add(() &#x3D;&gt; timeout(time).then(() &#x3D;&gt; console.log(order)));\n&#125;;\n\naddTask(1000, &quot;1&quot;);\naddTask(500, &quot;2&quot;);\naddTask(300, &quot;3&quot;);\naddTask(400, &quot;4&quot;);\n&#x2F;&#x2F; output：2 3 1 4\n&#x2F;&#x2F; 一开始，1，2两个任务进入队列。\n&#x2F;&#x2F; 500ms 时，2完成，输出2，任务3入队。\n&#x2F;&#x2F; 800ms 时，3完成，输出3，任务4入队。\n&#x2F;&#x2F; 1000ms 时，1完成，输出1。\n复制代码\n\n根据题目，我们只需要操作 Scheduler 类就行：\nclass Scheduler &#123;\n  constructor() &#123;\n    this.waitTasks &#x3D; []; &#x2F;&#x2F; 待执行的任务队列\n    this.excutingTasks &#x3D; []; &#x2F;&#x2F; 正在执行的任务队列\n    this.maxExcutingNum &#x3D; 2; &#x2F;&#x2F; 允许同时运行的任务数量\n  &#125;\n\n  add(promiseMaker) &#123;\n    if (this.excutingTasks.length &lt; this.maxExcutingNum) &#123;\n      this.run(promiseMaker);\n    &#125; else &#123;\n      this.waitTasks.push(promiseMaker);\n    &#125;\n  &#125;\n\n  run(promiseMaker) &#123;\n    const len &#x3D; this.excutingTasks.push(promiseMaker);\n    const index &#x3D; len - 1;\n    promiseMaker().then(() &#x3D;&gt; &#123;\n      this.excutingTasks.splice(index, 1);\n      if (this.waitTasks.length &gt; 0) &#123;\n        this.run(this.waitTasks.shift());\n      &#125;\n    &#125;);\n  &#125;\n&#125;\n复制代码\n\n8、去重\n利用 ES6 set 关键字：\n\nfunction unique(arr) &#123;\n  return [...new Set(arr)];\n&#125;\n复制代码\n\n\n利用 ES5 filter 方法：\n\nfunction unique(arr) &#123;\n  return arr.filter((item, index, array) &#x3D;&gt; &#123;\n    return array.indexOf(item) &#x3D;&#x3D;&#x3D; index;\n  &#125;);\n&#125;\n复制代码\n\n十一、其它\nrequestAnimationFrame（一个神奇的前端动画 API requestAnimationFrame）\n如何排查内存泄漏问题，面试官可能会问为什么页面越来越卡顿，直至卡死，怎么定位到产生这种现象的源代码（开发环境）？（一文带你了解如何排查内存泄漏导致的页面卡顿现象）\nvite 大火，我复习的时候是去年 9 月份，还没那么火，可能现在的你需要学一学了～\nvue3 也一样，如果你是 React 技术栈（就像我之前一样）当我没说。\nTCP&amp;UDP https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html\n\n十二、算法这部分大家可以点击以下这个仓库，按照仓库中的题目顺序进行刷题，都是我亲自刷过的，排了最适合的顺序：vortesnail&#x2F;leetcode。然后如果大家想看下大厂的算法高频题可以看这个仓库：afatcoder&#x2F;LeetcodeTop。\n","slug":"前端面试复习计划","date":"2022-01-04T03:02:15.000Z","categories_index":"Frontend","tags_index":"面经","author_index":"析构理想"},{"id":"14735e2960e22dca64c2f7a6c53b0957","title":"推荐系统面试题&解答","content":"ML与DL基础机器学习\n\n介绍下GBDT\ngbdt 是通过采用加法模型（即基函数的线性组合），以及不断减小训练过程产生的残差来达到将数据分类或者回归的算法， gbdt通过多轮迭代,每轮迭代产生一个弱分类器，每个分类器在上一轮分类器的残差基础上进行训练。\nGBDT中的树是回归树（不是分类树），默认选择CART回归树，GBDT用来做回归预测，调整后也可以用于分类。\n核心思想是利用损失函数的负梯度在当前模型的值作为残差的近似值，本质上是对损失函数进行一阶泰勒展开，从而拟合一个回归树。\n\n介绍XGBoost\nXGBoost是陈天奇开源的一种梯度提升树模型，是GBDT的一种工程实现。与GBDT最大的区别就是树的生成方式不同，加快了树的生成过程，以生成最优树。\nXGBT相对于GBDT的优化（sklearn中的GBDT实现和传统的有一定改进，同样支持XGBT的一些特性，这里的对比只针对传统GBDT）：\n正则项：XGBT加入了正则项，控制模型复杂度，防止过拟合，加入的有叶子结点个数正则化、叶子结点输出L2正则化；\n二阶泰勒展开：XGBT对损失函数进行了二阶泰勒展开，加速收敛速度；\n支持更多基学习器：GBDT只支持CART树，XGBT支持多种基学习器，比如线性分类器；\n行采样：传统GBDT每一轮迭代都使用了全部数据，XGBT使用了行采样；\n列采样：传统GBDT同样没有使用列采样，XGBT引入了列采样；\n缺失值处理：GBDT没有缺失值处理机制，XGBT支持缺失值处理；\nShrinkage：对每一颗树输出进行衰减，削弱单颗树影响，让后续树有更大学习空间；\n并行化：特征粒度的并行化，而非树粒度的，在不同特征上采用多线程并行计算最优分割点；\n\n\n\n介绍下LightGBM\nLightGBM是微软开源的一个梯度Boosting框架，使用基于决策树的学习算法，是GBDT的一种工程实现，特点是快。\nLGB相对于XGBT的改进：\n基于直方图的决策树算法：把特征离散到K个bin中构造直方图，遍历一遍特征统计直方图，最后根据直方图寻找最优分割点，这样做的好处是计算速度更快，内存占用更小；\n直方图做差加速：计算兄弟节点的直方图，只需要用父节点直方图-本节点直方图。这样做速度提升了一倍；\nLeaf-wise叶子生长策略：XGBT的Level-wise每次分裂一层节点，容易并行化，但是更容易过拟合，Leaf-wise值分裂增益最大的节点，相对精度更高，过拟合更小；\n直接支持类别特征：第一个直接支持类别特征的GBDT工具，具体算法《On Grouping For Maximum Homogeneity》；\n高效并行优化：数据量小采用特征并行、数据并行，数据量大采用投票并行；\nCache优化：直方图算法天生提高缓存命中，降低内存消耗；\n单边梯度抽样算法：过滤梯度小的样本，同时平衡了数据分布的改变，这个算法能够提升计算速度；\n\n\n\nLightGBM相对于XGBoost的改进\n如上\n\nGBDT中的梯度是什么，怎么用\n在线性模型优化的过程中。利用梯度下降我们总是让参数向负梯度的方向移动，使损失函数最小。gbdt，假入我们现在有 t 课树，我们需要去学习是第 t+1 颗树，那么如何学习第 t+1 颗树才是最优的树呢？ 这个时候我们参考梯度优化的思想。现在的 t 课树就是我们现在的状态使用这个状态我们可以计算出现在的损失。如何让损失更小呢？我们只需要让 t+1 颗树去拟合损失的负梯度。而残差 是梯度在MSE为损失函数下的特例（MSE的导数就是残差）。\n\nGBDT如何计算特征重要性\n树模型，天生能够利用Gini计算单颗树上特种重要性，然后再在所有树上汇总求平均；\n\n介绍XGBoost中的并行\nxgboost的并行是在特征粒度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。\n\n介绍XGBoost中精确算法与近似算法\n指的是在计算特征分裂的时候，XGBT使用了近似算法\n\n精确算法：通过列举所有特征的可能划分找到最优划分解来生成树，该方法需要排序以形成连续的特征，之后计算每个可能的梯度统计值。\n\n缺点：在数据量非常大的情况下，精确基本用不了。一方面在生成树的过程中，每次寻找一个节点最佳分割点时，都需要比较其在所有特征的所有分割点上的效果，这么做时间复杂度很高；另一方面，在每次对某个特征进行分割的时候，需要对所有样本根据该特征值进行排序，这需要我们把所有的数据存储在内存中，这会给硬件方面带来很大压力。\n\n\n近似算法：在针对一个特征寻找分割点的时候，我们其实对特征中的值的范围不敏感，只对这些值的顺序敏感。比如数据集中的样本的某一个特征出现的值有12、15、82、107，但是如果我们把这四种值分别替换成1、2、3、4，最后得到的树的结构是不变的。利用这种思想，给出一个数据集中样本的第k个特征和样本点在损失函数上的二阶导数所组成的集合，随后利用数据分布的百分比来定义一个排名函数 ，这个排名函数代表了特征k的值小于z的样本占总样本的比例。我们的目标就是利用这个排名函数来寻找候选分割点集合。\n\n\nXGBoost如何处理空缺值\n将缺失值分别划分到左子树和右子树，分别计算出左子树和右子树的增益 ，选出更大的，将该方向作为缺失值的分裂方向（记录下来，预测阶段将会使用）。\nLGB使用相同的方法；\n\n为何要进行行采样、列采样\n简单回答：降低了过拟合\n具体回答：（数学证明）\n\n为什么高维稀疏数据，LR比GBDT要好\n树模型对稀疏特征，切分的收益非常小，只能从少量非0信息上学习；\n线性模型的正则项是对权重惩罚，树模型是对深度、叶子个数的惩罚。所以高维稀疏数据中，少量样本会对结果产生非常大的影响，非常容易过拟合，而线性模型的权重惩罚能够很好处理这一点。综上，带正则化的线性模型比较不容易对稀疏特征过拟合；\n同样的原因可以解释为什么onehot不适合树模型；\n\n随机森林与GBDT采样的区别\nRF采用了行列采样，传统GBDT算法没有采用；\n\n随机森林中列采样的作用\n随机森林在bagging基础上，进一步在训练过程引入随机属性选择，从全集d中随机选择k个属性的子集，利用这个子集来建立本颗子树，下一轮同理；推荐的k&#x3D;log2d\n\nbagging与boosting对比\nboosting：串行的方式训练基分类器，各分类器之间有依赖。每次训练时，对前一层基分类器分错的样本给与更高的权重，更多的关注的是偏差；\n\nbagging：是Bootstrap aggregating的意思，各分类器之间无强依赖，可以并行，最终结果进行投票（分类），或者平均（回归）；\n\n样本选择上：\n\nBagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。\n\nBoosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。\n\n\n\n样例权重：\n\nBagging：使用均匀取样，每个样例的权重相等。\n\nBoosting：根据错误率不断调整样例的权值，错误率越大则权重越大。\n\n\n\n预测函数：\n\nBagging：所有预测函数的权重相等。\n\nBoosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。\n\n\n\n并行计算：\n\nBagging：各个预测函数可以并行生成。\n\nBoosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。\n\n\n\n\nbagging与boosting分别从什么角度降低过拟合\nbagging降低方差，boosting降低方差\n\n逻辑回归如何避免过拟合\n更多数据集、数据增强、更多特征；\n权重衰减正则化；\n提前终止；\n\n推导逻辑回归损失函数和损失函数求导正则化项L1和L2为什么有用\nL1正则化和L2正则化可以看做是损失函数的惩罚项。所谓『惩罚』是指对损失函数中的某些参数做一些限制；\n拟合过程中通常都倾向于让权值尽可能小，最后构造一个所有参数都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。\n\nl1正则不可导，如何优化\n在不可导处无法进行梯度下降，此时采用坐标轴下降法：坐标轴下降法是沿着坐标轴的方向，每次固定m-1个数值，对最后一个数值求局部最优解，迭代m次（证明：凸函数在每一个维度都取得最小值，则此处就是全局最小值）；\n同样可以用Proximal operator、admm等方法；\n\n什么样的特征容易产生比较小的权重\n？\n\n随机森林采样n次，n趋于无穷大，oob样本的概率接近于？\n1&#x2F;e：limx-&gt;∞（1-1&#x2F;x)^x\n\n逻辑回归与树模型的优缺点\n树模型\n可解释性强，比线性模型还强\n拟合能力更强，特别是对非线性数据；\n容易过拟合；\n\n\n\n对于高维稀疏数据，树模型能训练吗？一般怎么处理\n能训练，但是效果不好，容易过拟合；\n处理方法是：？\n\n树模型一般有哪些参数，分别有什么作用\nnum_leaves: 最大叶子节点个数\nmax_depth\nlearning_rate\nmin_split_gain\n\n随机森林如何处理空缺值\n随机森林本身没有处理空缺值算法，有些实现中附带了处理空缺值算法；\n数值变量用中位数、类别变量用众数；\n利用无空缺的变量计算相似度后加权计算，类别变量用加权投票，数值变量加权平均；\n\n介绍kmeans，与其他聚类算法的对比\nK-means 是我们最常用的基于欧式距离的聚类算法，其认为两个目标的距离越近，相似度越大；\n\n所以 K-means 的算法步骤为：\n\n选择初始化的 k 个样本作为初始聚类中心  ；\n针对数据集中每个样本  计算它到 k 个聚类中心的距离并将其分到距离最小的聚类中心所对应的类中；\n针对每个类别  ，重新计算它的聚类中心  （即属于该类的所有样本的质心）；\n重复上面 2 3 两步操作，直到达到某个中止条件（迭代次数、最小误差变化等）。\n\n\n优点：\n\n容易理解，聚类效果不错，虽然是局部最优， 但往往局部最优就够了；\n处理大数据集的时候，该算法可以保证较好的伸缩性；\n当簇近似高斯分布的时候，效果非常不错；\n算法复杂度低。\n\n\n缺点：\n\nK 值需要人为设定，不同 K 值得到的结果不一样；\n对初始的簇中心敏感，不同选取方式会得到不同结果；\n对异常值敏感；\n样本只能归为一类，不适合多分类任务；\n不适合太离散的分类、样本类别不平衡的分类、非凸形状的分类。\n\n\n\n机器学习导致误差的原因？\n偏差：模型无法表达数据集的复杂度，模型不够复杂，导致不能学习到基本关系，导致欠拟合；\n方差：数据量有限，模型对数据过度敏感，导致方差；\n\n过拟合、欠拟合对应的偏差和方差是怎样的？\n过拟合：高方差，低偏差\n欠拟合：高方差、高偏差\n\n如何解决过拟合问题？哪些角度\n更多数据、数据增强；\n更换模型：更简单模型、更优化的模型；\n权重衰减正则化；\nbagging等集成学习方法，深度学习中的dropout；\nearly stopping；\n\n深度学习优化器，SGD与Adam的异同点\nSGD有两大改进方向：动量上改进、自适应学习率改进\nAdam同时结合了这两者的改进方法：在动量上用了Momentum，自适应学习率上用了RMSprop\n\nSGD缺点，已经有什么改进的优化器\n每次只使用一批样本，导致迭代方向变化很大，容易剧烈震荡；\n学习率固定，容易在局部下降速度过慢过过快，得到局部最优解或者学习过慢；\n改进方法就是动量和自适应学习率：momentum、adagrad、Adam、等；\n\n网络权重初始化为0有什么影响，初始化为一个非0的常数呢？\n如果W、b初始化为0：每一层前向传播输出都是一致的，反向传播同样就一致，多个神经元作用等同于1个；\n只有W初始化为0：b随机初始化：反向传播过程中，第一次的第一层的dw都是0，只有第二次才能恢复，导致收敛更慢，梯度消失问题严重；\n只有b初始化为0：可以的\n\nembedding如何设置维度？越大越好还是越小越好？\n维度越低越粗糙，拟合能力就有限；\n阅读越高越细致，但是需要更多数据集才能训练，容易有维度灾难；\n具体大小需要结合实际数据集大小，问题规模，经验参数，以及调试得到；\n\ntransformer中计算attention除于根号d的作用embedding如何训练\nCBOW: 先在句子中选定一个中心词，并把其它词作为这个中心词的上下文。在学习过程中，使用上下文的词向量推理中心词，这样中心词的语义就被传递到上下文的词向量中, 从而达到学习语义信息的目的。\nSkip-gram: 同样先选定一个中心词，并把其他词作为这个中心词的上下文。不同的是，在学习过程中，使用中心词的词向量去推理上下文，这样上下文定义的语义被传入中心词的表示中， 从而达到学习语义信息的目的。\n一般来说，CBOW比Skip-gram训练速度快，训练过程更加稳定，原因是CBOW使用上下文average的方式进行训练，每个训练step会见到更多样本。而在生僻字（出现频率低的字）处理上，skip-gram比CBOW效果更好，原因是skip-gram不会刻意回避生僻字(CBOW结构中输入中存在生僻字时，生僻字会被其它非生僻字的权重冲淡)\n\n介绍下attention，相比cnn、lstm的优势word2vec如何进行负采样\n负采样的核心思想是：就是分别计算正负样本的loss，这样负样本就可以选择采样的那几条，而不是除开正样本以外的所有样本。\n一个单词被选作negative sample的概率跟它出现的频次有关，出现频次越高的单词越容易被选作negative words\n\nword2vec两种训练方法的区别，具体损失函数\n如上\n\n介绍LSTM每一个门的具体操作，一个LSTM cell的时间复杂度是多少\nforget gate：决定上一时刻的单元c-1有多少保存到当前时刻c\ninput gate：决定当前时刻的输入x，有多少保存下来到c\noutput gate：决定当前单元c，有多少输出的当前的输出值h\n复杂度没有找到相关资料；\n\ntransformer中encoder和decoder的输入分别是什么transformer中encoder与decoder的QKV矩阵如何产生transformer中QKV矩阵是否可以设置成同一个transformer与bert的位置编码有什么区别BERT中计算attention的公式BERT中LayerNorm的作用，为什么不用BN？BERT中的两种预训练任务介绍深度学习中BN的好处？最早提出BN是为了解决什么问题？BN具体怎么实现的\n随着训练进行，数据的分布会发生变化，会导致训练困难。如果没有 BN 层，深度神经网络中的每一层的输入数据或大或小、分布情况等都是不可控的。有了 BN 层之后，每层的数据分布都被转换在均值为零，方差为1 的状态，这样每层数据的分布大致是一样的，训练会比较容易收敛。\n神经网络在训练时比较容易收敛，更容易避免梯度消失、梯度爆炸；\n\n激活函数中，sigmoid，tanh有什么不好的地方？relu有什么优势？\nsigmoid、tanh缺点\n\n两端有梯度消失；\n有指数等运算，求导更复杂；\n\n\nrelu优点：\n\n求导快，梯度固定；\n避免了两端梯度消失现象；\n\n\n\n特征工程特征工程一般怎么做\n特征分类\n特征预处理\n特征构建\n特征选择\n特征评估特征数值分布比较稀疏如何处理\nembedding\n用对稀疏特征优化更好的算法，比如FM等；\n\n正负样本不均衡如何处理\n采样（欠采样、过采样\n集成学习\n对较少样本分类错误增加更高惩罚\n\n连续特征离散化的作用\n增强模型鲁棒性，减少噪声的影响，减少过拟合\n增强表达能力，引入了非线性表达，减少偏差\n模型运算速度更快，储存所用空间更少\n\n对id类特征onehot导致维度过高，如何处理？\nembedding\n\n如何进行特征筛选\n过滤法：按照相关性等指标对特征评分，进行特征选择\n包装法：每次选择部分特征进行训练\n嵌入法：使用能够计算特征重要性的模型（比如树、线性模型），找到最重要的特征\n\n评估指标auc的含义和计算方法\n**ROC曲线全称为受试者工作特征曲线 （receiver operating characteristic curve），它是根据一系列不同的二分类方式（分界值或决定阈），以真阳性率（敏感性）为纵坐标，假阳性率（1-特异性）为横坐标绘制的曲线**。\nAUC（Area Under Curve）被定义为ROC曲线下的面积\nauc两种绘制方法：\n绘制ROC，分段计算面积；\n利用auc另一种解释：正样本在负样本前的概率。具体如下：假设有m个正样本、n个负样本，共有mn个样本对，计算其中正样本在负样本前的概率；\n\n\n\n如果对负样本进行采样，auc的计算结果会发生变化吗\n针对负样本做随机采样，或者针对正样本做随机采样，或者全局做随机采样，保证随机采样后正负样本分布不变，这个时候auc对采样不敏感。\n\n交叉熵跟MSE有什么区别\n一个用于分类任务，一个用于回归任务；\nMSE是假设数据符合高斯分布时,模型概率分布的负条件对数似然;\n交叉熵是假设模型分布为多项式分布时,模型分布的负条件对数似然；\nMSE无差别得关注全部类别上预测概率和真实概率的差；\n交叉熵关注的是正确类别的预测概率；\n\nmicro-f1解释\nmicro f1不需要区分类别，直接使用总体样本的准召计算f1 score；\n在推荐系统中，种类中数量较多的商品会对f1造成更大的影响力；\nMacro F1分类别计算精确率和召回率，求均值后计算f1；\n\n介绍下排序指标ndcg\n归一化折损累计增益，NDCG用作排序结果的评价指标，这个指标通常是用来衡量和评价搜索结果算法；\nndcg@n 只关心前n个排序是否正确，后面的排序正不正确不予考虑。ndcg@n 的计算方式比较特别，要进行两次排序，一次是对预测的结果排序，另一次是对实际的分布排序；\n\n推荐模型相关召回介绍双塔模型\n双塔模型最大的特点就是「user和item是独立的两个子网络」，左侧是用户塔，右侧是item塔，这两个塔的参数不共享；\n输入层：「[User特征]」主要包括和用户相关的特征：用户id、手机系统、地域、年龄、历史行为序列等，「Item特征」主要包括和Item相关的特征：ItemId、Item类别、Item来源等；\n表示层：User特征和Item特征分别输入到特征提取网络（比如说DNN等）得到User Embedding和Item Embedding。之后我们可以计算这两个Embedding之间的余弦距离。「用户点击过的Item其距离更近，用户没有点击过或者讨厌的Item其距离更远」。之后利用算得的loss来更新模型的参数。\n匹配层：拿用户向量去FAISS中和Item向量进行相似度计算，并返回距离最近的Top K个Item作为个性化的召回结果。\n\n双塔模型的输出，用双塔embedding做内积+sigmoid和求余弦相似度+sigmoid的区别双塔模型一般怎么做特征\n每个塔各自构建user与item embedding，**[User特征]」主要包括和用户相关的特征：用户id、手机系统、地域、年龄、历史行为序列等，上下文特征（Context feature）可以放入用户侧塔，「Item特征」**主要包括和Item相关的特征：ItemId、Item类别、Item来源等；\n\n双塔模型为什么不直接把两个塔合起来输入一个DNN\n性能：减少线上运算速度，item塔可以提前训练，线上只需要user的embedding和相似度计算；\n\n排序为什么CTR中目前普遍使用深度学习模型替换树模型？\n强大的表达能力，能够挖掘更深层次数据模式；\n模型结构非常灵活，能够根据实际应用场景进行调整为什么要有wide层、FM层，deep层不也有记忆能力吗\nwide层记忆能力更强，因为它结构简单，原始数据能够直接影响推荐结果，能够学习到数据中的简单规则DeepFM与wide&amp;deep的介绍与对比\nWide&amp;Deep模型同时考虑了记忆能力和泛化能力，但Wide部分需要人工参与特征工程；DeepFM对Wide&amp;Deep模型的改进之处在于用FM替换了原来的Wide部分,加强了浅层网络部分特征组合的能力。\nDeepFM的动机非常直观，既希望考虑高&#x2F;低阶的feature interaction，又想省去额外的特征工程。使用FM取代Wide的LR部分是一个可行的做法，当然这里LR可以基于先验构造更高阶的组合特征，而FM只考虑二阶，DeepFM中的FM层和隐藏层共享输入，这种共享输入使得DeepFM可以同时从原始特征中学习低阶特征交互和高阶特征交互,完全不需要执行特征工程。对DeepFM进行优化，有哪些思路DeepFM如果过拟合和欠拟合分别如何处理介绍除了FM之外的特征交叉的模型\nFNN：有高阶bit-wise特征交叉，每个特征都使用了与训练的FM模型，训练开销更低。\nDeepFM：是一种可以从原始特征中抽取到各种复杂度特征的端到端模型，没有人工特征工程的困扰，DeepFM模型包含FM和DNN两部分，FM模型可以抽取low-order特征，DNN可以抽取high-order特征。无需类似Wide&amp;Deep模型人工特征工程。\nDCN：可以任意组合特征，而且不增加网络参数.Cross的目的是以一种显示、可控且高效的方式，自动构造有限高阶交叉特征。\n\n介绍DIN模型，适合的场景\n在DIN出现之前，推荐系统或者广告系统的做法通常是将高维的稀疏输入通过一个embedding层转化为低维稠密的特征表示，之后将同类的embedding特征通过pooling的方式（sum pooling或者avg pooling）转化为固定长度的特征，最后将不同类特征拼接起来输入到网络中进行训练。\nDIN模型，增加了注意力机制，D模型的创新点或者解决的问题就是使用了注意力机制来对用户的兴趣动态模拟， 而这个模拟过程存在的前提就是用户之前有大量的历史行为了，这样我们在预测某个商品广告用户是否点击的时候，就可以参考他之前购买过或者查看过的商品，这样就能猜测出用户的大致兴趣来，这样我们的推荐才能做的更加到位，所以这个模型的使用场景是非常注重用户的历史行为特征（历史购买过的商品或者类别信息）\n\nDIN中如何计算attention\n计算attention的方式是利用用户行为的Embedding向量和广告的Embedding向量来进行计算，具体文章中采用的是用一个神经网络（activation unit）来得到weight；\n\nactivation unit的输入包括两个部分，一个是原始的用户行为embedding向量、广告embedding向量；另外一个是两者Embedding向量经过外积计算后得到的向量，文章指出这种方式有利于relevance modeling。 \n除此之外文章用到的Attention机制不是原始NLP任务中采用的Attention，文章中放宽了对于权重加和等于一的限制，这样更有利于体现不同用户行为特征之间的差异化程度。\n\n\ntransformer与DIN的区别和联系介绍下listwise排序模型LambdaRank\nListwise方法是直接优化排序列表，输入为单条样本为一个文档排列。通过构造合适的度量函数衡量当前文档排序和最优排序差值，优化度量函数得到排序模型。\n\n热门技术相关Embedding介绍下item2vec模型\n相比于Word2vec利用“词序列”生成词Embedding。Item2vec利用“物品序列”构造物品Embedding。 其中物品序列是由指定用户的浏览购买等行为产生的历史行为序列；\n利用用户行为序列，采用word2vec思想，生成每个item的Embedding，同样user embedding：由历史item embedding平均或聚类得到；\n\nembedding冷启动怎么做\n补充side information：加入一些其他类型的特征，典型的用户侧特征是人口统计特征，典型的物品侧特征是一些内容型特征；\n从推荐架构改进：批处理-&gt;流处理-&gt;实时推断-&gt;边缘计算，让新信号的消费变得越来越实时；\n冷启动机制：比如采用Airbnb方案，利用物品之间的相似性，对冷启动物品根据相似物品，快速生成初始化Embedding。或者聚类，决策树等经典模型；\n\n多任务学习多任务学习模型的发展历史详细介绍为什么要用多任务学习介绍MMOE、PLE、ESMM，PLE相对MMOE的改进ESSM算法原理和解决的两个问题ESMM中如何解决CVR样本过于稀疏的问题，实际上解决了吗ESMM训练是否使用全量样本介绍PLE模型PLE里面loss如何平衡PLE模型中，是否有尝试对不同的gate用不同的特征，是否有尝试不同业务用不同的特征组合gradnorm介绍介绍关于多任务权重设置的相关模型或者策略如何平衡不同任务的loss如果一个特征对任务a是正相关，对任务b是负相关，如何处理这个特征CTR和CVR任务放在ESMM（都是曝光空间）里和放在PLE（CTR点击空间，CVR曝光空间）里哪种效果好模型蒸馏介绍下蒸馏的loss图神经网络GCN、GraphSAGE、GAT的区别与联系node2vec对比deepwalk的改进\nnode2vec的思想同DeepWalk一样，生成随机游走，对随机游走采样得到（节点，上下文）的组合，然后用处理词向量的方法对这样的组合建模得到网络节点的表示。不过在生成随机游走过程中做了一些创新，node2vec改进了DeepWalk中随机游走的生成方式(通过调整随机游走权重的方法使graph embedding的结果在网络的同质性（homophily）和结构性（structural equivalence）中进行权衡)，使得生成的随机游走可以反映深度优先和广度优先两种采样的特性，从而提高网络嵌入的效果。\n\ngraphsage对比gcn的优势transductive与Inductive的区别训练图模型的loss有哪些graph embedding的作用业务场景相关CVR相比CTR的区别、特点搜索与推荐的区别，你认为哪个难度更大\n排得更好VS估得更准VS搜的更全「推荐、广告、搜索」算法间到底有什么区别？ - 王喆的文章 - 知乎 https://zhuanlan.zhihu.com/p/430431149\n\n广告与推荐的区别\n排得更好VS估得更准VS搜的更全「推荐、广告、搜索」算法间到底有什么区别？ - 王喆的文章 - 知乎 https://zhuanlan.zhihu.com/p/430431149\n\n什么时候用规则，什么时候用模型线上如何生成最终的排序得分正负样本介绍（规模和比例），如何构造负样本\n正样本可以定义为用户当天播放过的节目，也就是“喜欢”；\n\n负样本则有两种选择方案：\n（1）负样本指的是对用户曝光过的节目，但是用户至始至终都没有播放过，也就是说该节目并不在“历史”和“喜欢”两个分类里面；（2）负样本指的是在整个抽样的池子里面，但是用户至始至终都没有播放过，也就是说该节目并不在“历史”和“喜欢”这两个分类里面，我们会选择给用户曝光但是用户没有进行播放的节目作为负阳本；\n\n假设正样本的条数是N，则负样本的条数会控制在2N或者3N，即遵循1:2或者1:3的关系，当然具体的业务场景下要进行不同的尝试和离线评估指标的对比。\n\n\n低活用户特征稀疏如何解决\n扩充用户画像：注册时统计更多用户静态信息，询问用户喜欢类别等；\n\n","slug":"推荐系统面试题&解答","date":"2021-12-15T06:22:35.000Z","categories_index":"AI","tags_index":"推荐系统","author_index":"析构理想"}]